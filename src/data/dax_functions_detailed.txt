APPROXIMATEDISTINCTCOUNT: Syntax - ***start of code*** APPROXIMATEDISTINCTCOUNT(<columnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The approximate number of distinct values in***start of code*** column ***end of code***. ~ Remarks -  ~ Example - There is no provided example for this function.
AVERAGE: Syntax - ***start of code*** AVERAGE(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns a decimal number that represents the arithmetic mean of the numbers in the column. ~ Remarks - This function takes the specified column as an argument and finds the average of the values in that column. If you want to find the average of an expression that evaluates to a set of numbers, use the AVERAGEX function instead. Nonnumeric values in the column are handled as followsIf the column contains text, no aggregation can be performed, and the functions returns blanks.If the column contains logical values or empty cells, those values are ignored.Cells with the value zero are included. If the column contains text, no aggregation can be performed, and the functions returns blanks. If the column contains logical values or empty cells, those values are ignored. Cells with the value zero are included. When you average cells, you must keep in mind the difference between an empty cell and a cell that contains the value 0 (zero). When a cell contains 0, it is added to the sum of numbers and the row is counted among the number of rows used as the divisor. However, when a cell contains a blank, the row is not counted. Whenever there are no rows to aggregate, the function returns a blank. However, if there are rows, but none of them meet the specified criteria, the function returns 0. Excel also returns a zero if no rows are found that meet the conditions. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following formula returns the average of the values in the column, ExtendedSalesAmount, in the table, InternetSales. ***start of code*** = AVERAGE(InternetSales[ExtendedSalesAmount]) ***end of code***
AVERAGEA: Syntax - ***start of code*** AVERAGEA(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - The AVERAGEA function takes a column and averages the numbers in it, but also handles non-numeric data types according to the following rulesValues that evaluates to***start of code*** TRUE ***end of code***count as 1.Values that evaluate to***start of code*** FALSE ***end of code***count as 0 (zero).Values that contain non-numeric text count as 0 (zero).Empty text ("") counts as 0 (zero). Values that evaluates to***start of code*** TRUE ***end of code***count as 1. Values that evaluate to***start of code*** FALSE ***end of code***count as 0 (zero). Values that contain non-numeric text count as 0 (zero). Empty text ("") counts as 0 (zero). If you do not want to include logical values and text representations of numbers in a reference as part of the calculation, use the AVERAGE function. Whenever there are no rows to aggregate, the function returns a blank.  However, if there are rows, but none of them meet the specified criteria, the function returns 0. Microsoft Excel also returns a zero if no rows are found that meet the conditions. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example returns the average of non-blank cells in the referenced column, given the following table. If you used the AVERAGE function, the mean would be 21/2; with the AVERAGEA function, the result is 22/5. Transaction IDAmountResult00001231Counts as 1000012420Counts as 200000125n/aCounts as 00000126Counts as 00000126***start of code*** TRUE ***end of code***Counts as 1 ***start of code*** = AVERAGEA([Amount]) ***end of code***
AVERAGEX: Syntax - ***start of code*** AVERAGEX(<table>,<expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - The AVERAGEX function enables you to evaluate expressions for each row of a table, and then take the resulting set of values and calculate its arithmetic mean. Therefore, the function takes a table as its first argument, and an expression as the second argument. In all other respects, AVERAGEX follows the same rules as AVERAGE. You cannot include non-numeric or null cells. Both the table and expression arguments are required. When there are no rows to aggregate, the function returns a blank.  When there are rows, but none of them meet the specified criteria, then the function returns 0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example calculates the average freight and tax on each order in the InternetSales table, by first summing Freight plus TaxAmt in each row, and then averaging those sums. ***start of code*** = AVERAGEX(InternetSales, InternetSales[Freight]+ InternetSales[TaxAmt]) ***end of code*** If you use multiple operations in the expression used as the second argument, you must use parentheses to control the order of calculations. For more information, seeDAX Syntax Reference.
COUNT: Syntax - ***start of code*** COUNT(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. ~ Remarks - The only argument allowed to this function is a column. The COUNT function counts rows that contain the following kinds of valuesNumbersDatesStrings Numbers Dates Strings When the function finds no rows to count, it returns a blank. Blank values are skipped.***start of code*** TRUE ***end of code***/***start of code*** FALSE ***end of code***values are not supported. If you want to evaluate a column of***start of code*** TRUE ***end of code***/***start of code*** FALSE ***end of code***values, use the COUNTA function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. For best practices when using COUNT, seeUse COUNTROWS instead of COUNT. ~ Example - The following example shows how to count the number of values in the column, ShipDate. ***start of code*** = COUNT([ShipDate]) ***end of code*** To count logical values or text, use the COUNTA or COUNTAX functions.
COUNTA: Syntax - ***start of code*** COUNTA(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. ~ Remarks - When the function does not find any rows to count, the function returns a blank. UnlikeCOUNT, COUNTA supports Boolean data type. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example returns the number of all rows in the***start of code*** Reseller ***end of code***table that have any kind of value in the column that stores phone numbers. ***start of code*** = COUNTA(Reseller[Phone]) ***end of code***
COUNTAX: Syntax - ***start of code*** COUNTAX(<table>,<expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. ~ Remarks - Like the COUNTA function, the COUNTAX function counts cells containing any type of information, including other expressions. For example, if the column contains an expression that evaluates to an empty string, the COUNTAX function treats that result as non-blank. Usually the COUNTAX function does not count empty cells but in this case the cell contains a formula, so it is counted. Whenever the function finds no rows to aggregate, the function returns a blank. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example counts the number of nonblank rows in the column, Phone, using the table that results from filtering the Reseller table on***start of code*** [Status] = Active ***end of code***. ***start of code*** = COUNTAX(FILTER('Reseller',[Status]="Active"),[Phone]) ***end of code***
COUNTBLANK: Syntax - ***start of code*** COUNTBLANK(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. If no rows are found that meet the condition, blanks are returned. ~ Remarks - The only argument allowed to this function is a column. You can use columns containing any type of data, but only blank cells are counted. Cells that have the value zero (0) are not counted, as zero is considered a numeric value and not a blank. Whenever there are no rows to aggregate, the function returns a blank.  However, if there are rows, but none of them meet the specified criteria, the function returns 0. Microsoft Excel also returns a zero if no rows are found that meet the conditions. In other words, if the COUNTBLANK function finds no blanks, the result will be zero, but if there are no rows to check, the result will be blank. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows how to count the number of rows in the table Reseller that have blank values for BankName. ***start of code*** = COUNTBLANK(Reseller[BankName]) ***end of code*** To count logical values or text, use the COUNTA or COUNTAX functions.
COUNTROWS: Syntax - ***start of code*** COUNTROWS([<table>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. ~ Remarks - This function can be used to count the number of rows in a base table, but more often is used to count the number of rows that result from filtering a table, or applying context to a table. When the table argument contains no rows, the function returns BLANK. To learn more about best practices when using COUNT and COUNTROWS, seeUse COUNTROWS instead of COUNT in DAX. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
COUNTX: Syntax - ***start of code*** COUNTX(<table>,<expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer. ~ Remarks - The COUNTX function takes two arguments. The first argument must always be a table, or any expression that returns a table. The second argument is the column or expression that is searched by COUNTX. The COUNTX function counts only values, dates, or strings. If the function finds no rows to count, it returns a blank. If you want to count logical values, use the COUNTAX function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
DISTINCTCOUNT: Syntax - ***start of code*** DISTINCTCOUNT(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The number of distinct values in***start of code*** column ***end of code***. ~ Remarks - The only argument allowed to this function is a column. You can use columns containing any type of data. When the function finds no rows to count, it returns a BLANK, otherwise it returns the count of distinct values. DISTINCTCOUNT function counts the BLANK value. To skip the BLANK value, use theDISTINCTCOUNTNOBLANKfunction. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows how to count the number of distinct sales orders in the column ResellerSales_USD[SalesOrderNumber]. ***start of code*** = DISTINCTCOUNT(ResellerSales_USD[SalesOrderNumber]) ***end of code*** Using the above measure in a table with calendar year in the side and product category on top returns the following results Row LabelsAccessoriesBikesClothingComponents-Grand Total2005135345242205366200635685064470210152007531123496311381521200829372456160189411Grand Total131531532410264613797 In the above example, note that the rows Grand Total numbers do not add up, this happens because the same order might contain line items, in the same order, from different product categories.
DISTINCTCOUNTNOBLANK: Syntax - ***start of code*** DISTINCTCOUNTNOBLANK(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The number of distinct values in***start of code*** column ***end of code***. ~ Remarks - UnlikeDISTINCTCOUNTfunction, DISTINCTCOUNTNOBLANK does not count the BLANK value. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows how to count the number of distinct sales orders in the column ResellerSales_USD[SalesOrderNumber]. ***start of code*** = DISTINCTCOUNT(ResellerSales_USD[SalesOrderNumber]) ***end of code*** DAX query ***start of code*** EVALUATE    ROW(        "DistinctCountNoBlank", DISTINCTCOUNTNOBLANK(DimProduct[EndDate]),        "DistinctCount", DISTINCTCOUNT(DimProduct[EndDate])    ) ***end of code*** [DistinctCountNoBlank][DistinctCount]23
MAX: Syntax - ***start of code*** MAX(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The largest value. ~ Remarks - When comparing two expressions, blank is treated as 0 when comparing. That is, Max(1, Blank() ) returns 1, and Max( -1, Blank() ) returns 0. If both arguments are blank, MAX returns a blank. If either expression returns a value which is not allowed, MAX returns an error. ***start of code*** TRUE ***end of code***/***start of code*** FALSE ***end of code***values are not supported. If you want to evaluate a column of***start of code*** TRUE ***end of code***/***start of code*** FALSE ***end of code***values, use the MAXA function. ~ Example - There is no provided example for this function.
MAXA: Syntax - ***start of code*** MAXA(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The largest value. ~ Remarks - The MAXA function takes as argument a column, and looks for the largest value among the following types of valuesNumbersDates Numbers Dates Logical values, such as***start of code*** TRUE ***end of code***and***start of code*** FALSE ***end of code***. Rows that evaluate to***start of code*** TRUE ***end of code***count as 1; rows that evaluate to***start of code*** FALSE ***end of code***count as 0 (zero). Empty cells are ignored. If the column contains no values that can be used, MAXA returns 0 (zero). If you want to compare text values, use the MAX function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
MAXX: Syntax - ***start of code*** MAXX(<table>,<expression>,[<variant>])   ***end of code*** ~ Parameters - No parameters found ~ Return Value - The highest value. ~ Remarks - The***start of code*** table ***end of code***argument to the MAXX function can be a table name or an expression that evaluates to a table. The second argument indicates the expression to be evaluated for each row of the table. Of the values to evaluate, only the following are countedNumbersTextsDates Numbers Texts Dates Blank values are skipped.***start of code*** TRUE ***end of code***/***start of code*** FALSE ***end of code***values are not supported. If the expression has variant or mixed value types such as text and number, then by default MAXX considers only numbers. If***start of code*** <variant> =  ***end of code***TRUE``, the maximum value is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
MIN: Syntax - ***start of code*** MIN(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The smallest value. ~ Remarks - The MIN function takes a column or two expressions as an argument, and returns the smallest value. The following types of values in the columns are countedNumbersTextsDatesBlanks Numbers Texts Dates Blanks When comparing expressions, blank is treated as 0 when comparing. That is, Min(1,Blank() ) returns 0, and Min( -1, Blank() ) returns -1. If both arguments are blank, MIN returns a blank. If either expression returns a value which is not allowed, MIN returns an error. ***start of code*** TRUE ***end of code***/***start of code*** FALSE ***end of code***values are not supported. If you want to evaluate a column of***start of code*** TRUE ***end of code***/***start of code*** FALSE ***end of code***values, use the MINA function. ~ Example - There is no provided example for this function.
MINA: Syntax - ***start of code*** MINA(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The smallest value. ~ Remarks - The MINA function takes as argument a column that contains numbers, and determines the smallest value as followsIf the column contains no values, MINA returns 0 (zero).Rows in the column that evaluates to logical values, such as***start of code*** TRUE ***end of code***and***start of code*** FALSE ***end of code***are treated as 1 if***start of code*** TRUE ***end of code***and 0 (zero) if***start of code*** FALSE ***end of code***.Empty cells are ignored. If the column contains no values, MINA returns 0 (zero). Rows in the column that evaluates to logical values, such as***start of code*** TRUE ***end of code***and***start of code*** FALSE ***end of code***are treated as 1 if***start of code*** TRUE ***end of code***and 0 (zero) if***start of code*** FALSE ***end of code***. Empty cells are ignored. If you want to compare text values, use the MIN function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
MINX: Syntax - ***start of code*** MINX(<table>, < expression>,[<variant>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The lowest value. ~ Remarks - The MINX function takes as its first argument a table or an expression that returns a table. The second argument contains the expression that is evaluated for each row of the table. Blank values are skipped.***start of code*** TRUE ***end of code***/***start of code*** FALSE ***end of code***values are not supported. If the expression has variant or mixed value types such as text and number, then by default MINX considers only numbers. If***start of code*** <variant> = TRUE ***end of code***, the minimum value is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
PRODUCT: Syntax - ***start of code*** PRODUCT(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - To return the product of an expression evaluated for each row in a table, usePRODUCTX function. Only the numbers in the column are counted. Blanks, logical values, and text are ignored. For example,***start of code*** PRODUCT( Table[Column] ) ***end of code***is equivalent to***start of code*** PRODUCTX( Table, Table[Column] ) ***end of code***. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following computes the product of the AdjustedRates column in an Annuity table ***start of code*** = PRODUCT( Annuity[AdjustedRates] ) ***end of code***
PRODUCTX: Syntax - ***start of code*** PRODUCTX(<table>, <expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - To return the product of the numbers in a column, usePRODUCT. The PRODUCTX function takes as its first argument a table, or an expression that returns a table. The second argument is a column that contains the numbers for which you want to compute the product, or an expression that evaluates to a column. Only the numbers in the column are counted. Blanks, logical values, and text are ignored. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following computes the future value of an investment ***start of code*** = [PresentValue] * PRODUCTX( AnnuityPeriods, 1+[FixedInterestRate] ) ***end of code***
SUM: Syntax - ***start of code*** SUM(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks -  ~ Example - The following example adds all the numbers that are contained in the column, Amt, from the table, Sales. ***start of code*** = SUM(Sales[Amt]) ***end of code***
SUMX: Syntax - ***start of code*** SUMX(<table>, <expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - The SUMX function takes as its first argument a table, or an expression that returns a table. The second argument is a column that contains the numbers you want to sum, or an expression that evaluates to a column. The SUMX is aniterator function. Only the numbers in the column are counted. Blanks, logical values, and text are ignored. For more complex examples of SUMX in formulas, seeALLandCALCULATETABLE. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example first filters the table, InternetSales, on the expression, 'InternetSales[SalesTerritoryID] = 5`, and then returns the sum of all values in the Freight column. In other words, the expression returns the sum of freight charges for only the specified sales area. ***start of code*** = SUMX(FILTER(InternetSales, InternetSales[SalesTerritoryID]=5),[Freight]) ***end of code*** If you do not need to filter the column, use the SUM function. The SUM function is similar to the Excel function of the same name, except that it takes a column as a reference.
CALENDAR: Syntax - ***start of code*** CALENDAR(<start_date>, <end_date>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns a table with a single column named "Date" containing a contiguous set of dates. The range of dates is from the specified start date to the specified end date, inclusive of those two dates. ~ Remarks - An error is returned if start_date is greater than end_date. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
CALENDARAUTO: Syntax - ***start of code*** CALENDARAUTO([fiscal_year_end_month]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns a table with a single column named "Date" that contains a contiguous set of dates. The range of dates is calculated automatically based on data in the model. ~ Remarks - The date range is calculated as followsThe earliest date in the model which is not in a calculated column or calculated table is taken as the MinDate.The latest date in the model which is not in a calculated column or calculated table is taken as the MaxDate.The date range returned is dates between the beginning of the fiscal year associated with MinDate and the end of the fiscal year associated with MaxDate. The earliest date in the model which is not in a calculated column or calculated table is taken as the MinDate. The latest date in the model which is not in a calculated column or calculated table is taken as the MaxDate. The date range returned is dates between the beginning of the fiscal year associated with MinDate and the end of the fiscal year associated with MaxDate. An error is returned if the model does not contain any datetime values which are not in calculated columns or calculated tables. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - In this example, the MinDate and MaxDate in the data model are July 1, 2010 and June 30, 2011. ***start of code*** CALENDARAUTO() ***end of code***will return all dates between January 1, 2010 and December 31, 2011. ***start of code*** CALENDARAUTO(3) ***end of code***will return all dates between April 1, 2010 and March 31, 2012.
DATE: Syntax - ***start of code*** DATE(<year>, <month>, <day>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the specified date (***start of code*** datetime ***end of code***). ~ Remarks - The DATE function takes the integers that are input as arguments, and generates the corresponding date. The DATE function is most useful in situations where the year, month, and day are supplied by formulas. For example, the underlying data might contain dates in a format that is not recognized as a date, such as YYYYMMDD. You can use the DATE function in conjunction with other functions to convert the dates to a number that can be recognized as a date. In contrast to Microsoft Excel, which stores dates as a serial number, DAX date functions always return a***start of code*** datetime ***end of code***data type. However, you can use formatting to display dates as serial numbers if you want. Date and datetime can also be specified as a literal in the format***start of code*** dt"YYYY-MM-DD" ***end of code***,***start of code*** dt"YYYY-MM-DDThhmmss" ***end of code***, or***start of code*** dt"YYYY-MM-DD hhmmss" ***end of code***. When specified as a literal, using the DATE function in the expression is not necessary. To learn more, seeDAX Syntax | Date and time. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
DATEDIFF: Syntax - ***start of code*** DATEDIFF(<Date1>, <Date2>, <Interval>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The count of interval boundaries between two dates. ~ Remarks -  ~ Example - Examples in this article can be used with the sample Adventure Works DW 2020 Power BI Desktop model. To get the model, seeDAX sample model. The following DAX query ***start of code*** EVALUATEVAR StartDate =  DATE ( 2019, 07, 01 )VAR EndDate =    DATE ( 2021, 12, 31 )RETURN    {        ( "Year",     DATEDIFF ( StartDate, EndDate, YEAR ) ),        ( "Quarter",  DATEDIFF ( StartDate, EndDate, QUARTER ) ),        ( "Month",    DATEDIFF ( StartDate, EndDate, MONTH ) ),        ( "Week",     DATEDIFF ( StartDate, EndDate, WEEK ) ),        ( "Day",      DATEDIFF ( StartDate, EndDate, DAY ) )    }  ***end of code*** Returns the following Value1Value2Year2Quarter9Month29Week130Day914
DATEVALUE: Syntax - ***start of code*** DATEVALUE(date_text) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - When converting, DATEVALUE uses the locale and date/time settings of the model to determine a date value. If the model date/time settings represent dates in the format of Month/Day/Year, then the string, "1/8/2009", is converted to a***start of code*** datetime ***end of code***value equivalent to January 8th of 2009. However, if the model date/time settings represent dates in the format of Day/Month/Year, the same string is converted as a***start of code*** datetime ***end of code***value equivalent to August 1st of 2009. If conversion using the locale and date/time settings of the model fails, DATEVALUE will attempt to use other date formats. In this case, some rows may be converted using one format and other rows are converted using a different format. For example, "5/4/2018" may convert to May 4th of 2018, and "20/4/2018" may convert to April 20th. If the year portion of the***start of code*** date_text ***end of code***argument is omitted, the DATEVALUE function uses the current year from your computer's built-in clock. Time information in the***start of code*** date_text ***end of code***argument is ignored. Model locale and data/time settings are initially determined by the application and computer when the model is created. Date and datetime can also be specified as a literal in the format***start of code*** dt"YYYY-MM-DD" ***end of code***,***start of code*** dt"YYYY-MM-DDThhmmss" ***end of code***, or***start of code*** dt"YYYY-MM-DD hhmmss" ***end of code***. When specified as a literal, using the DATEVALUE function in the expression is not necessary. To learn more, seeDAX Syntax | Date and time. ~ Example - The following example returns a different***start of code*** datetime ***end of code***value depending on the model locale and settings for how dates and times are presented. In date/time settings where the day precedes the month, the example returns a***start of code*** datetime ***end of code***value corresponding to January 8th of 2009.In date/time settings where the month precedes the day, the example returns a***start of code*** datetime ***end of code***value corresponding to August 1st of 2009. ***start of code*** = DATEVALUE("8/1/2009") ***end of code***
DAY: Syntax - ***start of code*** DAY(<date>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer number indicating the day of the month. ~ Remarks - The DAY function takes as an argument the date of the day you are trying to find. Dates can be provided to the function by using another date function, by using an expression that returns a date, or by typing a date in a***start of code*** datetime ***end of code***format. You can also type a date in one of the accepted string formats for dates. Values returned by the YEAR, MONTH and DAY functions will be Gregorian values regardless of the display format for the supplied date value. For example, if the display format of the supplied date is Hijri, the returned values for the YEAR, MONTH and DAY functions will be values associated with the equivalent Gregorian date. When the date argument is a text representation of the date, the day function uses the locale and date/time settings of the client computer to understand the text value in order to perform the conversion. If the current date/time settings represent dates in the format of Month/Day/Year, then the string, "1/8/2009", is interpreted as a***start of code*** datetime ***end of code***value equivalent to January 8th of 2009, and the function returns 8. However, if the current date/time settings represent dates in the format of Day/Month/Year, the same string would be interpreted as a***start of code*** datetime ***end of code***value equivalent to August 1st of 2009, and the function returns 1. ~ Example - There is no provided example for this function.
EDATE: Syntax - ***start of code*** EDATE(<start_date>, <months>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A date (***start of code*** datetime ***end of code***). ~ Remarks - In contrast to Microsoft Excel, which stores dates as sequential serial numbers, DAX works with dates in a***start of code*** datetime ***end of code***format. Dates stored in other formats are converted implicitly. If***start of code*** start_date ***end of code***is not a valid date, EDATE returns an error. Make sure that the column reference or date that you supply as the first argument is a date. If***start of code*** months ***end of code***is not an integer, it is truncated. When the date argument is a text representation of the date, the EDATE function uses the locale and date time settings of the client computer to understand the text value in order to perform the conversion. If the current date time settings represent a date in the format of Month/Day/Year, then the following string "1/8/2009" is interpreted as a datetime value equivalent to January 8th of 2009. However, if the current date time settings represent a date in the format of Day/Month/Year, the same string would be interpreted as a datetime value equivalent to August 1st of 2009. If the requested date is past the last day of the corresponding month, then the last day of the month is returned. For example, the following functions EDATE("2009-01-29", 1), EDATE("2009-01-30", 1), EDATE("2009-01-31", 1) return February 28th of 2009; that corresponds to one month after the start date. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example returns the date three months after the order date, which is stored in the column [TransactionDate]. ***start of code*** = EDATE([TransactionDate],3) ***end of code***
EOMONTH: Syntax - ***start of code*** EOMONTH(<start_date>, <months>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A date (***start of code*** datetime ***end of code***). ~ Remarks - In contrast to Microsoft Excel, which stores dates as sequential serial numbers, DAX works with dates in a***start of code*** datetime ***end of code***format. The EOMONTH function can accept dates in other formats, with the following restrictions If***start of code*** start_date ***end of code***is not a valid date, EOMONTH returns an error. If***start of code*** start_date ***end of code***is a numeric value that is not in a***start of code*** datetime ***end of code***format, EOMONTH will convert the number to a date. To avoid unexpected results, convert the number to a***start of code*** datetime ***end of code***format before using the EOMONTH function. If***start of code*** start_date ***end of code***plus months yields an invalid date, EOMONTH returns an error. Dates before March 1st of 1900 and after December 31st of 9999 are invalid. When the date argument is a text representation of the date, the EDATE function uses the locale and date time settings, of the client computer, to understand the text value in order to perform the conversion. If current date time settings represent a date in the format of Month/Day/Year, then the following string "1/8/2009" is interpreted as a datetime value equivalent to January 8th of 2009. However, if the current date time settings represent a date in the format of Day/Month/Year, the same string would be interpreted as a datetime value equivalent to August 1st of 2009. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following expression returns May 31, 2008, because the***start of code*** months ***end of code***argument is rounded to 2. ***start of code*** = EOMONTH("March 3, 2008",1.5) ***end of code***
HOUR: Syntax - ***start of code*** HOUR(<datetime>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer number from 0 to 23. ~ Remarks - The HOUR function takes as argument the time that contains the hour you want to find. You can supply the time by using a date/time function, an expression that returns a***start of code*** datetime ***end of code***, or by typing the value directly in one of the accepted time formats. Times can also be entered as any accepted text representation of a time. When the***start of code*** datetime ***end of code***argument is a text representation of the date and time, the function uses the locale and date/time settings of the client computer to understand the text value in order to perform the conversion. Most locales use the colon () as the time separator and any input text using colons as time separators will parse correctly. Review your locale settings to understand your results. ~ Example - There is no provided example for this function.
MINUTE: Syntax - ***start of code*** MINUTE(<datetime>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer number from 0 to 59. ~ Remarks - In contrast to Microsoft Excel, which stores dates and times in a serial numeric format, DAX uses a***start of code*** datetime ***end of code***data type for dates and times. You can provide the***start of code*** datetime ***end of code***value to the MINUTE function by referencing a column that stores dates and times, by using a date/time function, or by using an expression that returns a date and time. When the***start of code*** datetime ***end of code***argument is a text representation of the date and time, the function uses the locale and date/time settings of the client computer to understand the text value in order to perform the conversion. Most locales use the colon () as the time separator and any input text using colons as time separators will parse correctly. Verify your locale settings to understand your results. ~ Example - There is no provided example for this function.
MONTH: Syntax - ***start of code*** MONTH(<datetime>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer number from 1 to 12. ~ Remarks - In contrast to Microsoft Excel, which stores dates as serial numbers, DAX uses a***start of code*** datetime ***end of code***format when working with dates. You can enter the date used as argument to the MONTH function by typing an accepted***start of code*** datetime ***end of code***format, by providing a reference to a column that contains dates, or by using an expression that returns a date. Values returned by the YEAR, MONTH and DAY functions will be Gregorian values regardless of the display format for the supplied date value. For example, if the display format of the supplied date is Hijri, the returned values for the YEAR, MONTH and DAY functions will be values associated with the equivalent Gregorian date. When the date argument is a text representation of the date, the function uses the locale and date time settings of the client computer to understand the text value in order to perform the conversion. If the current date time settings represent a date in the format of Month/Day/Year, then the following string "1/8/2009" is interpreted as a datetime value equivalent to January 8th of 2009, and the function yields a result of 1. However, if the current date time settings represent a date in the format of Day/Month/Year, then the same string would be interpreted as a datetime value equivalent to August 1st of 2009, and the function yields a result of 8. If the text representation of the date cannot be correctly converted to a datetime value, the function returns an error. ~ Example - There is no provided example for this function.
NETWORKDAYS: Syntax - ***start of code*** NETWORKDAYS(<start_date>, <end_date>[, <weekend>, <holidays>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - This DAX function is similar to Excel NETWORKDAYS.INTL and NETWORKDAYS functions. If start_date and end_date both are BLANK, the output value is also BLANK. If either start_date or end_date is BLANK, the BLANK start_date or end_date will be treated as Date(1899, 12, 30). Dates must be specified by usingDATE functionor as the result of another expression. For example,***start of code*** DATE ( 2022, 5, 30 ) ***end of code***, specifies May 30th, 2022. Dates can also be specified as aliteralin format,***start of code*** (dt”2022-05-30”) ***end of code***. Do not specify dates as text. ~ Example - The following expression ***start of code***    = NETWORKDAYS (        DATE ( 2022, 5, 28 ),        DATE ( 2022, 5, 30 ),        1,        {            DATE ( 2022, 5, 30 )        }    ) ***end of code*** Returns [Value]0 In this example, 0 is returned because the start date is a Saturday and the end date is a Monday. The weekend parameter specifies that the weekend is Saturday and Sunday, so those are not work days. The holiday parameter marks the 30th (the end date) as a holiday, so no working days remain.
NOW: Syntax - ***start of code*** NOW() ***end of code*** ~ Parameters - No parameters found ~ Return Value - A date (***start of code*** datetime) ***end of code***. ~ Remarks - The result of the***start of code*** NOW ***end of code***function changes only when the column that contains the formula is refreshed. It is not updated continuously. In the Power BI Service, the result of the***start of code*** NOW ***end of code***function is always in the UTC timezone. The***start of code*** TODAY ***end of code***function returns the same date but is not precise with regard to time; the time returned is always 120000 AM and only the date is updated. ~ Example - The following example returns the current date and time plus 3.5 days ***start of code*** = NOW()+3.5 ***end of code***
QUARTER: Syntax - ***start of code*** QUARTER(<date>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer number from 1 to 4. ~ Remarks -  ~ Example - There is no provided example for this function.
SECOND: Syntax - ***start of code*** SECOND(<time>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer number from 0 to 59. ~ Remarks - In contrast to Microsoft Excel, which stores dates and times as serial numbers, DAX uses a***start of code*** datetime ***end of code***format when working with dates and times. If the source data is not in this format, DAX implicitly converts the data. You can use formatting to display the dates and times as a serial number of you need to. The date/time value that you supply as an argument to the SECOND function can be entered as a text string within quotation marks (for example, "645 PM"). You can also provide a time value as the result of another expression, or as a reference to a column that contains times. If you provide a numeric value of another data type, such as 13.60, the value is interpreted as a serial number and is represented as a***start of code*** datetime ***end of code***data type before extracting the value for seconds. To make it easier to understand your results, you might want to represent such numbers as dates before using them in the SECOND function. For example, if you use SECOND with a column that contains a numeric value such as,25.56, the formula returns 24. That is because, when formatted as a date, the value 25.56 is equivalent to January 25, 1900, 12624 PM. When the***start of code*** time ***end of code***argument is a text representation of a date and time, the function uses the locale and date/time settings of the client computer to understand the text value in order to perform the conversion. Most locales use the colon () as the time separator and any input text using colons as time separators will parse correctly. Review your locale settings to understand your results. ~ Example - There is no provided example for this function.
TIME: Syntax - ***start of code*** TIME(hour, minute, second) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A time (***start of code*** datetime ***end of code***) ranging from 000000 (120000 AM) to 235959 (115959 PM). ~ Remarks - In contrast to Microsoft Excel, which stores dates and times as serial numbers, DAX works with date and time values in a***start of code*** datetime ***end of code***format. Numbers in other formats are implicitly converted when you use a date/time value in a DAX function. If you need to use serial numbers, you can use formatting to change the way that the numbers are displayed. Time values are a portion of a date value, and in the serial number system are represented by a decimal number. Therefore, the***start of code*** datetime ***end of code***value 1200 PM is equivalent to 0.5, because it is half of a day. You can supply the arguments to the TIME function as values that you type directly, as the result of another expression, or by a reference to a column that contains a numeric value. Date and datetime can also be specified as a literal in the format***start of code*** dt"YYYY-MM-DD" ***end of code***,***start of code*** dt"YYYY-MM-DDThhmmss" ***end of code***, or***start of code*** dt"YYYY-MM-DD hhmmss" ***end of code***. When specified as a literal, using the TIME function in the expression is not necessary. To learn more, seeDAX Syntax | Date and time. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
TIMEVALUE: Syntax - ***start of code*** TIMEVALUE(time_text) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A date (***start of code*** datetime ***end of code***). ~ Remarks - Time values are a portion of a date value and represented by a decimal number. For example, 1200 PM is represented as 0.5 because it is half of a day. When the***start of code*** time_text ***end of code***argument is a text representation of the date and time, the function uses the locale and date/time settings of the model to understand the text value in order to perform the conversion. Most locales use the colon () as the time separator, and any input text using colons as time separators will parse correctly. Review your locale settings to understand your results. Date and datetime can also be specified as a literal in the format***start of code*** dt"YYYY-MM-DD" ***end of code***,***start of code*** dt"YYYY-MM-DDThhmmss" ***end of code***, or***start of code*** dt"YYYY-MM-DD hhmmss" ***end of code***. When specified as a literal, using the TIMEVALUE function in the expression is not necessary. To learn more, seeDAX Syntax | Date and time. ~ Example - ***start of code*** = TIMEVALUE("204530") ***end of code***
TODAY: Syntax - ***start of code*** TODAY() ***end of code*** ~ Parameters - No parameters found ~ Return Value - A date (***start of code*** datetime ***end of code***). ~ Remarks - The TODAY function is useful when you need to have the current date displayed on a worksheet, regardless of when you open the workbook. It is also useful for calculating intervals. If the TODAY function does not update the date when you expect it to, you might need to change the settings that control when the column or workbook is refreshed.. The NOW function is similar but returns the exact time, whereas TODAY returns the time value 120000 PM for all dates. ~ Example - If you know that someone was born in 1963, you might use the following formula to find that person's age as of this year's birthday ***start of code*** = YEAR(TODAY())-1963 ***end of code*** This formula uses the TODAY function as an argument for the YEAR function to obtain the current year, and then subtracts 1963, returning the person's age.
UTCNOW: Syntax - ***start of code*** UTCNOW() ***end of code*** ~ Parameters - No parameters found ~ Return Value - A***start of code*** datetime ***end of code***. ~ Remarks -  ~ Example - The following ***start of code*** EVALUATE { FORMAT(UTCNOW(), "General Date") } ***end of code*** Returns Value2/2/2018 44808 AM
UTCTODAY: Syntax - ***start of code*** UTCTODAY() ***end of code*** ~ Parameters - No parameters found ~ Return Value - A date. ~ Remarks - UTCTODAY returns the time value 120000 PM for all dates. The UTCNOW function is similar but returns the exact time and date. ~ Example - The following ***start of code*** EVALUATE { FORMAT(UTCTODAY(), "General Date") } ***end of code*** Returns [Value]2/2/2018
WEEKDAY: Syntax - ***start of code*** WEEKDAY(<date>, <return_type>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer number from 1 to 7. ~ Remarks - In contrast to Microsoft Excel, which stores dates as serial numbers, DAX works with dates and times in a***start of code*** datetime ***end of code***format. If you need to display dates as serial numbers, you can use the formatting options in Excel. You can also type dates in an accepted text representation of a date, but to avoid unexpected results, it is best to convert the text date to a***start of code*** datetime ***end of code***format first. When the date argument is a text representation of the date, the function uses the locale and date/time settings of the client computer to understand the text value in order to perform the conversion. If the current date/time settings represent dates in the format of Month/Day/Year, then the string, "1/8/2009", is interpreted as a***start of code*** datetime ***end of code***value equivalent to January 8th of 2009. However, if the current date/time settings represent dates in the format of Day/Month/Year, then the same string would be interpreted as a***start of code*** datetime ***end of code***value equivalent to August 1st of 2009. ~ Example - The following example gets the date from the [HireDate] column, adds 1, and displays the weekday corresponding to that date. Because the***start of code*** return_type ***end of code***argument has been omitted, the default format is used, in which 1 is Sunday and 7 is Saturday. If the result is 4, the day would be Wednesday. ***start of code*** = WEEKDAY([HireDate]+1) ***end of code***
WEEKNUM: Syntax - ***start of code*** WEEKNUM(<date>[, <return_type>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer number. ~ Remarks - By default, the WEEKNUM function uses a calendar convention in which the week containing January 1 is considered to be the first week of the year. However, the ISO 8601 calendar standard, widely used in Europe, defines the first week as the one with the majority of days (four or more) falling in the new year. This means that if***start of code*** return_type ***end of code***is any valid value other than 21, for any years in which there are three days or less in the first week of January, the WEEKNUM function returns week numbers that are different from the ISO 8601 definition. For***start of code*** return_type ***end of code***, the following valid values  may not be supported by some DirectQuery data sourcesreturn_typeWeek begins onSystem1 or omittedSunday12Monday111Monday112Tuesday113Wednesday114Thursday115Friday116Saturday117Sunday121Monday2 ~ Example - There is no provided example for this function.
YEAR: Syntax - ***start of code*** YEAR(<date>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer in the range 1900-9999. ~ Remarks - In contrast to Microsoft Excel, which stores dates as serial numbers, DAX uses a***start of code*** datetime ***end of code***data type to work with dates and times. Dates should be entered by using the DATE function, or as results of other formulas or functions. You can also enter dates in accepted text representations of a date, such as March 3, 2007, or Mar-3-2003. Values returned by the YEAR, MONTH, and DAY functions will be Gregorian values regardless of the display format for the supplied date value. For example, if the display format of the supplied date uses the Hijri calendar, the returned values for the YEAR, MONTH, and DAY functions will be values associated with the equivalent Gregorian date. When the date argument is a text representation of the date, the function uses the locale and date time settings of the client computer to understand the text value in order to perform the conversion. Errors may arise if the format of strings is incompatible with the current locale settings. For example, if your locale defines dates to be formatted as month/day/year, and the date is provided as day/month/year, then 25/1/2009 will not be interpreted as January 25th of 2009 but as an invalid date. ~ Example - The following example returns 2007. ***start of code*** = YEAR("March 2007") ***end of code***
YEARFRAC: Syntax - ***start of code*** YEARFRAC(<start_date>, <end_date>, <basis>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. The internal data type is a signed IEEE 64-bit (8-byte) double-precision floating-point number. ~ Remarks - In contrast to Microsoft Excel, which stores dates as serial numbers, DAX uses a***start of code*** datetime ***end of code***format to work with dates and times. If you need to view dates as serial numbers, you can use the formatting options in Excel. If***start of code*** start_date ***end of code***or***start of code*** end_date ***end of code***are not valid dates, YEARFRAC returns an error. If***start of code*** basis ***end of code***< 0 or if***start of code*** basis ***end of code***> 4, YEARFRAC returns an error. ~ Example - There is no provided example for this function.
ALL: Syntax - ***start of code*** ALL( [<table> | <column>[, <column>[, <column>[,…]]]] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The table or column with filters removed. ~ Remarks - This function is not used by itself, but serves as an intermediate function that can be used to change the set of results over which some other calculation is performed. The normal behavior for DAX expressions containing the ALL() function is that any filters applied will be ignored. However, there are some scenarios where this is not the case because of***start of code*** auto-exist ***end of code***, a DAX technology that optimizes filtering in order to reduce the amount of processing required for certain DAX queries. An example where auto-exist and ALL() provide unexpected results is when filtering on two or more columns of the same table (like when using slicers), and there is a measure on that same table that uses ALL(). In this case, auto-exist willmergethe multiple filters into one and will only filter on existing combinations of values. Because of this merge, the measure will be calculated on the existing combinations of values and the result will be based on filtered values instead of all values as expected. To learn more about auto-exist and its effect on calculations, see Microsoft MVP Alberto Ferrari'sUnderstanding DAX Auto-Existarticle onsql.bi.com. The following table describes how you can use the ALL and ALLEXCEPT functions in different scenarios.Function and usageDescriptionALL()Removes all filters everywhere. ALL() can only be used to clear filters but not to return a table.ALL(Table)Removes all filters from the specified table. In effect, ALL(Table) returns all of the values in the table, removing any filters from the context that otherwise might have been applied. This function is useful when you are working with many levels of grouping, and want to create a calculation that creates a ratio of an aggregated value to the total value. The first example demonstrates this scenario.ALL (Column[, Column[, …]])Removes all filters from the specified columns in the table; all other filters on other columns in the table still apply. All column arguments must come from the same table. The ALL(Column) variant is useful when you want to remove the context filters for one or more specific columns and to keep all other context filters. The second and third examples demonstrate this scenario.ALLEXCEPT(Table, Column1 [,Column2]...)Removes all context filters in the table except filters that are applied to the specified columns. This is a convenient shortcut for situations in which you want to remove the filters on many, but not all, columns in a table. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
ALLCROSSFILTERED: Syntax - ***start of code*** ALLCROSSFILTERED(<table>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - N/A. See remarks. ~ Remarks - ALLCROSSFILTERED can only be used to clear filters but not to return a table. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - ***start of code*** DEFINEMEASURE FactInternetSales[TotalQuantity1] =    CALCULATE(SUM(FactInternetSales[OrderQuantity]), ALLCROSSFILTERED(FactInternetSales))MEASURE FactInternetSales[TotalQuantity2] =    CALCULATE(SUM(FactInternetSales[OrderQuantity]), ALL(FactInternetSales))EVALUATE    SUMMARIZECOLUMNS(DimSalesReason[SalesReasonName],         "TotalQuantity1", [TotalQuantity1],        "TotalQuantity2", [TotalQuantity2])    ORDER BY DimSalesReason[SalesReasonName] ***end of code*** Returns, DimSalesReason[SalesReasonName][TotalQuantity1][TotalQuantity2]Demo Event60398Magazine Advertisement60398Manufacturer603981818On Promotion603987390Other603983653Price6039847733Quality603981551Review603981640Sponsorship60398Television  Advertisement60398730 NoteThere is a direct or indirect many-to-many relationship between FactInternetSales table and DimSalesReason table.
ALLEXCEPT: Syntax - ***start of code*** ALLEXCEPT(<table>,<column>[,<column>[,…]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table with all filters removed except for the filters on the specified columns. ~ Remarks - This function is not used by itself, but serves as an intermediate function that can be used to change the set of results over which some other calculation is performed. ALL and ALLEXCEPT can be used in different scenariosFunction and usageDescriptionALL(Table)Removes all filters from the specified table. In effect, ALL(Table) returns all of the values in the table, removing any filters from the context that otherwise might have been applied. This function is useful when you are working with many levels of grouping, and want to create a calculation that creates a ratio of an aggregated value to the total value.ALL (Column[, Column[, …]])Removes all filters from the specified columns in the table; all other filters on other columns in the table still apply. All column arguments must come from the same table. The ALL(Column) variant is useful when you want to remove the context filters for one or more specific columns and to keep all other context filters.ALLEXCEPT(Table, Column1 [,Column2]...)Removes all context filters in the table except filters that are applied to the specified columns. This is a convenient shortcut for situations in which you want to remove the filters on many, but not all, columns in a table. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following measure formula sums SalesAmount_USD and uses the ALLEXCEPT function to remove any context filters on the DateTime table except if the filter has been applied to the CalendarYear column. ***start of code*** = CALCULATE(SUM(ResellerSales_USD[SalesAmount_USD]), ALLEXCEPT(DateTime, DateTime[CalendarYear])) ***end of code*** Because the formula uses ALLEXCEPT, whenever any column but CalendarYear from the table DateTime is used to slice a visualization, the formula will remove any slicer filters, providing a value equal to the sum of SalesAmount_USD. However, if the column CalendarYear is used to slice the visualization, the results are different. Because CalendarYear is specified as the argument to ALLEXCEPT, when the data is sliced on the year, a filter will be applied on years at the row level
ALLNOBLANKROW: Syntax - ***start of code*** ALLNOBLANKROW( {<table> | <column>[, <column>[, <column>[,…]]]} ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table, when the passed parameter was a table, or a column of values, when the passed parameter was a column. ~ Remarks - The ALLNOBLANKROW function only filters the blank row that a parent table, in a relationship, will show when there are one or more rows in the child table that have non-matching values to the parent column. See the example below for a thorough explanation. The following table summarizes the variations of***start of code*** ALL ***end of code***that are provided in DAX, and their differencesFunction and usageDescription***start of code*** ALL(Column) ***end of code***Removes all filters from the specified column in the table; all other filters in the table, over other columns, still apply.***start of code*** ALL(Table) ***end of code***Removes all filters from the specified table.***start of code*** ALLEXCEPT(Table,Col1,Col2...) ***end of code***Overrides all context filters in the table except over the specified columns.***start of code*** ALLNOBLANK(table|column) ***end of code***From the parent table of a relationship, returns all rows but the blank row, or all distinct values of a column but the blank row, and disregards any context filters that might existFor a general description of how the ALL function works, together with step-by-step examples that use ALL(Table) and ALL(Column), seeALL function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - In the sample data, the ResellerSales_USD table contains one row that has no values and therefore cannot be related to any of the parent tables in the relationships within the workbook. You will use this table in a PivotTable so that you can see the blank row behavior and how to handle counts on unrelated data. Step 1 Verify the unrelated data Open thePower Pivot window, then select the ResellerSales_USD table. In the ProductKey column, filter for blank values. One row will remain. In that row, all column values should be blank except for SalesOrderLineNumber. Step 2 Create a PivotTable Create a new PivotTable, then drag the column, datetime.[Calendar Year], to the Row Labels pane. The following table shows the expected results Row Labels2005200620072008Grand Total Note the blank label between2008andGrand Total. This blank label represents the Unknown member, which is a special group that is created to account for any values in the child table that have no matching value in the parent table, in this example the datetime.[Calendar Year] column. When you see this blank label in the PivotTable, you know that in some of the tables that are related to the column, datetime.[Calendar Year], there are either blank values or non-matching values. The parent table is the one that shows the blank label, but the rows that do not match are in one or more of the child tables. The rows that get added to this blank label group are either values that do not match any value in the parent table-- for example, a date that does not exist in the datetime table-- or null values, meaning no value for date at all. In this example we have placed a blank value in all columns of the child sales table. Having more values in the parent table than in the children tables does not cause a problem. Step 3 Count rows using ALL and ALLNOBLANK Add the following two measures to the datetime table, to count the table rowsCountrows ALLNOBLANK of datetime,Countrows ALL of datetime. The formulas that you can use to define these measures are ***start of code*** // Countrows ALLNOBLANK of datetime= COUNTROWS(ALLNOBLANKROW('DateTime'))// Countrows ALL of datetime= COUNTROWS(ALL('DateTime'))// Countrows ALLNOBLANKROW of ResellerSales_USD= COUNTROWS(ALLNOBLANKROW('ResellerSales_USD'))// Countrows ALL of ResellerSales_USD= COUNTROWS(ALL('ResellerSales_USD')) ***end of code*** On a blank PivotTable add datetime.[Calendar Year] column to the row labels, and then add the newly created measures.  The results should look like the following table Row LabelsCountrows ALLNOBLANK of datetimeCountrows ALL of datetime20051280128120061280128120071280128120081280128112801281Grand Total12801281 The results show a difference of 1 row in the table rows count. However, if you open thePower Pivot windowand select the datetime table, you cannot find any blank row in the table because the special blank row mentioned here is the Unknown member. Step 4 Verify that the count is accurate In order to prove that the ALLNOBLANKROW does not count any truly blank rows, and only handles the special blank row on the parent table only, add the following two measures to the ResellerSales_USD tableCountrows ALLNOBLANKROW of ResellerSales_USD,Countrows ALL of ResellerSales_USD. Create a new PivotTable, and drag the column, datetime.[Calendar Year], to the Row Labels pane. Now add the measures that you just created. The results should look like the following Row LabelsCountrows ALLNOBLANKROW of ResellerSales_USDCountrows ALL of ResellerSales_USD200560856608562006608566085620076085660856200860856608566085660856Grand Total6085660856 Now the two measures have the same results. That is because the ALLNOBLANKROW function does not count truly blank rows in a table, but only handles the blank row that is a special case generated in a parent table, when one or more of the child tables in the relationship contain non-matching values or blank values.
ALLSELECTED: Syntax - ***start of code*** ALLSELECTED([<tableName> | <columnName>[, <columnName>[, <columnName>[,…]]]] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The context of the query without any column and row filters. ~ Remarks - If there is one argument, the argument is either***start of code*** tableName ***end of code***or***start of code*** columnName ***end of code***. If there is more than one argument, they must be columns from the same table. This function is different from ALL() because it retains all filters explicitly set within the query, and it retains all context filters other than row and column filters. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows how to generate different levels of visual totals in a table report using DAX expressions. In the report two (2) previous filters have been applied to the Reseller Sales data; one on Sales Territory Group =Europeand the other on Promotion Type =Volume Discount. Once filters have been applied, visual totals can be calculated for the entire report, for All Years, or for All Product Categories. Also, for illustration purposes the grand total for All Reseller Sales is obtained too, removing all filters in the report. Evaluating the following DAX expression results in a table with all the information needed to build a table with Visual Totals. ***start of code*** definemeasure 'Reseller Sales'[Reseller Sales Amount]=sum('Reseller Sales'[Sales Amount])measure 'Reseller Sales'[Reseller Grand Total]=calculate(sum('Reseller Sales'[Sales Amount]), ALL('Reseller Sales'))measure 'Reseller Sales'[Reseller Visual Total]=calculate(sum('Reseller Sales'[Sales Amount]), ALLSELECTED())measure 'Reseller Sales'[Reseller Visual Total for All of Calendar Year]=calculate(sum('Reseller Sales'[Sales Amount]), ALLSELECTED('Date'[Calendar Year]))measure 'Reseller Sales'[Reseller Visual Total for All of Product Category Name]=calculate(sum('Reseller Sales'[Sales Amount]), ALLSELECTED('Product Category'[Product Category Name]))evaluateCalculateTable(    //CT table expression    summarize(//summarize table expressioncrossjoin(distinct('Product Category'[Product Category Name]), distinct('Date'[Calendar Year]))//First Group by expression, 'Product Category'[Product Category Name]//Second Group by expression, 'Date'[Calendar Year]//Summary expressions, "Reseller Sales Amount", [Reseller Sales Amount], "Reseller Grand Total", [Reseller Grand Total], "Reseller Visual Total", [Reseller Visual Total], "Reseller Visual Total for All of Calendar Year", [Reseller Visual Total for All of Calendar Year], "Reseller Visual Total for All of Product Category Name", [Reseller Visual Total for All of Product Category Name])//CT filters, 'Sales Territory'[Sales Territory Group]="Europe", 'Promotion'[Promotion Type]="Volume Discount")order by [Product Category Name], [Calendar Year] ***end of code*** After executing the above expression in SQL Server Management Studio against AdventureWorks DW Tabular Model, you obtain the following results [Product Category Name][Calendar Year][Reseller Sales Amount][Reseller Grand Total][Reseller Visual Total][Reseller Visual Total for All of Calendar Year][Reseller Visual Total for All of Product Category Name]Accessories200080450596.9823877006.798738786.018Accessories200180450596.9823877006.798738786.018Accessories2002625.793380450596.9823877006.798738786.01891495.3104Accessories200326037.313280450596.9823877006.798738786.018572927.0136Accessories200412122.911580450596.9823877006.798738786.018212584.4747Accessories200580450596.9823877006.798738786.018Accessories200680450596.9823877006.798738786.018Bikes200080450596.9823877006.7987689287.7939Bikes200180450596.9823877006.7987689287.7939Bikes200273778.93880450596.9823877006.7987689287.793991495.3104Bikes2003439771.413680450596.9823877006.7987689287.7939572927.0136Bikes2004175737.442380450596.9823877006.7987689287.7939212584.4747Bikes200580450596.9823877006.7987689287.7939Bikes200680450596.9823877006.7987689287.7939Clothing200080450596.9823877006.798795090.7757Clothing200180450596.9823877006.798795090.7757Clothing200212132.433480450596.9823877006.798795090.775791495.3104Clothing200358234.221480450596.9823877006.798795090.7757572927.0136Clothing200424724.120980450596.9823877006.798795090.7757212584.4747Clothing200580450596.9823877006.798795090.7757Clothing200680450596.9823877006.798795090.7757Components200080450596.9823877006.798753842.2111Components200180450596.9823877006.798753842.2111Components20024958.145780450596.9823877006.798753842.211191495.3104Components200348884.065480450596.9823877006.798753842.2111572927.0136Components200480450596.9823877006.798753842.2111212584.4747Components200580450596.9823877006.798753842.2111Components200680450596.9823877006.798753842.2111 The columns in the report are Reseller Sales AmountThe actual value of Reseller Sales for the year and product category. This value appears in a cell in the center of your report, at the intersection of year and catergory. Reseller Visual Total for All of Calendar YearThe total value for a product category across all years. This value appears at the end of a column or row for a given product category and across all years in the report. Reseller Visual Total for All of Product Category NameThe total value for a year across all product categories. This value appears at the end of a column or row for a given year and across all product categories in the report. Reseller Visual TotalThe total value for all years and product categories. This value usually appears in the bottom rightmost corner of the table. Reseller Grand TotalThis is the grand total for all reseller sales, before any filter has been applied; you should notice the difference with [Reseller Visual Total]. You do remember that this report includes two (2) filters, one on Product Category Group and the other in Promotion Type. Noteif you have explicit filters in your expression, those filters are also applied to the expression.
CALCULATE: Syntax - ***start of code*** CALCULATE(<expression>[, <filter1> [, <filter2> [, …]]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The value that is the result of the expression. ~ Remarks - When filter expressions are provided, the CALCULATE function modifies the filter context to evaluate the expression. For each filter expression, there are two possible standard outcomes when the filter expression is not wrapped in the KEEPFILTERS functionIf the columns (or tables) aren't in the filter context, then new filters will be added to the filter context to evaluate the expression.If the columns (or tables) are already in the filter context, the existing filters will be overwritten by the new filters to evaluate the CALCULATE expression. If the columns (or tables) aren't in the filter context, then new filters will be added to the filter context to evaluate the expression. If the columns (or tables) are already in the filter context, the existing filters will be overwritten by the new filters to evaluate the CALCULATE expression. The CALCULATE function usedwithout filtersachieves a specific requirement. It transitions row context to filter context. It's required when an expression (not a model measure) that summarizes model data needs to be evaluated in row context. This scenario can happen in a calculated column formula or when an expression in an iterator function is evaluated. Note that when a model measure is used in row context, context transition is automatic. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
CALCULATETABLE: Syntax - ***start of code*** CALCULATETABLE(<expression>[, <filter1> [, <filter2> [, …]]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table of values. ~ Remarks - When filter expressions are provided, the CALCULATETABLE function modifies the filter context to evaluate the expression. For each filter expression, there are two possible standard outcomes when the filter expression is not wrapped in the KEEPFILTERS functionIf the columns (or tables) aren't in the filter context, then new filters will be added to the filter context to evaluate the expression.If the columns (or tables) are already in the filter context, the existing filters will be overwritten by the new filters to evaluate the CALCULATETABLE expression. If the columns (or tables) aren't in the filter context, then new filters will be added to the filter context to evaluate the expression. If the columns (or tables) are already in the filter context, the existing filters will be overwritten by the new filters to evaluate the CALCULATETABLE expression. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example uses the CALCULATETABLE function to get the sum of Internet sales for 2006. This value is later used to calculate the ratio of Internet sales compared to all sales for the year 2006. The following formula ***start of code*** = SUMX(    CALCULATETABLE(        'InternetSales_USD',        'DateTime'[CalendarYear] = 2006    ),    [SalesAmount_USD]) ***end of code*** It results in the following table Row LabelsInternet SalesAmount_USDCalculateTable 2006 Internet SalesInternet Sales to 2006 ratio2005$2,627,031.40$5,681,440.580.462006$5,681,440.58$5,681,440.581.002007$8,705,066.67$5,681,440.581.532008$9,041,288.80$5,681,440.581.59Grand Total$26,054,827.45$5,681,440.584.59
EARLIER: Syntax - ***start of code*** EARLIER(<column>, <number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The current value of row, from***start of code*** column ***end of code***, at***start of code*** number ***end of code***of outer evaluation passes. ~ Remarks - ***start of code*** EARLIER ***end of code***succeeds if there is a row context prior to the beginning of the table scan. Otherwise it returns an error. The performance of***start of code*** EARLIER ***end of code***might be slow because theoretically, it might have to perform a number of operations that is close to the total number of rows (in the column) times the same number (depending on the syntax of the expression). For example if you have 10 rows in the column, approximately a 100 operations could be required; if you have 100 rows then close to 10,000 operations might be performed. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - To illustrate the use of EARLIER, it is necessary to build a scenario that calculates a rank value and then uses that rank value in other calculations. The following example is based on this simple table,***start of code*** ProductSubcategory ***end of code***, which shows the total sales for each ProductSubcategory. The final table, including the ranking column is shown here. ProductSubcategoryKeyEnglishProductSubcategoryNameTotalSubcategorySalesSubcategoryRanking18Bib-Shorts$156,167.881826Bike Racks$220,720.701427Bike Stands$35,628.693028Bottles and Cages$59,342.43245Bottom Brackets$48,643.47276Brakes$62,113.162319Caps$47,934.54287Chains$8,847.083529Cleaners$16,882.62328Cranksets$191,522.09159Derailleurs$64,965.332230Fenders$41,974.102910Forks$74,727.662120Gloves$228,353.58124Handlebars$163,257.061711Headsets$57,659.992531Helmets$451,192.31932Hydration Packs$96,893.782021Jerseys$699,429.78733Lights3634Locks$15,059.47331Mountain Bikes$34,305,864.29212Mountain Frames$4,511,170.68435Panniers3613Pedals$140,422.201936Pumps$12,695.18342Road Bikes$40,551,696.34114Road Frames$3,636,398.71515Saddles$52,526.472622Shorts$385,707.801023Socks$28,337.853124Tights$189,179.371637Tires and Tubes$224,832.81133Touring Bikes$13,334,864.18316Touring Frames$1,545,344.02625Vests$240,990.041117Wheels$648,240.048
EARLIEST: Syntax - ***start of code*** EARLIEST(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A column with filters removed. ~ Remarks - The EARLIEST function is similar to EARLIER, but lets you specify one additional level of recursion. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The current sample data does not support this scenario. ***start of code*** = EARLIEST(<column>) ***end of code***
FILTER: Syntax - ***start of code*** FILTER(<table>,<filter>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing only the filtered rows. ~ Remarks - You can use FILTER to reduce the number of rows in the table that you are working with, and use only specific data in calculations. FILTER is not used independently, but as a function that is embedded in other functions that require a table as an argument. For best practices when using FILTER, seeAvoid using FILTER as a filter argument. ~ Example - The following example creates a report of Internet sales outside the United States by using a measure that filters out sales in the United States, and then slicing by calendar year and product categories. To create this measure, you filter the table, Internet Sales USD, by using Sales Territory, and then use the filtered table in a SUMX function. In this example, the expression ***start of code*** FILTER('InternetSales_USD', RELATED('SalesTerritory'[SalesTerritoryCountry])<>"United States") ***end of code*** Returns a table that is a subset of Internet Sales minus all rows that belong to the United States sales territory. The RELATED function is what links the Territory key in the Internet Sales table to SalesTerritoryCountry in the SalesTerritory table. The following table demonstrates the proof of concept for the measure, NON USA Internet Sales, the formula for which is provided in the code section below. The table compares all Internet sales with non- USA Internet sales, to show that the filter expression works, by excluding United States sales from the computation. To re-create this table, add the field, SalesTerritoryCountry, to theRow Labelsarea of a report or PivotTable. Table 1. Comparing total sales for U.S. vs. all other regions Row LabelsInternet SalesNon USA Internet SalesAustralia$4,999,021.84$4,999,021.84Canada$1,343,109.10$1,343,109.10France$2,490,944.57$2,490,944.57Germany$2,775,195.60$2,775,195.60United Kingdom$5,057,076.55$5,057,076.55United States$9,389,479.79Grand Total$26,054,827.45$16,665,347.67 The final report table shows the results when you create a PivotTable by using the measure, NON USA Internet Sales. Add the field, CalendarYear, to theRow Labelsarea of the PivotTable and add the field, ProductCategoryName, to theColumn Labelsarea. Table 2. Comparing non- U.S. sales by product categories Row LabelsAccessoriesBikesClothingGrand Total2005$1,526,481.95$1,526,481.952006$3,554,744.04$3,554,744.042007$156,480.18$5,640,106.05$70,142.77$5,866,729.002008$228,159.45$5,386,558.19$102,675.04$5,717,392.68Grand Total$384,639.63$16,107,890.23$172,817.81$16,665,347.67 ***start of code*** SUMX(FILTER('InternetSales_USD', RELATED('SalesTerritory'[SalesTerritoryCountry])<>"United States")     ,'InternetSales_USD'[SalesAmount_USD]) ***end of code***
FIRST: Syntax - ***start of code*** FIRST ( <column>[, <axis>][, <blanks>][, reset] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The value of***start of code*** column ***end of code***from the first element of the axis. ~ Remarks -  ~ Example - The following visual calculation returns the sales amount of the first row on ROWS axis, that resets on the lowest parent. ***start of code*** FirstInternetSalesAmount = FIRST ( [Sum of SalesAmount], ROWS, LowestParent ) ***end of code*** The screenshot below shows the visual matrix and the visual calculation expression
INDEX: Syntax - ***start of code*** INDEX(<position>[, <relation> or <axis>][, <orderBy>][, <blanks>][, <partitionBy>][, <matchBy>][, <reset>] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A row at an absolute position. ~ Remarks - If there is exactly one corresponding outer column, its value is used. If there is no corresponding outer columnINDEX will first determine all***start of code*** partitionBy ***end of code***and***start of code*** matchBy ***end of code***columns that have no corresponding outer column.For every combination of existing values for these columns in INDEX’s parent context, INDEX is evaluated and a row is returned.INDEX’s final output is a union of these rows. INDEX will first determine all***start of code*** partitionBy ***end of code***and***start of code*** matchBy ***end of code***columns that have no corresponding outer column. For every combination of existing values for these columns in INDEX’s parent context, INDEX is evaluated and a row is returned. INDEX’s final output is a union of these rows. If there is more than one corresponding outer column, an error is returned. ~ Example - There is no provided example for this function.
KEEPFILTERS: Syntax - ***start of code*** KEEPFILTERS(<expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table of values. ~ Remarks - You use KEEPFILTERS within the context CALCULATE and CALCULATETABLE functions, to override the standard behavior of those functions. By default, filter arguments in functions such as CALCULATE are used as the context for evaluating the expression, and as such filter arguments for CALCULATE replace all existing filters over the same columns. The new context effected by the filter argument for CALCULATE affects only existing filters on columns mentioned as part of the filter argument. Filters on columns other than those mentioned in the arguments of CALCULATE or other related functions remain in effect and unaltered. The KEEPFILTERS function allows you to modify this behavior. When you use KEEPFILTERS, any existing filters in the current context are compared with the columns in the filter arguments, and the intersection of those arguments is used as the context for evaluating the expression. The net effect over any one column is that both sets of arguments apply both the filter arguments used in CALCULATE and the filters in the arguments of the KEEPFILTER function. In other words, whereas CALCULATE filters replace the current context, KEEPFILTERS adds filters to the current context. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example takes you through some common scenarios that demonstrate use of the KEEPFILTERS function as part of a CALCULATE or CALCULATETABLE formula. The first three expressions obtain simple data to be used for comparisons Internet Sales for the state of Washington.Internet Sales for the states of Washington and Oregon (both states combined).Internet Sales for the state of Washington and the province of British Columbia (both regions combined). The fourth expression calculates Internet Sales for Washington and Oregon, while the filter for Washington and British Columbia is applied. The next expression calculates Internet Sales for Washington and Oregon but uses KEEPFILTERS; the filter for Washington and British Columbia is part of the prior context. ***start of code*** EVALUATE ROW(  "$$ in WA"    , CALCULATE('Internet Sales'[Internet Total Sales]                , 'Geography'[State Province Code]="WA"      ), "$$ in WA and OR"    , CALCULATE('Internet Sales'[Internet Total Sales]               , 'Geography'[State Province Code]="WA"                  || 'Geography'[State Province Code]="OR"      ), "$$ in WA and BC"    , CALCULATE('Internet Sales'[Internet Total Sales]               , 'Geography'[State Province Code]="WA"                  || 'Geography'[State Province Code]="BC"      ), "$$ in WA and OR ??"    , CALCULATE(          CALCULATE('Internet Sales'[Internet Total Sales]                    ,'Geography'[State Province Code]="WA"                       || 'Geography'[State Province Code]="OR"          )          , 'Geography'[State Province Code]="WA"             || 'Geography'[State Province Code]="BC"      ), "$$ in WA !!"    , CALCULATE(          CALCULATE('Internet Sales'[Internet Total Sales]                   , KEEPFILTERS('Geography'[State Province Code]="WA"                               || 'Geography'[State Province Code]="OR"                     )          )          , 'Geography'[State Province Code]="WA"             || 'Geography'[State Province Code]="BC"      )) ***end of code*** When this expression is evaluated against the sample database AdventureWorks DW, the following results are obtained. ColumnValue***start of code*** [$$ in WA] ***end of code***$  2,467,248.34***start of code*** [$$ in WA and OR] ***end of code***$  3,638,239.88***start of code*** [$$ in WA and BC] ***end of code***$  4,422,588.44***start of code*** [$$ in WA and OR ??] ***end of code***$  3,638,239.88***start of code*** [$$ in WA !!] ***end of code***$  2,467,248.34 NoteThe above results were formatted to a table, instead of a single row, for educational purposes. First, examine the expression,***start of code*** [$$ in WA and OR ??] ***end of code***. You might wonder how this formula could return the value for sales in Washington and Oregon, since the outer CALCULATE expression includes a filter for Washington and British Columbia. The answer is that the default behavior of CALCULATE overrides the outer filters in 'Geography'[State Province Code] and substitutes its own filter arguments, because the filters apply to the same column. Next, examine the expression,***start of code*** [$$ in WA !!] ***end of code***. You might wonder how this formula could return the value for sales in Washington and nothing else, since the argument filter includes Oregon and the outer CALCULATE expression includes a filter in Washington and British Columbia. The answer is that KEEPFILTERS modifies the default behavior of CALCULATE and adds an additional filter. Because the intersection of filters is used, now the outer filter***start of code*** 'Geography'[State Province Code]="WA" || 'Geography'[State Province Code]="BC") ***end of code***is added to the filter argument***start of code*** 'Geography'[State Province Code]="WA" || 'Geography'[State Province Code]="OR" ***end of code***,. Because both filters apply to the same column, the resulting filter***start of code*** 'Geography'[State Province Code]="WA" ***end of code***is the filter that is applied when evaluating the expression.
LAST: Syntax - ***start of code*** LAST ( <column>[, <axis>][, <blanks>][, reset] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The value of***start of code*** column ***end of code***from the last element of the axis. ~ Remarks -  ~ Example - The following visual calculation returns the sales amount of the last row on ROWS axis, that resets on the lowest parent. ***start of code*** LastInternetSalesAmount = LAST ( [Sum of SalesAmount], ROWS, LowestParent ) ***end of code*** The screenshot below shows the visual matrix and the visual calculation expression
LOOKUPVALUE: Syntax - ***start of code*** LOOKUPVALUE (    <result_columnName>,    <search_columnName>,    <search_value>    [, <search2_columnName>, <search2_value>]…    [, <alternateResult>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The value of***start of code*** result_columnName ***end of code***at the row where all pairs of***start of code*** search_columnName ***end of code***and***start of code*** search_value ***end of code***have an exact match. ~ Remarks - If there is a relationship between the table that contains the result column and tables that contain the search columns, in most cases, using theRELATEDfunction instead of LOOKUPVALUE is more efficient and provides better performance. Multiple pairs of***start of code*** search_columnName ***end of code***and***start of code*** search_value ***end of code***can be specified. The***start of code*** search_value ***end of code***and***start of code*** alternateResult ***end of code***parameters are evaluated before the function iterates through the rows of the search table. Avoid using ISERROR or IFERROR functions to capture an error returned by LOOKUPVALUE. If some inputs to the function result in an error when a single output value cannot be determined, providing an***start of code*** alternateResult ***end of code***parameter is the most reliable and highest performing way to handle the error. The***start of code*** alternateResult ***end of code***parameter returns an error if specified in a Power Pivot calculated column. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
MATCHBY: Syntax - ***start of code*** MATCHBY ( [<matchBy_columnName>[, matchBy_columnName [, …]]] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - This function does not return a value. ~ Remarks -  ~ Example - SeeOFFSET.
MOVINGAVERAGE: Syntax - ***start of code*** MOVINGAVERAGE ( <column>, <windowSize>[, <includeCurrent>][, <axis>][, <blanks>][, <reset>] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value, the moving average at the current element of the axis. ~ Remarks -  ~ Example - There is no provided example for this function.
NEXT: Syntax - ***start of code*** NEXT ( <column>[, <steps>][, <axis>][, <blanks>][, reset] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The value of***start of code*** column ***end of code***from the next element of the axis. ~ Remarks -  ~ Example - The following visual calculation returns the sales amount of the next row on ROWS axis, that resets on the lowest parent. ***start of code*** NextInternetSalesAmount = NEXT ( [Sum of SalesAmount], ROWS, LowestParent ) ***end of code*** The screenshot below shows the visual matrix and the visual calculation expression
OFFSET: Syntax - ***start of code*** OFFSET ( <delta>[, <relation> or <axis>][, <orderBy>][, <blanks>][, <partitionBy>][, <matchBy>][, <reset>] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - One or more rows from***start of code*** relation ***end of code***. ~ Remarks - If there is exactly one corresponding outer column, its value is used. If there is no corresponding outer column, thenOFFSET will first determine all columns that have no corresponding outer column.For every combination of existing values for these columns in OFFSET’s parent context, OFFSET is evaluated and a row is returned.OFFSET’s final output is a union of these rows. OFFSET will first determine all columns that have no corresponding outer column. For every combination of existing values for these columns in OFFSET’s parent context, OFFSET is evaluated and a row is returned. OFFSET’s final output is a union of these rows. If there is more than one corresponding outer column, an error is returned. ~ Example - There is no provided example for this function.
ORDERBY: Syntax - ***start of code*** ORDERBY ( [<orderBy_expression>[, <order>[, <orderBy_expression>[, <order>]] …]] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - This function does not return a value. ~ Remarks -  ~ Example - SeeOFFSET.
PARTITIONBY: Syntax - ***start of code*** PARTITIONBY ( [<partitionBy_columnName>[, partitionBy_columnName [, …]]] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - This function does not return a value. ~ Remarks -  ~ Example - SeeOFFSET.
PREVIOUS: Syntax - ***start of code*** PREVIOUS ( <column>[, <steps>][, <axis>][, <blanks>][, reset] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The value of***start of code*** column ***end of code***from the previous element of the axis. ~ Remarks -  ~ Example - The following visual calculation returns the sales amount of the previous row on ROWS axis, that resets on the lowest parent. ***start of code*** PreviousInternetSalesAmount = PREVIOUS ( [Sum of SalesAmount], ROWS, LowestParent ) ***end of code*** The screenshot below shows the visual matrix and the visual calculation expression
RANGE: Syntax - ***start of code*** RANGE ( <step>[, <includeCurrent>][, <axis>][, <blanks>][, <reset>] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - An interval of data rows. ~ Remarks -  ~ Example - There is no provided example for this function.
RANK: Syntax - ***start of code*** RANK ( [<ties>][, <relation> or <axis>][, <orderBy>][, <blanks>][, <partitionBy>][, <matchBy>][, <reset>] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The rank number for the current context. ~ Remarks - Each***start of code*** orderBy ***end of code***,***start of code*** partitionBy ***end of code***, and***start of code*** matchBy ***end of code***column must have a corresponding outer value to help define the current row on which to operate, with the following behaviorIf there is exactly one corresponding outer column, its value is used.If there is no corresponding outer column, thenRANK will first determine all***start of code*** orderBy ***end of code***,***start of code*** partitionBy ***end of code***, and***start of code*** matchBy ***end of code***columns that have no corresponding outer column.For every combination of existing values for these columns in RANK parent context, RANK is evaluated and a row is returned.RANK’s final output is a rank number. If there is exactly one corresponding outer column, its value is used. If there is no corresponding outer column, thenRANK will first determine all***start of code*** orderBy ***end of code***,***start of code*** partitionBy ***end of code***, and***start of code*** matchBy ***end of code***columns that have no corresponding outer column.For every combination of existing values for these columns in RANK parent context, RANK is evaluated and a row is returned.RANK’s final output is a rank number. RANK will first determine all***start of code*** orderBy ***end of code***,***start of code*** partitionBy ***end of code***, and***start of code*** matchBy ***end of code***columns that have no corresponding outer column. For every combination of existing values for these columns in RANK parent context, RANK is evaluated and a row is returned. RANK’s final output is a rank number. If***start of code*** matchBy ***end of code***is present, then RANK will try to use columns in***start of code*** matchBy ***end of code***and***start of code*** partitionBy ***end of code***to idenfity the current row. If the columns specified within***start of code*** orderBy ***end of code***and***start of code*** partitionBy ***end of code***cannot uniquely identify every row in***start of code*** relation ***end of code***, then two or more rows may have the same ranking and the ranking will be determined by the ties parameter. RANK returns a blank value for total rows. It's recommended that you test your expression thoroughly. RANK does not compare to RANKX as SUM compares to SUMX. ***start of code*** reset ***end of code***can be used in visual calculations only, and cannot be used in combination with***start of code*** orderBy ***end of code***or***start of code*** partitionBy ***end of code***. If***start of code*** reset ***end of code***is present,***start of code*** axis ***end of code***can be specified but***start of code*** relation ***end of code***cannot. ~ Example - There is no provided example for this function.
REMOVEFILTERS: Syntax - ***start of code*** REMOVEFILTERS([<table> | <column>[, <column>[, <column>[,…]]]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - N/A. See remarks. ~ Remarks - REMOVEFILTERS can only be used to clear filters but not to return a table. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
ROWNUMBER: Syntax - ***start of code*** ROWNUMBER ( [<relation> or <axis>][, <orderBy>][, <blanks>][, <partitionBy>][, <matchBy>][, <reset>] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The rownumber number for the current context. ~ Remarks - If there is exactly one corresponding outer column, its value is used. If there is no corresponding outer column, thenROWNUMBER will first determine all***start of code*** orderBy ***end of code***,***start of code*** partitionBy ***end of code***, and***start of code*** matchBy ***end of code***columns that have no corresponding outer column.For every combination of existing values for these columns in ROWNUMBER parent context, ROWNUMBER is evaluated and a row is returned.ROWNUMBER’s final output is a union of these rows. ROWNUMBER will first determine all***start of code*** orderBy ***end of code***,***start of code*** partitionBy ***end of code***, and***start of code*** matchBy ***end of code***columns that have no corresponding outer column. For every combination of existing values for these columns in ROWNUMBER parent context, ROWNUMBER is evaluated and a row is returned. ROWNUMBER’s final output is a union of these rows. If there is more than one corresponding outer column, an error is returned. ~ Example - There is no provided example for this function.
RUNNINGSUM: Syntax - ***start of code*** RUNNINGSUM ( <column>[, <axis>][, <blanks>][, <reset>] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value, the running sum up to the current element of the axis. ~ Remarks -  ~ Example - Given a table that summarizes the total sales for each product category and calendar year, the following DAX query adds a column with the total sales for that category up to a given year. ***start of code*** SalesUpToDate = RUNNINGSUM([SalesAmount], Rows) ***end of code*** The screenshot below shows the visual matrix and the visual calculation expression
SELECTEDVALUE: Syntax - ***start of code*** SELECTEDVALUE(<columnName>[, <alternateResult>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The value when the context for columnName has been filtered down to one distinct value only. Else, alternateResult. ~ Remarks - An equivalent expression for***start of code*** SELECTEDVALUE(<columnName>, <alternateResult>) ***end of code***is***start of code*** IF(HASONEVALUE(<columnName>), VALUES(<columnName>), <alternateResult>) ***end of code***. To learn more about best practices when using SELECTEDVALUE, seeUse SELECTEDVALUE instead of VALUES in DAX. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query ***start of code*** DEFINE MEASURE DimProduct[Selected Color] = SELECTEDVALUE(DimProduct[Color], "No Single Selection")EVALUATE SUMMARIZECOLUMNS   (ROLLUPADDISSUBTOTAL(DimProduct[Color], "Is Total"),   "Selected Color", [Selected Color])ORDER BY [Is Total] ASC,   [Color] ASC ***end of code*** Returns the following DimProduct[Color][Is Total][Selected Color]Black***start of code*** FALSE ***end of code***BlackBlue***start of code*** FALSE ***end of code***BlueGrey***start of code*** FALSE ***end of code***GreyMulti***start of code*** FALSE ***end of code***MultiNA***start of code*** FALSE ***end of code***NARed***start of code*** FALSE ***end of code***RedSilver***start of code*** FALSE ***end of code***SilverSilver/Black***start of code*** FALSE ***end of code***Silver/BlackWhite***start of code*** FALSE ***end of code***WhiteYellow***start of code*** FALSE ***end of code***Yellow``***start of code*** TRUE ***end of code***No Single Selection
WINDOW: Syntax - ***start of code*** WINDOW ( from[, from_type], to[, to_type][, <relation> or <axis>][, <orderBy>][, <blanks>][, <partitionBy>][, <matchBy>][, <reset>] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - All rows from the window. ~ Remarks - If there is exactly one corresponding outer column, its value is used. If there is no corresponding outer columnWINDOW will first determine all columns that have no corresponding outer column.For every combination of existing values for these columns in WINDOW’s parent context, WINDOW is evaluated, and the corresponding rows is returned.WINDOW final output is a union of these rows. WINDOW will first determine all columns that have no corresponding outer column. For every combination of existing values for these columns in WINDOW’s parent context, WINDOW is evaluated, and the corresponding rows is returned. WINDOW final output is a union of these rows. If there is more than one corresponding outer column, an error is returned. ~ Example - There is no provided example for this function.
ACCRINT: Syntax - ***start of code*** ACCRINT(<issue>, <first_interest>, <settlement>, <rate>, <par>, <frequency>[, <basis>[, <calc_method>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. ACCRINT is calculated as follows$$\text{ACCRINT} = \text{par} \times \frac{\text{rate}}{\text{frequency}} \times \sum^{\text{NC}}_{i=1}\frac{\text{A}_{i}}{\text{NL}_{i}}$$where$\text{A}_{i}$ = number of accrued days for the $i^{th}$ quasi-coupon period within odd period.$\text{NC}$ = number of quasi-coupon periods that fit in odd period. If this number contains a fraction, raise it to the next whole number.$\text{NL}_{i}$ = normal length in days of the quasi-coupon period within odd period. $\text{A}_{i}$ = number of accrued days for the $i^{th}$ quasi-coupon period within odd period. $\text{NC}$ = number of quasi-coupon periods that fit in odd period. If this number contains a fraction, raise it to the next whole number. $\text{NL}_{i}$ = normal length in days of the quasi-coupon period within odd period. issue, first_interest, and settlement are truncated to integers. frequency and basis are rounded to the nearest integer. An error is returned ifissue, first_interest, or settlement is not a valid date.issue ≥ settlement.rate ≤ 0.par ≤ 0.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. issue, first_interest, or settlement is not a valid date. issue ≥ settlement. rate ≤ 0. par ≤ 0. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
ACCRINTM: Syntax - ***start of code*** ACCRINTM(<issue>, <maturity>, <rate>, <par>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. ACCRINTM is calculated as follows$$\text{ACCRINTM} = \text{par} \times \text{rate} \times \frac{\text{A}}{\text{D}}$$where$\text{A}$ = Number of accrued days counted according to a monthly basis. For interest at maturity items, the number of days from the issue date to the maturity date is used.$\text{D}$ = Annual Year Basis. $\text{A}$ = Number of accrued days counted according to a monthly basis. For interest at maturity items, the number of days from the issue date to the maturity date is used. $\text{D}$ = Annual Year Basis. issue and maturity are truncated to integers. basis is rounded to the nearest integer. An error is returned ifissue or maturity is not a valid date.issue ≥ maturity.rate ≤ 0.par ≤ 0.basis < 0 or basis > 4. issue or maturity is not a valid date. issue ≥ maturity. rate ≤ 0. par ≤ 0. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription1-April-2008Issue date15-June-2008Maturity date10%Percent coupon1000Par value3Actual/365 basis (see above) The following DAX query ***start of code*** EVALUATE{  ACCRINTM(DATE(2008,4,1), DATE(2008,6,15), 0.1, 1000, 3)} ***end of code*** Returns the accrued interest for a security with the terms specified above. [Value]20.5479452054795
AMORDEGRC: Syntax - ***start of code*** AMORDEGRC(<cost>, <date_purchased>, <first_period>, <salvage>, <period>, <rate>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. This function will return the depreciation until the last period of the life of the assets or until the cumulated value of depreciation is greater than the cost of the assets minus the salvage value. The depreciation coefficients areLife of assets (1/rate)Depreciation coefficientBetween 3 and 4 years1.5Between 5 and 6 years2More than 6 years2.5 The depreciation rate will grow to 50 percent for the period preceding the last period and will grow to 100 percent for the last period. period and basis are rounded to the nearest integer. An error is returned ifcost < 0.first_period or date_purchased is not a valid date.date_purchased > first_period.salvage < 0 or salvage > cost.period < 0.rate ≤ 0.The life of assets is between 0 (zero) and 1, 1 and 2, 2 and 3, or 4 and 5.basis is any number other than 0, 1, 3, or 4. cost < 0. first_period or date_purchased is not a valid date. date_purchased > first_period. salvage < 0 or salvage > cost. period < 0. rate ≤ 0. The life of assets is between 0 (zero) and 1, 1 and 2, 2 and 3, or 4 and 5. basis is any number other than 0, 1, 3, or 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription2400Cost19-August-2008Date purchased31-December-2008End of the first period300Salvage value1Period15%Depreciation rate1Actual basis (see above) The following DAX query ***start of code*** EVALUATE{  AMORDEGRC(2400, DATE(2008,8,19), DATE(2008,12,31), 300, 1, 0.15, 1)} ***end of code*** Returns the first period's depreciation, given the terms specified above. [Value]776
AMORLINC: Syntax - ***start of code*** AMORLINC(<cost>, <date_purchased>, <first_period>, <salvage>, <period>, <rate>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. period and basis are rounded to the nearest integer. An error is returned if***start of code*** cost ***end of code***< 0.***start of code*** first_period ***end of code***or***start of code*** date_purchased ***end of code***is not a valid date.***start of code*** date_purchased ***end of code***>***start of code*** first_period ***end of code***.***start of code*** salvage ***end of code***< 0 or***start of code*** salvage ***end of code***>***start of code*** cost ***end of code***.***start of code*** period ***end of code***< 0.***start of code*** rate ***end of code***≤ 0.***start of code*** basis ***end of code***is any number other than 0, 1, 3, or 4. ***start of code*** cost ***end of code***< 0. ***start of code*** first_period ***end of code***or***start of code*** date_purchased ***end of code***is not a valid date. ***start of code*** date_purchased ***end of code***>***start of code*** first_period ***end of code***. ***start of code*** salvage ***end of code***< 0 or***start of code*** salvage ***end of code***>***start of code*** cost ***end of code***. ***start of code*** period ***end of code***< 0. ***start of code*** rate ***end of code***≤ 0. ***start of code*** basis ***end of code***is any number other than 0, 1, 3, or 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription2400Cost19-August-2008Date purchased31-December-2008End of the first period300Salvage value1Period15%Depreciation rate1Actual basis (see above) The following DAX query ***start of code*** EVALUATE{  AMORLINC(2400, DATE(2008,8,19), DATE(2008,12,31), 300, 1, 0.15, 1)} ***end of code*** Returns the first period's depreciation, given the terms specified above. [Value]360
COUPDAYBS: Syntax - ***start of code*** COUPDAYBS(<settlement>, <maturity>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, 30 years after the January 1, 2008, issue date. settlement and maturity are truncated to integers. frequency and basis are rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription25-Jan-11Settlement date15-Nov-11Maturity date2Semiannual coupon (see above)1Actual/actual basis (see above) The following DAX query ***start of code*** EVALUATE{  COUPDAYBS(DATE(2011,1,25), DATE(2011,11,15), 2, 1)} ***end of code*** Returns the number of days from the beginning of the coupon period until the settlement date, for a bond with terms above. [Value]71
COUPDAYS: Syntax - ***start of code*** COUPDAYS(<settlement>, <maturity>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date is January 1, 2038, 30 years after the January 1, 2008 issue date. settlement and maturity are truncated to integers. frequency and basis are rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription25-Jan-11Settlement date15-Nov-11Maturity date2Semiannual coupon (see above)1Actual/actual basis (see above) The following DAX query ***start of code*** EVALUATE{  COUPDAYS(DATE(2011,1,25), DATE(2011,11,15), 2, 1)} ***end of code*** Returns the number of days in the coupon period that contains the settlement date, for a bond with the terms specified above. [Value]181
COUPDAYSNC: Syntax - ***start of code*** COUPDAYSNC(<settlement>, <maturity>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. settlement and maturity are truncated to integers. frequency and basis are rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription25-Jan-11Settlement date15-Nov-11Maturity date2Semiannual coupon (see above)1Actual/actual basis (see above) The following DAX query ***start of code*** EVALUATE{  COUPDAYSNC(DATE(2011,1,25), DATE(2011,11,15), 2, 1)} ***end of code*** Returns the number of days from the settlement date to the next coupon date, for a bond with the terms specified above. [Value]110
COUPNCD: Syntax - ***start of code*** COUPNCD(<settlement>, <maturity>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date is January 1, 2038, 30 years after the January 1, 2008 issue date. settlement and maturity are truncated to integers. frequency and basis are rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription25-Jan-11Settlement date15-Nov-11Maturity date2Semiannual coupon (see above)1Actual/actual basis (see above) The following DAX query ***start of code*** EVALUATE{  COUPNCD(DATE(2011,1,25), DATE(2011,11,15), 2, 1)} ***end of code*** Returns the next coupon date after the settlement date, for a bond with the terms specified above. [Value]5/15/2011 120000 AM
COUPNUM: Syntax - ***start of code*** COUPNUM(<settlement>, <maturity>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. settlement and maturity are truncated to integers. frequency and basis are rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription25-Jan-07Settlement date15-Nov-08Maturity date2Semiannual coupon (see above)1Actual/actual basis (see above) The following DAX query ***start of code*** EVALUATE{  COUPNUM(DATE(2007,1,25), DATE(2008,11,15), 2, 1)} ***end of code*** Returns the number of coupon payments for a bond with the terms specified above. [Value]4
COUPPCD: Syntax - ***start of code*** COUPPCD(<settlement>, <maturity>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. settlement and maturity are truncated to integers. frequency and basis are rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription25-Jan-11Settlement date15-Nov-11Maturity date2Semiannual coupon (see above)1Actual/actual basis (see above) The following DAX query ***start of code*** EVALUATE{  COUPPCD(DATE(2011,1,25), DATE(2011,11,15), 2, 1)} ***end of code*** Returns the previous coupon date before the settlement date, for a bond using the terms specified above. [Value]11/15/2010 120000 AM
CUMIPMT: Syntax - ***start of code*** CUMIPMT(<rate>, <nper>, <pv>, <start_period>, <end_period>, <type>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Make sure that you are consistent about the units you use for specifying rate and nper. If you make monthly payments on a four-year loan at an annual interest rate of 10 percent, use 0.1/12 for rate and 4*12 for nper. If you make annual payments on the same loan, use 0.1 for rate and 4 for nper. start_period, end_period, and type are rounded to the nearest integer. An error is returned ifrate ≤ 0.nper < 1.pv ≤ 0.start_period < 1 or start_period > end_period.end_period < start_period or end_period > nper.type is any number other than 0 or 1. rate ≤ 0. nper < 1. pv ≤ 0. start_period < 1 or start_period > end_period. end_period < start_period or end_period > nper. type is any number other than 0 or 1. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
CUMPRINC: Syntax - ***start of code*** CUMPRINC(<rate>, <nper>, <pv>, <start_period>, <end_period>, <type>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Make sure that you are consistent about the units you use for specifying rate and nper. If you make monthly payments on a four-year loan at an annual interest rate of 10 percent, use 0.1/12 for rate and 4*12 for nper. If you make annual payments on the same loan, use 0.1 for rate and 4 for nper. start_period, end_period, and type are rounded to the nearest integer. An error is returned ifrate ≤ 0.nper < 1.pv ≤ 0.start_period < 1 or start_period > end_period.end_period < start_period or end_period > nper.type is any number other than 0 or 1. rate ≤ 0. nper < 1. pv ≤ 0. start_period < 1 or start_period > end_period. end_period < start_period or end_period > nper. type is any number other than 0 or 1. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
DB: Syntax - ***start of code*** DB(<cost>, <salvage>, <life>, <period>[, <month>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - The fixed-declining balance method computes depreciation at a fixed rate. DB uses the following formulas to calculate depreciation for a period$$(\text{cost} - \text{total depreciation from prior periods}) \times \text{rate}$$where$\text{rate} = 1 - ((\frac{\text{salvage}}{\text{cost}})^{(\frac{1}{\text{life}})})\text{, rounded to three decimal places}$ $\text{rate} = 1 - ((\frac{\text{salvage}}{\text{cost}})^{(\frac{1}{\text{life}})})\text{, rounded to three decimal places}$ Depreciation for the first and last periods is a special case.For the first period, DB uses this formula$$\frac{\text{cost} \times \text{rate} \times \text{month}}{12}$$For the last period, DB uses this formula$$\frac{(\text{cost} - \text{total depreciation from prior periods}) \times \text{rate} \times (12 - \text{month})}{12}$$ For the first period, DB uses this formula$$\frac{\text{cost} \times \text{rate} \times \text{month}}{12}$$ For the last period, DB uses this formula$$\frac{(\text{cost} - \text{total depreciation from prior periods}) \times \text{rate} \times (12 - \text{month})}{12}$$ period and month are rounded to the nearest integer. An error is returned ifcost < 0.salvage < 0.life < 1.period < 1 or period > life.month < 1 or month > 12. cost < 0. salvage < 0. life < 1. period < 1 or period > life. month < 1 or month > 12. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
DDB: Syntax - ***start of code*** DDB(<cost>, <salvage>, <life>, <period>[, <factor>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - The double-declining balance method computes depreciation at an accelerated rate. Depreciation is highest in the first period and decreases in successive periods. DDB uses the following formula to calculate depreciation for a period$$\text{Min}((\text{cost} - \text{total depreciation from prior periods}) \times (\frac{\text{factor}}{\text{life}}),(\text{cost} - \text{salvage} - \text{total depreciation from prior periods}))$$ Change factor if you do not want to use the double-declining balance method. Use the VDB function if you want to switch to the straight-line depreciation method when depreciation is greater than the declining balance calculation. period is rounded to the nearest integer. An error is returned ifcost < 0.salvage < 0.life < 1.period < 1 or period > life.factor ≤ 0. cost < 0. salvage < 0. life < 1. period < 1 or period > life. factor ≤ 0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
DISC: Syntax - ***start of code*** DISC(<settlement>, <maturity>, <pr>, <redemption>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2018, and is purchased by a buyer six months later. The issue date would be January 1, 2018, the settlement date would be July 1, 2018, and the maturity date would be January 1, 2048, 30 years after the January 1, 2018, issue date. DISC is calculated as follows$$\text{DISC} = \frac{\text{redemption} - \text{par}}{\text{redemption}} \times \frac{\text{B}}{\text{DSM}}$$where$\text{B}$ = number of days in a year, depending on the year basis.$\text{DSM}$ = number of days between settlement and maturity. $\text{B}$ = number of days in a year, depending on the year basis. $\text{DSM}$ = number of days between settlement and maturity. settlement and maturity are truncated to integers. basis is rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.pr ≤ 0.redemption ≤ 0.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. pr ≤ 0. redemption ≤ 0. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription07/01/2018Settlement date01/01/2048Maturity date97.975Price100Redemption value1Actual/actual basis (see above) The following DAX query ***start of code*** EVALUATE{  DISC(DATE(2018,7,1), DATE(2048,1,1), 97.975, 100, 1)} ***end of code*** Returns the bond discount rate, for a bond with the terms specified above. [Value]0.000686384169121348
DOLLARDE: Syntax - ***start of code*** DOLLARDE(<fractional_dollar>, <fraction>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - The fraction part of the value is divided by an integer that you specify. For example, if you want your price to be expressed to a precision of 1/16 of a dollar, you divide the fraction part by 16. In this case, 1.02 represents \$1.125 (\$1 + 2/16 = \$1.125). fraction is rounded to the nearest integer. An error is returned iffraction < 1. fraction < 1. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query ***start of code*** EVALUATE{  DOLLARDE(1.02, 16)} ***end of code*** Returns 1.125, the decimal price of the original fractional price, 1.02, read as 1 and 2/16. Since the fraction value is 16, the price has a precision of 1/16 of a dollar.
DOLLARFR: Syntax - ***start of code*** DOLLARFR(<decimal_dollar>, <fraction>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - fraction is rounded to the nearest integer. An error is returned iffraction < 1. fraction < 1. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query ***start of code*** EVALUATE{  DOLLARFR(1.125, 16)} ***end of code*** Returns 1.02, read as 1 and 2/16, which is the corresponding fraction price of the original decimal price, 1.125. Since the fraction value is 16, the price has a precision of 1/16 of a dollar.
DURATION: Syntax - ***start of code*** DURATION(<settlement>, <maturity>, <coupon>, <yld>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date is January 1, 2038, which is 30 years after the January 1, 2008, issue date. settlement and maturity are truncated to integers. frequency, and basis are rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.coupon < 0.yld < 0frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. coupon < 0. yld < 0 frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription07/01/2018Settlement date01/01/2048Maturity date8.0%Percent coupon9.0%Percent yield2Frequency is semiannual (see above)1Actual/actual basis (see above) The following DAX query ***start of code*** EVALUATE{  DURATION(DATE(2018,7,1), DATE(2048,1,1), 0.08, 0.09, 2, 1)} ***end of code*** Returns the Macauley duration for a bond with the terms specified above. [Value]10.9191452815919
EFFECT: Syntax - ***start of code*** EFFECT(<nominal_rate>, <npery>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - EFFECT is calculated as follows$$\text{EFFECT} = \bigg( 1 + \frac{\text{nominal_rate}}{\text{npery}} \bigg)^{\text{npery}} - 1$$ npery is rounded to the nearest integer. An error is returned ifnominal_rate ≤ 0.npery < 1. nominal_rate ≤ 0. npery < 1. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription5.25%Nominal interest rate4Number of compounding periods per year The following DAX query ***start of code*** EVALUATE{  EFFECT(0.0525, 4)} ***end of code*** Returns the effective interest rate using the terms specified above. [Value]0.0535426673707584
FV: Syntax - ***start of code*** FV(<rate>, <nper>, <pmt>[, <pv>[, <type>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Make sure that you are consistent about the units you use for specifying rate and nper. If you make monthly payments on a four-year loan at 12 percent annual interest, use 0.12/12 for rate and 4*12 for nper. If you make annual payments on the same loan, use 0.12 for rate and 4 for nper. For all the arguments, cash you pay out, such as deposits to savings, is represented by negative numbers; cash you receive, such as dividend checks, is represented by positive numbers. type is rounded to the nearest integer. An error is returned ifnper < 1 nper < 1 This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription6%Annual interest rate10Number of payments-200Amount of the payment-500Present value1Payment is due at the beginning of the period (0 indicates payment is due at end of period) The following DAX query ***start of code*** EVALUATE{  FV(0.06/12, 10, -200, -500, 1)} ***end of code*** Returns the future value of an investment using the terms specified above. [Value]2581.40337406012
INTRATE: Syntax - ***start of code*** INTRATE(<settlement>, <maturity>, <investment>, <redemption>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date is January 1, 2038, which is 30 years after the January 1, 2008, issue date. INTRATE is calculated as follows$$\text{INTRATE} = \frac{\text{redemption} - \text{investment}}{\text{investment}} \times \frac{\text{B}}{\text{DIM}}$$where$\text{B}$ = number of days in a year, depending on the year basis.$\text{DIM}$ = number of days from settlement to maturity. $\text{B}$ = number of days in a year, depending on the year basis. $\text{DIM}$ = number of days from settlement to maturity. settlement and maturity are truncated to integers. basis is rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.investment ≤ 0.redemption ≤ 0.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. investment ≤ 0. redemption ≤ 0. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription2/15/2008Settlement date5/15/2008Maturity date\$1,000,000Investment\$1,014,420Redemption value2Actual/360 basis The following DAX query ***start of code*** EVALUATE{  INTRATE(DATE(2008,2,15), DATE(2008,5,15), 1000000, 1014420, 2)} ***end of code*** Returns the discount rate for a bond using the terms specified above. [Value]0.05768
IPMT: Syntax - ***start of code*** IPMT(<rate>, <per>, <nper>, <pv>[, <fv>[, <type>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Make sure that you are consistent about the units you use for specifying rate and nper. If you make monthly payments on a four-year loan at 12 percent annual interest, use 0.12/12 for rate and 4*12 for nper. If you make annual payments on the same loan, use 0.12 for rate and 4 for nper. For all the arguments, cash you pay out, such as deposits to savings, is represented by negative numbers; cash you receive, such as dividend checks, is represented by positive numbers. type is rounded to the nearest integer. An error is returned ifper < 1 or per > npernper < 1 per < 1 or per > nper nper < 1 This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
ISPMT: Syntax - ***start of code*** ISPMT(<rate>, <per>, <nper>, <pv>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Make sure that you are consistent about the units you use for specifying rate and nper. If you make monthly payments on a four-year loan at an annual interest rate of 12 percent, use 0.12/12 for rate and 4*12 for nper. If you make annual payments on the same loan, use 0.12 for rate and 4 for nper. For all the arguments, the cash you pay out, such as deposits to savings or other withdrawals, is represented by negative numbers; the cash you receive, such as dividend checks and other deposits, is represented by positive numbers. ISPMT counts each period beginning with zero, not one. Most loans use a repayment schedule with even periodic payments. The IPMT function returns the interest payment for a given period for this type of loan. Some loans use a repayment schedule with even principal payments. The ISPMT function returns the interest payment for a given period for this type of loan. An error is returned ifnper = 0. nper = 0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription\$4,000Present value4Number of periods10%Rate To illustrate when to use ISPMT, the amortization table below uses an even-principal repayment schedule with the terms specified above. The interest charge each period is equal to the rate times the unpaid balance for the previous period. And the payment each period is equal to the even principal plus the interest for the period. PeriodPrincipal PaymentInterest PaymentTotal PaymentBalance4,000.0011,000.00400.001,400.003,000.0021,000.00300.001,300.002,000.0031,000.00200.001,200.001,000.0041,000.00100.001,100.000.00 The following DAX query ***start of code*** DEFINEVAR NumPaymentPeriods = 4VAR PaymentPeriods = GENERATESERIES(0, NumPaymentPeriods-1)EVALUATEADDCOLUMNS (  PaymentPeriods,  "Interest Payment",  ISPMT(0.1, [Value], NumPaymentPeriods, 4000)) ***end of code*** Returns the interest paid during each period, using the even-principal repayment schedule and terms specified above. The values are negative to indicate that it is interest paid, not received. [Value][Interest Payment]0-4001-3002-2003-100
MDURATION: Syntax - ***start of code*** MDURATION(<settlement>, <maturity>, <coupon>, <yld>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date is January 1, 2038, which is 30 years after the January 1, 2008, issue date. Modified duration is defined as follows$$\text{MDURATION} = \frac{\text{DURATION}}{1 + (\frac{\text{Market yield}}{\text{Coupon payments per year}})}$$ settlement and maturity are truncated to integers. frequency, and basis are rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.coupon < 0.yld < 0frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. coupon < 0. yld < 0 frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription1/1/2008Settlement date1/1/2016Maturity date8%Percent coupon9%Percent yield2Frequency is semiannual (see above)1Actual/actual basis (see above) The following DAX query ***start of code*** EVALUATE{  MDURATION(DATE(2008,1,1), DATE(2016,1,1), 0.08, 0.09, 2, 1)} ***end of code*** Returns the modified Macauley duration of a bond using the terms specified above. [Value]5.73566981391884
NOMINAL: Syntax - ***start of code*** NOMINAL(<effect_rate>, <npery>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - The relationship between NOMINAL and EFFECT is shown in the following equation$$\text{EFFECT} = \Big( 1 + \frac{\text{nominal_rate}}{\text{npery}} \Big)^{\text{npery}} - 1$$ npery is rounded to the nearest integer. An error is returned ifeffect_rate ≤ 0.npery < 1. effect_rate ≤ 0. npery < 1. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription5.3543%Effective interest rate4Number of compounding periods per year The following DAX query ***start of code*** EVALUATE{  NOMINAL(0.053543, 4)} ***end of code*** Returns the nominal interest rate, using the terms specified above. [Value]0.052500319868356
NPER: Syntax - ***start of code*** NPER(<rate>, <pmt>, <pv>[, <fv>[, <type>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - type is rounded to the nearest integer. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription12%Annual interest rate-100Payment made each period-1000Present value10000Future value1Payment is due at the beginning of the period (see above) The following DAX query ***start of code*** EVALUATE{  NPER(0.12/12, -100, -1000, 10000, 1)} ***end of code*** Returns the number of periods for the investment described by the terms specified above. [Value]59.6738656742946
ODDFPRICE: Syntax - ***start of code*** ODDFPRICE(<settlement>, <maturity>, <issue>, <first_coupon>, <rate>, <yld>, <redemption>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. ODDFPRICE is calculated as followsOdd short first coupon$$\text{ODDFPRICE} = \bigg[ \frac{\text{redemption}}{(1 + \frac{\text{yld}}{\text{frequency}})^{(N - 1 + \frac{\text{DSC}}{\text{E}})}} \bigg] + \bigg[ \frac{100 \times \frac{\text{rate}}{\text{frequency}} \times \frac{\text{DFC}}{\text{E}}}{(1 + \frac{\text{yld}}{\text{frequency}})^{(\frac{\text{DSC}}{\text{E}})}} \bigg] + \bigg[ \sum^{N}_{k=2} \frac{100 \times \frac{\text{rate}}{\text{frequency}}}{(1 + \frac{\text{yld}}{\text{frequency}})^{(k - 1 + \frac{\text{DSC}}{\text{E}})}} \bigg] - \Big[ 100 \times \frac{\text{rate}}{\text{frequency}} \times \frac{\text{A}}{\text{E}} \Big] $$where$\text{A}$ = number of days from the beginning of the coupon period to the settlement date (accrued days).$\text{DSC}$ = number of days from the settlement to the next coupon date.$\text{DFC}$ = number of days from the beginning of the odd first coupon to the first coupon date.$\text{E}$ = number of days in the coupon period.$\text{N}$ = number of coupons payable between the settlement date and the redemption date. (If this number contains a fraction, it is raised to the next whole number.)Odd long first coupon$$\text{ODDFPRICE} = \bigg[ \frac{\text{redemption}}{(1 + \frac{\text{yld}}{\text{frequency}})^{(\text{N} + \text{N}_{q} + \frac{\text{DSC}}{\text{E}})}} \bigg] + \bigg[ \frac{100 \times \frac{\text{rate}}{\text{frequency}} \times \Big[ \sum^{\text{NC}}_{i=1} \frac{\text{DC}_{i}}{\text{NL}_{i}} \Big]  }{(1 + \frac{\text{yld}}{\text{frequency}})^{(\text{N}_{q} + \frac{\text{DSC}}{\text{E}})}} \bigg] + \bigg[ \sum^{\text{N}}_{k=1} \frac{100 \times \frac{\text{rate}}{\text{frequency}}}{(1 + \frac{\text{yld}}{\text{frequency}})^{(k - \text{N}_{q} + \frac{\text{DSC}}{\text{E}})}} \bigg] - \Big[ 100 \times \frac{\text{rate}}{\text{frequency}} \times \sum^{\text{NC}}_{i=1} \frac{\text{A}_{i}}{\text{NL}_{i}} \Big]$$where$\text{A}_{i}$ = number of days from the beginning of the $i^{th}$, or last, quasi-coupon period within odd period.$\text{DC}_{i}$ = number of days from dated date (or issue date) to first quasi-coupon ($i = 1$) or number of days in quasi-coupon ($i = 2$,..., $i = \text{NC}$).$\text{DSC}$ = number of days from settlement to next coupon date.$\text{E}$ = number of days in coupon period.$\text{N}$ = number of coupons payable between the first real coupon date and redemption date. (If this number contains a fraction, it is raised to the next whole number.)$\text{NC}$ = number of quasi-coupon periods that fit in odd period. (If this number contains a fraction, it is raised to the next whole number.)$\text{NL}_{i}$ = normal length in days of the full $i^{th}$, or last, quasi-coupon period within odd period.$\text{N}_{q}$ = number of whole quasi-coupon periods between settlement date and first coupon. $\text{A}$ = number of days from the beginning of the coupon period to the settlement date (accrued days). $\text{DSC}$ = number of days from the settlement to the next coupon date. $\text{DFC}$ = number of days from the beginning of the odd first coupon to the first coupon date. $\text{E}$ = number of days in the coupon period. $\text{N}$ = number of coupons payable between the settlement date and the redemption date. (If this number contains a fraction, it is raised to the next whole number.) $\text{A}_{i}$ = number of days from the beginning of the $i^{th}$, or last, quasi-coupon period within odd period. $\text{DC}_{i}$ = number of days from dated date (or issue date) to first quasi-coupon ($i = 1$) or number of days in quasi-coupon ($i = 2$,..., $i = \text{NC}$). $\text{DSC}$ = number of days from settlement to next coupon date. $\text{E}$ = number of days in coupon period. $\text{N}$ = number of coupons payable between the first real coupon date and redemption date. (If this number contains a fraction, it is raised to the next whole number.) $\text{NC}$ = number of quasi-coupon periods that fit in odd period. (If this number contains a fraction, it is raised to the next whole number.) $\text{NL}_{i}$ = normal length in days of the full $i^{th}$, or last, quasi-coupon period within odd period. $\text{N}_{q}$ = number of whole quasi-coupon periods between settlement date and first coupon. settlement, maturity, issue, and first_coupon are truncated to integers. basis and frequency are rounded to the nearest integer. An error is returned ifsettlement, maturity, issue, or first_coupon is not a valid date.maturity > first_coupon > settlement > issue is not satisfied.rate < 0.yld < 0.redemption ≤ 0.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement, maturity, issue, or first_coupon is not a valid date. maturity > first_coupon > settlement > issue is not satisfied. rate < 0. yld < 0. redemption ≤ 0. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataArgument description11/11/2008Settlement date3/1/2021Maturity date10/15/2008Issue date3/1/2009First coupon date7.85%Percent coupon6.25%Percent yield\$100.00Redemptive value2Frequency is semiannual1Actual/actual basis The following DAX query ***start of code*** EVALUATE{  ODDFPRICE(DATE(2008,11,11), DATE(2021,3,1), DATE(2008,10,15), DATE(2009,3,1), 0.0785, 0.0625, 100.00, 2, 1)} ***end of code*** Returns the price per \$100 face value of a security having an odd (short or long) first period, using the terms specified above. [Value]113.597717474079
ODDFYIELD: Syntax - ***start of code*** ODDFYIELD(<settlement>, <maturity>, <issue>, <first_coupon>, <rate>, <pr>, <redemption>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The***start of code*** settlement ***end of code***date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. ODDFYIELD is calculated using an iterative method. It uses the Newton method based on the formula used for the function ODDFPRICE. The yield is changed through 100 iterations until the estimated price with the given yield is close to the price. See ODDFPRICE for the formula that ODDFYIELD uses. settlement, maturity, issue, and first_coupon are truncated to integers. basis and frequency are rounded to the nearest integer. An error is returned if***start of code*** settlement ***end of code***,***start of code*** maturity ***end of code***,***start of code*** issue ***end of code***, or***start of code*** first_coupon ***end of code***is not a valid date.***start of code*** maturity ***end of code***>***start of code*** first_coupon ***end of code***>***start of code*** settlement ***end of code***>***start of code*** issue ***end of code***is not satisfied.***start of code*** rate ***end of code***< 0.***start of code*** pr ***end of code***≤ 0.***start of code*** redemption ***end of code***≤ 0.***start of code*** frequency ***end of code***is any number other than 1, 2, or 4.***start of code*** basis ***end of code***< 0 or***start of code*** basis ***end of code***> 4. ***start of code*** settlement ***end of code***,***start of code*** maturity ***end of code***,***start of code*** issue ***end of code***, or***start of code*** first_coupon ***end of code***is not a valid date. ***start of code*** maturity ***end of code***>***start of code*** first_coupon ***end of code***>***start of code*** settlement ***end of code***>***start of code*** issue ***end of code***is not satisfied. ***start of code*** rate ***end of code***< 0. ***start of code*** pr ***end of code***≤ 0. ***start of code*** redemption ***end of code***≤ 0. ***start of code*** frequency ***end of code***is any number other than 1, 2, or 4. ***start of code*** basis ***end of code***< 0 or***start of code*** basis ***end of code***> 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataArgument descriptionNovember 11, 2008Settlement dateMarch 1, 2021Maturity dateOctober 15, 2008Issue dateMarch 1, 2009First coupon date5.75%Percent coupon84.50Price100Redemptive value2Frequency is semiannual030/360 basis The following DAX query ***start of code*** EVALUATE{  ODDFYIELD(DATE(2008,11,11), DATE(2021,3,1), DATE(2008,10,15), DATE(2009,3,1), 0.0575, 84.50, 100, 2, 0)} ***end of code*** Returns the yield of a security that has an odd (short or long) first period, using the terms specified above. [Value]0.0772455415972989
ODDLPRICE: Syntax - ***start of code*** ODDLPRICE(<settlement>, <maturity>, <last_interest>, <rate>, <yld>, <redemption>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. settlement, maturity, and last_interest are truncated to integers. basis and frequency are rounded to the nearest integer. An error is returned ifsettlement, maturity, or last_interest is not a valid date.maturity > settlement > last_interest is not satisfied.rate < 0.yld < 0.redemption ≤ 0.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement, maturity, or last_interest is not a valid date. maturity > settlement > last_interest is not satisfied. rate < 0. yld < 0. redemption ≤ 0. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query DataArgument descriptionFebruary 7, 2008Settlement dateJune 15, 2008Maturity dateOctober 15, 2007Last interest date3.75%Percent coupon4.05%Percent yield\$100Redemptive value2Frequency is semiannual030/360 basis ***start of code*** EVALUATE{  ODDLPRICE(DATE(2008,2,7), DATE(2008,6,15), DATE(2007,10,15), 0.0375, 0.0405, 100, 2, 0)} ***end of code*** Returns the price per \$100 face value of a security that has an odd (short or long) last coupon period, using the terms specified above. [Value]99.8782860147213
ODDLYIELD: Syntax - ***start of code*** ODDLYIELD(<settlement>, <maturity>, <last_interest>, <rate>, <pr>, <redemption>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. ODDLYIELD is calculated as follows$$\text{ODDLYIELD} = \bigg[ \frac{(\text{redemption} + ((\sum^{\text{NC}}_{i=1} \frac{\text{DC}_{i}}{\text{NL}_{i}}) \times \frac{100 \times \text{rate}}{\text{frequency}})) - (\text{par} + ((\sum^{\text{NC}}_{i=1} \frac{\text{A}_{i}}{\text{NL}_{i}}) \times \frac{100 \times \text{rate}}{\text{frequency}}))}{\text{par} + ((\sum^{\text{NC}}_{i=1} \frac{\text{A}_{i}}{\text{NL}_{i}}) \times \frac{100 \times \text{rate}}{\text{frequency}})} \bigg] \times \bigg[ \frac{\text{frequency}}{(\sum^{\text{NC}}_{i=1} \frac{\text{DSC}_{i}}{\text{NL}_{i}})} \bigg]$$where$\text{A}_{i}$ = number of accrued days for the $i^{th}$, or last, quasi-coupon period within odd period counting forward from last interest date before redemption.$\text{DC}_{i}$ = number of days counted in the $i^{th}$, or last, quasi-coupon period as delimited by the length of the actual coupon period.$\text{NC}$ = number of quasi-coupon periods that fit in odd period; if this number contains a fraction it will be raised to the next whole number.$\text{NL}_{i}$ = normal length in days of the $i^{th}$, or last, quasi-coupon period within odd coupon period. $\text{A}_{i}$ = number of accrued days for the $i^{th}$, or last, quasi-coupon period within odd period counting forward from last interest date before redemption. $\text{DC}_{i}$ = number of days counted in the $i^{th}$, or last, quasi-coupon period as delimited by the length of the actual coupon period. $\text{NC}$ = number of quasi-coupon periods that fit in odd period; if this number contains a fraction it will be raised to the next whole number. $\text{NL}_{i}$ = normal length in days of the $i^{th}$, or last, quasi-coupon period within odd coupon period. settlement, maturity, last_interest are truncated to integers. basis and frequency are rounded to the nearest integer. An error is returned ifsettlement, maturity, last_interest is not a valid date.maturity > settlement > last_interest is not satisfied.rate < 0.pr ≤ 0.redemption ≤ 0.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement, maturity, last_interest is not a valid date. maturity > settlement > last_interest is not satisfied. rate < 0. pr ≤ 0. redemption ≤ 0. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query DataArgument description4/20/2008Settlement date6/15/2008Maturity date12/24/2007Last interest date3.75%Percent coupon\$99.875Price\$100Redemption value2Frequency is semiannual030/360 basis ***start of code*** EVALUATE{  ODDLYIELD(DATE(2008,4,20), DATE(2008,6,15), DATE(2007,12,24), 0.0375, 99.875, 100, 2, 0)} ***end of code*** Returns the yield of a security that has an odd (short of long) last period, using the terms specified above. [Value]0.0451922356291692
PDURATION: Syntax - ***start of code*** PDURATION(<rate>, <pv>, <fv>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - PDURATION uses the following equation$$\text{PDURATION} = \frac{log(\text{fv}) - log(\text{pv})}{log(1 + \text{rate})}$$ An error is returned ifrate ≤ 0.pv ≤ 0.fv ≤ 0. rate ≤ 0. pv ≤ 0. fv ≤ 0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
PMT: Syntax - ***start of code*** PMT(<rate>, <nper>, <pv>[, <fv>[, <type>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - The payment returned by PMT includes principal and interest but no taxes, reserve payments, or fees sometimes associated with loans. Make sure that you are consistent about the units you use for specifying rate and nper. If you make monthly payments on a four-year loan at an annual interest rate of 12 percent, use 0.12/12 for rate and 4*12 for nper. If you make annual payments on the same loan, use 0.12 for rate and 4 for nper. ***start of code*** type ***end of code***is rounded to the nearest integer. An error is returned if***start of code*** nper < 1 ***end of code*** ***start of code*** nper < 1 ***end of code*** ~ Example - There is no provided example for this function.
PPMT: Syntax - ***start of code*** PPMT(<rate>, <per>, <nper>, <pv>[, <fv>[, <type>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Make sure that you are consistent about the units you use for specifying***start of code*** rate ***end of code***and***start of code*** nper ***end of code***. If you make monthly payments on a four-year loan at an annual interest rate of 12 percent, use 0.12/12 for rate and 4*12 for nper. If you make annual payments on the same loan, use 0.12 for***start of code*** rate ***end of code***and 4 for***start of code*** nper ***end of code***. type is rounded to the nearest integer. An error is returned if***start of code*** per < 1 ***end of code***or***start of code*** per > nper ***end of code******start of code*** nper < 1 ***end of code*** ***start of code*** per < 1 ***end of code***or***start of code*** per > nper ***end of code*** ***start of code*** nper < 1 ***end of code*** This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
PRICE: Syntax - ***start of code*** PRICE(<settlement>, <maturity>, <rate>, <yld>, <redemption>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. settlement and maturity are truncated to integers. basis and frequency are rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.rate < 0.yld < 0.redemption ≤ 0.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. rate < 0. yld < 0. redemption ≤ 0. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataArgument description2/15/2008Settlement date11/15/2017Maturity date5.75%Percent semiannual coupon6.50%Percent yield\$100Redemption value2Frequency is semiannual030/360 basis The following DAX query ***start of code*** EVALUATE{  PRICE(DATE(2008,2,15), DATE(2017,11,15), 0.0575, 0.065, 100, 2, 0)} ***end of code*** Returns the bond price, for a bond using the terms specified above. [Value]94.6343616213221
PRICEDISC: Syntax - ***start of code*** PRICEDISC(<settlement>, <maturity>, <discount>, <redemption>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2018, and is purchased by a buyer six months later. The issue date would be January 1, 2018, the settlement date would be July 1, 2018, and the maturity date would be January 1, 2048, 30 years after the January 1, 2018, issue date. PRICEDISC is calculated as follows$$\text{PRICEDISC} = \text{redemption} - \text{discount} \times \text{redemption} \times \frac{\text{DSM}}{\text{B}}$$where$\text{B}$ = number of days in year, depending on year basis.$\text{DSM}$ = number of days from settlement to maturity. $\text{B}$ = number of days in year, depending on year basis. $\text{DSM}$ = number of days from settlement to maturity. settlement and maturity are truncated to integers. basis is rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.discount ≤ 0.redemption ≤ 0.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. discount ≤ 0. redemption ≤ 0. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataArgument description2/16/2008Settlement date3/1/2008Maturity date5.25%Percent discount rate\$100Redemption value2Actual/360 basis The following DAX query ***start of code*** EVALUATE{  PRICEDISC(DATE(2008,2,16), DATE(2008,3,1), 0.0525, 100, 2)} ***end of code*** Returns the bond price per \$100 face value, for a bond with the terms specified above. [Value]99.7958333333333
PRICEMAT: Syntax - ***start of code*** PRICEMAT(<settlement>, <maturity>, <issue>, <rate>, <yld>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. PRICEMAT is calculated as follows$$\text{PRICEMAT} = \frac{100 + (\frac{\text{DIM}}{\text{B}} \times \text{rate} \times 100)}{1 + (\frac{\text{DSM}}{\text{B}} \times \text{yld})} - (\frac{\text{A}}{\text{B}} \times \text{rate} \times 100)$$where$\text{B}$ = number of days in year, depending on year basis.$\text{DSM}$ = number of days from settlement to maturity.$\text{DIM}$ = number of days from issue to maturity.$\text{A}$ = number of days from issue to settlement. $\text{B}$ = number of days in year, depending on year basis. $\text{DSM}$ = number of days from settlement to maturity. $\text{DIM}$ = number of days from issue to maturity. $\text{A}$ = number of days from issue to settlement. settlement, maturity, and issue are truncated to integers. basis is rounded to the nearest integer. An error is returned ifsettlement, maturity, or issue is not a valid date.maturity > settlement > issue is not satisfied.rate < 0.yld < 0.basis < 0 or basis > 4. settlement, maturity, or issue is not a valid date. maturity > settlement > issue is not satisfied. rate < 0. yld < 0. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query DataDescription2/15/2008Settlement date4/13/2008Maturity date11/11/2007Issue date6.10%Percent semiannual coupon6.10%Percent yield030/360 basis ***start of code*** EVALUATE{  PRICEMAT(DATE(2008,2,15), DATE(2008,4,13), DATE(2007,11,11), 0.061, 0.061, 0)} ***end of code*** Returns the price per \$100 face value of a security with the terms specified above. [Value]99.9844988755569
PV: Syntax - ***start of code*** PV(<rate>, <nper>, <pmt>[, <fv>[, <type>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Make sure that you are consistent about the units you use for specifying rate and nper. If you make monthly payments on a four-year loan at 12 percent annual interest, use 0.12/12 for rate and 4*12 for nper. If you make annual payments on the same loan, use 0.12 for rate and 4 for nper. The following functions apply to annuities***start of code*** CUMIPMT ***end of code******start of code*** CUMPRINC ***end of code******start of code*** FV ***end of code******start of code*** IPMT ***end of code******start of code*** PMT ***end of code******start of code*** PPMT ***end of code******start of code*** PV ***end of code******start of code*** RATE ***end of code******start of code*** XIRR ***end of code******start of code*** XNPV ***end of code*** ***start of code*** CUMIPMT ***end of code*** ***start of code*** CUMPRINC ***end of code*** ***start of code*** FV ***end of code*** ***start of code*** IPMT ***end of code*** ***start of code*** PMT ***end of code*** ***start of code*** PPMT ***end of code*** ***start of code*** PV ***end of code*** ***start of code*** RATE ***end of code*** ***start of code*** XIRR ***end of code*** ***start of code*** XNPV ***end of code*** An annuity is a series of constant cash payments made over a continuous period. For example, a car loan or a mortgage is an annuity. For more information, see the description for each annuity function. In annuity functions, cash you pay out, such as a deposit to savings, is represented by a negative number; cash you receive, such as a dividend check, is represented by a positive number. For example, a \$1,000 deposit to the bank would be represented by the argument -1000 if you are the depositor and by the argument 1000 if you are the bank. One financial argument is solved in terms of the others.If rate is not 0, then$$\text{pv} \times (1 + \text{rate})^{\text{nper}} + \text{pmt}(1 + \text{rate} \times \text{type}) \times \bigg( \frac{(1 + \text{rate})^{\text{nper}} - 1}{\text{rate}} \bigg) + \text{fv} = 0$$If rate is 0, then$$(\text{pmt} \times \text{nper}) + \text{pv} + \text{fv} = 0$$ If rate is not 0, then$$\text{pv} \times (1 + \text{rate})^{\text{nper}} + \text{pmt}(1 + \text{rate} \times \text{type}) \times \bigg( \frac{(1 + \text{rate})^{\text{nper}} - 1}{\text{rate}} \bigg) + \text{fv} = 0$$ If rate is 0, then$$(\text{pmt} \times \text{nper}) + \text{pv} + \text{fv} = 0$$ type is rounded to the nearest integer. An error is returned ifnper < 1 or blank nper < 1 or blank This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription\$500.00Money paid out of an insurance annuity at the end of every month.8%Interest rate earned on the money paid out.20Years the money will be paid out. The following DAX query ***start of code*** EVALUATE{  PV(0.08/12, 12*20, 500.00, 0, 0)} ***end of code*** Returns the present value of an annuity using the terms specified above. [Value]-59777.1458511878
RATE: Syntax - ***start of code*** RATE(<nper>, <pmt>, <pv>[, <fv>[, <type>[, <guess>]]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Make sure that you are consistent about the units you use for specifying guess and nper. If you make monthly payments on a four-year loan at 12 percent annual interest, use 0.12/12 for guess and 4*12 for nper. If you make annual payments on the same loan, use 0.12 for guess and 4 for nper. type is rounded to the nearest integer. An error is returned ifnper ≤ 0.RATE does not converge to within 0.0000001 after 20 iterations nper ≤ 0. RATE does not converge to within 0.0000001 after 20 iterations This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
RECEIVED: Syntax - ***start of code*** RECEIVED(<settlement>, <maturity>, <investment>, <discount>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. RECEIVED is calculated as follows$$\text{RECEIVED} = \frac{\text{investment}}{1 - (\text{discount} \times \frac{\text{DIM}}{\text{B}})}$$where$\text{B}$ = number of days in a year, depending on the year basis.$\text{DIM}$ = number of days from issue to maturity. $\text{B}$ = number of days in a year, depending on the year basis. $\text{DIM}$ = number of days from issue to maturity. settlement and maturity are truncated to integers. basis is rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.investment ≤ 0.discount ≤ 0.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. investment ≤ 0. discount ≤ 0. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query DataDescription15-Feb-08Settlement (issue) date15-May-08Maturity date\$1,000,000.00Investment5.75%Percent discount rate2Actual/360 basis ***start of code*** EVALUATE{  RECEIVED(DATE(2008,2,15), DATE(2008,5,15), 1000000.00, 0.0575, 2)} ***end of code*** Returns the total amount to be received at maturity, for a bond with the terms specified above. [Value]1014584.6544071
RRI: Syntax - ***start of code*** RRI(<nper>, <pv>, <fv>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - RRI returns the interest rate given $\text{nper}$ (the number of periods), $\text{pv}$ (present value), and $\text{fv}$ (future value), calculated by using the following equation$$\bigg( \frac{\text{fv}}{\text{pv}} \bigg)^{(\frac{1}{\text{}nper})} - 1$$ An error is returned ifnper ≤ 0. nper ≤ 0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription\$10,000Present value\$21,000Future value4Years invested The following DAX query ***start of code*** EVALUATE{  RRI(4*12, 10000, 21000)} ***end of code*** Returns an equivalent interest rate for the growth of an investment with the terms specified above. [Value]0.0155771057566627
SLN: Syntax - ***start of code*** SLN(<cost>, <salvage>, <life>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - An error is returned iflife = 0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription\$30,000Cost\$7,500Salvage value10Years of useful life The following DAX query ***start of code*** EVALUATE{  SLN(30000, 7500, 10)} ***end of code*** Returns the yearly depreciation allowance using the terms specified above. [Value]2250
SYD: Syntax - ***start of code*** SYD(<cost>, <salvage>, <life>, <per>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - SYD is calculated as follows$$\text{SYD} = \frac{(\text{cost} - \text{salvage}) \times (\text{life} - \text{per} + 1) \times 2}{(\text{life}) \times (\text{life} + 1)}$$ An error is returned iflife < 1.per < 1 or per > life. life < 1. per < 1 or per > life. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
TBILLEQ: Syntax - ***start of code*** TBILLEQ(<settlement>, <maturity>, <discount>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. TBILLEQ is calculated as$$\text{TBILLEQ} = \frac{365 \times \text{discount}}{360 - (\text{discount} \times \text{DSM})}$$where$\text{DSM}$ is the number of days between settlement and maturity computed according to the 360 days per year basis. $\text{DSM}$ is the number of days between settlement and maturity computed according to the 360 days per year basis. settlement and maturity are truncated to integers. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity or maturity is more than one year after settlement.discount ≤ 0. settlement or maturity is not a valid date. settlement ≥ maturity or maturity is more than one year after settlement. discount ≤ 0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription3/31/2008Settlement date6/1/2008Maturity date9.14%Percent discount rate The following DAX query ***start of code*** EVALUATE{  TBILLEQ(DATE(2008,3,31), DATE(2008,6,1), 0.0914)} ***end of code*** Returns the bond-equivalent yield for a Treasury bill using the terms specified above. [Value]0.094151493565943
TBILLPRICE: Syntax - ***start of code*** TBILLPRICE(<settlement>, <maturity>, <discount>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. TBILLPRICE is calculated as follows$$\text{TBILLPRICE} = 100 \times (1 - \frac{\text{discount} \times \text{DSM}}{360})$$where$\text{DSM}$ = number of days from settlement to maturity, excluding any maturity date that is more than one calendar year after the settlement date. $\text{DSM}$ = number of days from settlement to maturity, excluding any maturity date that is more than one calendar year after the settlement date. settlement and maturity are truncated to integers. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity or maturity is more than one year after settlement.discount ≤ 0. settlement or maturity is not a valid date. settlement ≥ maturity or maturity is more than one year after settlement. discount ≤ 0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription3/31/2008Settlement date6/1/2008Maturity date9.0%Percent discount rate The following DAX query ***start of code*** EVALUATE{  TBILLPRICE(DATE(2008,3,31), DATE(2008,6,1), 0.09)} ***end of code*** Returns the Treasury Bill's price per \$100 face value, given the terms specified above. [Value]98.45
TBILLYIELD: Syntax - ***start of code*** TBILLYIELD(<settlement>, <maturity>, <pr>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. TBILLYIELD is calculated as follows$$\text{TBILLYIELD} = \frac{100 - \text{pr}}{\text{pr}} \times \frac{360}{\text{DSM}}$$where$\text{DSM}$ = number of days from settlement to maturity, excluding any maturity date that is more than one calendar year after the settlement date. $\text{DSM}$ = number of days from settlement to maturity, excluding any maturity date that is more than one calendar year after the settlement date. settlement and maturity are truncated to integers. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity or maturity is more than one year after settlement.pr ≤ 0. settlement or maturity is not a valid date. settlement ≥ maturity or maturity is more than one year after settlement. pr ≤ 0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query DataDescription3/31/2008Settlement date6/1/2008Maturity date\$98.45Price per \$100 face value ***start of code*** EVALUATE{  TBILLYIELD(DATE(2008,3,31), DATE(2008,6,1), 98.45)} ***end of code*** Returns the yield of a Treasury bill using the terms specified above. [Value]0.0914169629253426
VDB: Syntax - ***start of code*** VDB(<cost>, <salvage>, <life>, <start_period>, <end_period>[, <factor>[, <no_switch>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - An error is returned ifcost < 0.salvage < 0.life < 1.start_period < 1 or start_period > end_period.end_period < start_period or end_period > life.factor < 0.no_switch does not evaluate to either***start of code*** TRUE ***end of code***or***start of code*** FALSE ***end of code***. cost < 0. salvage < 0. life < 1. start_period < 1 or start_period > end_period. end_period < start_period or end_period > life. factor < 0. no_switch does not evaluate to either***start of code*** TRUE ***end of code***or***start of code*** FALSE ***end of code***. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
XIRR: Syntax - ***start of code*** XIRR(<table>, <values>, <dates>, [, <guess>[, <alternateResult>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Internal rate of return for the given inputs. If the calculation fails to return a valid result, an error or value specified as alternateResult is returned. ~ Remarks - The value is calculated as the rate that satisfies the following function$$0=\sum^{N}_{j=1} \frac{P_{j}}{(1 + \text{rate})^{\frac{d_{j} - d_{1}}{365}}}$$Where$P_{j}$ is the $j^{th}$ payment$d_{j}$ is the $j^{th}$ payment date$d_{1}$ is the first payment date $P_{j}$ is the $j^{th}$ payment $d_{j}$ is the $j^{th}$ payment date $d_{1}$ is the first payment date The series of cash flow values must contain at least one positive number and one negative number. Avoid using ISERROR or IFERROR functions to capture an error returned by XIRR. If some inputs to the function may result in a no solution error, providing an alternateResult parameter is the most reliable and highest performing way to handle the error. To learn more about using the alternateResult parameter, be to check out thisvideo. When the absolute value of initial payment is small, the calculation likely fails to return a valid result. Avoid including 0 values in payments. They will not impact the final result, and using 0 as initial payment will fail XIRR() calculation always. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following formula calculates the internal rate of return of the CashFlows table ***start of code*** = XIRR( CashFlows, [Payment], [Date] ) ***end of code*** DatePayment1/1/2014-100003/1/2014275010/30/201442502/15/201532504/1/20152750 Rate of return = 37.49%
XNPV: Syntax - ***start of code*** XNPV(<table>, <values>, <dates>, <rate>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Net present value. ~ Remarks - The value is calculated as the following summation$$\sum^{N}_{j=1} \frac{P_{j}}{(1 + \text{rate})^{\frac{d_{j} - d_{1}}{365}}}$$Where$P_{j}$ is the $j^{th}$ payment$d_{j}$ is the $j^{th}$ payment date$d_{1}$ is the first payment date $P_{j}$ is the $j^{th}$ payment $d_{j}$ is the $j^{th}$ payment date $d_{1}$ is the first payment date The series of cash flow values must contain at least one positive number and one negative number. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following calculates the present value of the CashFlows table ***start of code*** = XNPV( CashFlows, [Payment], [Date], 0.09 ) ***end of code*** ***start of code*** Date ***end of code***Payment***start of code*** 1/1/2014 ***end of code***-10000***start of code*** 3/1/2014 ***end of code***2750***start of code*** 10/30/2014 ***end of code***4250***start of code*** 2/15/2015 ***end of code***3250***start of code*** 4/1/2015 ***end of code***2750 Present value = 2089.50
YIELD: Syntax - ***start of code*** YIELD(<settlement>, <maturity>, <rate>, <pr>, <redemption>, <frequency>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. If there is one coupon period or less until redemption, YIELD is calculated as follows$$\text{YIELD} = \frac{(\frac{\text{redemption}}{100} + \frac{\text{rate}}{\text{frequency}}) - (\frac{\text{par}}{100} + (\frac{\text{A}}{\text{E}} \times \frac{\text{rate}}{\text{frequency}}))}{\frac{\text{par}}{100} + (\frac{\text{A}}{\text{E}} \times \frac{\text{rate}}{\text{frequency}})} \times \frac{\text{frequency} \times \text{E}}{\text{DSR}}$$where$\text{A}$ = number of days from the beginning of the coupon period to the settlement date (accrued days).$\text{DSR}$ = number of days from the settlement date to the redemption date.$\text{E}$ = number of days in the coupon period. $\text{A}$ = number of days from the beginning of the coupon period to the settlement date (accrued days). $\text{DSR}$ = number of days from the settlement date to the redemption date. $\text{E}$ = number of days in the coupon period. If there is more than one coupon period until redemption, YIELD is calculated through a hundred iterations. The resolution uses the Newton method, based on the formula used for the function PRICE. The yield is changed until the estimated price given the yield is close to price. settlement and maturity are truncated to integers. frequency, and basis are rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.rate < 0.pr ≤ 0.redemption ≤ 0.frequency is any number other than 1, 2, or 4.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. rate < 0. pr ≤ 0. redemption ≤ 0. frequency is any number other than 1, 2, or 4. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription15-Feb-08Settlement date15-Nov-16Maturity date5.75%Percent coupon95.04287Price\$100Redemption value2Frequency is semiannual (see above)030/360 basis (see above) The following DAX query ***start of code*** EVALUATE{  YIELD(DATE(2008,2,15), DATE(2016,11,15), 0.0575, 95.04287, 100, 2,0)} ***end of code*** Returns the yield on a bond with the terms specified above. [Value]0.0650000068807314
YIELDDISC: Syntax - ***start of code*** YIELDDISC(<settlement>, <maturity>, <pr>, <redemption>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. settlement and maturity are truncated to integers. basis is rounded to the nearest integer. An error is returned ifsettlement or maturity is not a valid date.settlement ≥ maturity.pr ≤ 0.redemption ≤ 0.basis < 0 or basis > 4. settlement or maturity is not a valid date. settlement ≥ maturity. pr ≤ 0. redemption ≤ 0. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - Data-16-Feb-08Settlement date1-Mar-08Maturity date99.795Price\$100Redemption value2Actual/360 basis The following DAX query ***start of code*** EVALUATE{  YIELDDISC(DATE(2008,2,16), DATE(2008,3,1), 99.795, 100, 2)} ***end of code*** Returns the security's annual yield, given the terms specified above. [Value]0.0528225719868583
YIELDMAT: Syntax - ***start of code*** YIELDMAT(<settlement>, <maturity>, <issue>, <rate>, <pr>[, <basis>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks - Dates are stored as sequential serial numbers so they can be used in calculations. In DAX, December 30, 1899 is day 0, and January 1, 2008 is 39448 because it is 39,448 days after December 30, 1899. The settlement date is the date a buyer purchases a coupon, such as a bond. The maturity date is the date when a coupon expires. For example, suppose a 30-year bond is issued on January 1, 2008, and is purchased by a buyer six months later. The issue date would be January 1, 2008, the settlement date would be July 1, 2008, and the maturity date would be January 1, 2038, which is 30 years after the January 1, 2008, issue date. settlement, maturity, and issue are truncated to integers. basis is rounded to the nearest integer. An error is returned ifsettlement, maturity, or issue is not a valid date.maturity > settlement > issue is not satisfied.rate < 0.pr ≤ 0.basis < 0 or basis > 4. settlement, maturity, or issue is not a valid date. maturity > settlement > issue is not satisfied. rate < 0. pr ≤ 0. basis < 0 or basis > 4. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DataDescription15-Mar-08Settlement date3-Nov-08Maturity date8-Nov-07Issue date6.25%Percent semiannual coupon100.0123Price030/360 basis (see above) The following DAX query ***start of code*** EVALUATE{  YIELDMAT(DATE(2008,3,15), DATE(2008,11,3), DATE(2007,11,8), 0.0625, 100.0123, 0)} ***end of code*** Returns the yield for a security using the terms specified above. Value0.0609543336915387
COLUMNSTATISTICS: Syntax - ***start of code*** COLUMNSTATISTICS () ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table of statistics. Each row of this table represents a different column in the model. Table columns include ~ Remarks - Columns in an error state and columns from query-scope calculated tables do not appear in the result table. If a filter from the filter context is applied to COLUMNSTATISTICS(), an error is returned. For binary-typed columns, the Min and Max statistics will have BLANK values. ~ Example - Examples in this article can be used with the sample Adventure Works DW 2020 Power BI Desktop model. To get the model, seeDAX sample model. The following DAX query ***start of code*** DEFINE    TABLE FilteredProduct =        FILTER (            Product,            [Color] == "Blue"        )    COLUMN Customer[Location] = [State-Province] & " " & [Country-Region]EVALUATECOLUMNSTATISTICS () ***end of code*** Returns a table with statistics regarding all columns from all tables in the model. The table also includes statistics for the query-scope calculated column, Customer[Location]. However, the table does not include the columns from the query-scope calculated table, FilteredProduct.
CONTAINS: Syntax - ***start of code*** CONTAINS(<table>, <columnName>, <value>[, <columnName>, <value>]…) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A value of***start of code*** TRUE ***end of code***if each specified***start of code*** value ***end of code***can be found in the corresponding***start of code*** columnName ***end of code***, or are contained, in those columns; otherwise, the function returns***start of code*** FALSE ***end of code***. ~ Remarks - The arguments***start of code*** columnName ***end of code***and***start of code*** value ***end of code***must come in pairs; otherwise an error is returned. ***start of code*** columnName ***end of code***must belong to the specified***start of code*** table ***end of code***, or to a table that is related to***start of code*** table ***end of code***. If***start of code*** columnName ***end of code***refers to a column in a related table then it must be fully qualified; otherwise, an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example creates a measure that tells you whether there were any Internet sales of product 214 and to customer 11185 at the same time. ***start of code*** = CONTAINS(InternetSales, [ProductKey], 214, [CustomerKey], 11185) ***end of code***
CONTAINSROW: Syntax - ***start of code*** CONTAINSROW(<Table>, <Value> [, <Value> [, …] ] )  ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***or***start of code*** FALSE ***end of code***. ~ Remarks - Except syntax, the***start of code*** IN ***end of code***operator and CONTAINSROW function are functionally equivalent.***start of code*** <scalarExpr> IN <tableExpr> ( <scalarExpr1>, <scalarExpr2>, … ) IN <tableExpr> ***end of code***The number of scalarExprN must match the number of columns in tableExpr.NOT IN is not an operator in DAX. To perform the logical negation of the IN operator, put NOT in front of the entire expression. For example, NOT [Color] IN { "Red", "Yellow", "Blue" }. The number of scalarExprN must match the number of columns in tableExpr. NOT IN is not an operator in DAX. To perform the logical negation of the IN operator, put NOT in front of the entire expression. For example, NOT [Color] IN { "Red", "Yellow", "Blue" }. Unlike the = operator, the IN operator and the CONTAINSROW function perform strict comparison. For example, the BLANK value does not match 0. ~ Example - There is no provided example for this function.
CONTAINSSTRING: Syntax - ***start of code*** CONTAINSSTRING(<within_text>, <find_text>)  ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***if find_text is a substring of within_text; otherwise***start of code*** FALSE ***end of code***. ~ Remarks - CONTAINSSTRING is not case-sensitive. You can use***start of code*** ? ***end of code***and***start of code*** * ***end of code***wildcard characters. Use***start of code***  ***end of code***to escape wildcard characters. ~ Example - DAX query ***start of code*** EVALUATE    ROW(        "Case 1", CONTAINSSTRING("abcd", "bc"),         "Case 2", CONTAINSSTRING("abcd", "BC"),        "Case 3", CONTAINSSTRING("abcd", "a*d"),        "Case 4", CONTAINSSTRING("abcd", "ef")    ) ***end of code*** Returns [Case 1][Case 2][Case 3][Case 4]***start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** FALSE ***end of code***
CONTAINSSTRINGEXACT: Syntax - ***start of code*** CONTAINSSTRINGEXACT(<within_text>, <find_text>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***if find_text is a substring of within_text; otherwise***start of code*** FALSE ***end of code***. ~ Remarks -  ~ Example - DAX query ***start of code*** EVALUATE    ROW(        "Case 1", CONTAINSSTRINGEXACT("abcd", "bc"),         "Case 2", CONTAINSSTRINGEXACT("abcd", "BC"),        "Case 3", CONTAINSSTRINGEXACT("abcd", "a*d"),        "Case 4", CONTAINSSTRINGEXACT("abcd", "ef")    ) ***end of code*** Returns [Case 1][Case 2][Case 3][Case 4]***start of code*** TRUE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code***
CUSTOMDATA: Syntax - ***start of code*** CUSTOMDATA() ***end of code*** ~ Parameters - No parameters found ~ Return Value - The content of the***start of code*** CustomData ***end of code***property in the connection string. ~ Remarks -  ~ Example - The following DAX formula verifies if the CustomData property was set to***start of code*** OK ***end of code***. ***start of code*** = IF(CUSTOMDATA()="OK", "Correct Custom data in connection string", "No custom data in connection string property or unexpected value") ***end of code***
HASONEFILTER: Syntax - ***start of code*** HASONEFILTER(<columnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***when the number of directly filtered values on***start of code*** columnName ***end of code***is one; otherwise returns***start of code*** FALSE ***end of code***. ~ Remarks - This function is similar to HASONEVALUE() with the difference that HASONEVALUE() works based on cross-filters while HASONEFILTER() works by a direct filter. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows how to use HASONEFILTER() to return the filter for   ResellerSales_USD[ProductKey]) if there is one filter, or to return BLANK if there are no filters or more than one filter on ResellerSales_USD[ProductKey]). ***start of code*** = IF(HASONEFILTER(ResellerSales_USD[ProductKey]),FILTERS(ResellerSales_USD[ProductKey]),BLANK()) ***end of code***
HASONEVALUE: Syntax - ***start of code*** HASONEVALUE(<columnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***when the context for***start of code*** columnName ***end of code***has been filtered down to one distinct value only. Otherwise is***start of code*** FALSE ***end of code***. ~ Remarks - An equivalent expression for HASONEVALUE() is***start of code*** COUNTROWS(VALUES(<columnName>)) = 1 ***end of code***. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following measure formula verifies if the context is being sliced by one value in order to estimate a percentage against a predefined scenario; in this case you want to compare Reseller Sales against sales in 2007, then you need to know if the context is filtered by single years. Also, if the comparison is meaningless you want to return BLANK. ***start of code*** = IF(HASONEVALUE(DateTime[CalendarYear]),SUM(ResellerSales_USD[SalesAmount_USD])/CALCULATE(SUM(ResellerSales_USD[SalesAmount_USD]),DateTime[CalendarYear]=2007),BLANK()) ***end of code***
ISAFTER: Syntax - ***start of code*** ISAFTER(<scalar_expression>, <scalar_expression>[, sort_order [, <scalar_expression>, <scalar_expression>[, sort_order]]…) ***end of code*** ~ Parameters - No parameters found ~ Return Value - True or false. ~ Remarks -  ~ Example - Table name 'Info' Country/RegionStateCountTotalINDJK20800INDMH251000INDWB10900USACA5500USAWA10900 The following expression ***start of code*** FILTER (    Info,    ISAFTER (        Info[Country], "IND", ASC,        Info[State], "MH", ASC )) ***end of code*** Returns CountryStateCountTotalINDWB10900USACA5500USAWA10900
ISBLANK: Syntax - ***start of code*** ISBLANK(<value>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A Boolean value of***start of code*** TRUE ***end of code***if the value is blank; otherwise***start of code*** FALSE ***end of code***. ~ Remarks -  ~ Example - This formula computes the increase or decrease ratio in sales compared to the previous year. The example uses the IF function to check the value for the previous year's sales in order to avoid a divide by zero error. ***start of code*** //Sales to Previous Year Ratio= IF( ISBLANK('CalculatedMeasures'[PreviousYearTotalSales])   , BLANK()   , ( 'CalculatedMeasures'[Total Sales]-'CalculatedMeasures'[PreviousYearTotalSales] )      /'CalculatedMeasures'[PreviousYearTotalSales]) ***end of code*** Result, Row LabelsTotal SalesTotal Sales Previous YearSales to Previous Year Ratio2005$10,209,985.082006$28,553,348.43$10,209,985.08179.66%2007$39,248,847.52$28,553,348.4337.46%2008$24,542,444.68$39,248,847.52-37.47%Grand Total$102,554,625.71
ISCROSSFILTERED: Syntax - ***start of code*** ISCROSSFILTERED(<TableNameOrColumnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***when***start of code*** ColumnName ***end of code***or a column of***start of code*** TableName ***end of code***is being cross-filtered. Otherwise returns***start of code*** FALSE ***end of code***. ~ Remarks - A column or table is said to be cross-filtered when a filter is applied to***start of code*** ColumnName ***end of code***, any column of***start of code*** TableName ***end of code***, or to any column of a related table. A column or table is said to be filtered directly when a filter is applied to***start of code*** ColumnName ***end of code***or to any column of***start of code*** TableName ***end of code***. Therefore, theISFILTEREDfunction also returns***start of code*** TRUE ***end of code***when***start of code*** ColumnName ***end of code***or any column of***start of code*** TableName ***end of code***is filtered. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
ISEMPTY: Syntax - ***start of code*** ISEMPTY(<table_expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - True if the table is empty (has no rows), if else, False. ~ Remarks -  ~ Example - For the below table named 'Info' Country/RegionStateCountyTotalINDJK20800INDMH251000INDWB10900USACA5500USAWA10900 ***start of code*** EVALUATEROW("Any countries with count > 25?", NOT(ISEMPTY(FILTER(Info, [County]>25)))) ***end of code*** Return value `FALSE``
ISERROR: Syntax - ***start of code*** ISERROR(<value>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A Boolean value of***start of code*** TRUE ***end of code***if the value is an error; otherwise***start of code*** FALSE ***end of code***. ~ Remarks - For best practices when using ISERROR, seeAppropriate use of error functions. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example calculates the ratio of total Internet sales to total reseller sales. The ISERROR function is used to check for errors, such as division by zero. If there is an error a blank is returned, otherwise the ratio is returned. ***start of code*** = IF( ISERROR(       SUM('ResellerSales_USD'[SalesAmount_USD])       /SUM('InternetSales_USD'[SalesAmount_USD])             )    , BLANK()    , SUM('ResellerSales_USD'[SalesAmount_USD])      /SUM('InternetSales_USD'[SalesAmount_USD])    ) ***end of code***
ISEVEN: Syntax - ***start of code*** ISEVEN(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns***start of code*** TRUE ***end of code***if number is even, or***start of code*** FALSE ***end of code***if number is odd. ~ Remarks - If number is nonnumeric, ISEVEN returns the***start of code*** #VALUE! ***end of code***error value. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
ISFILTERED: Syntax - ***start of code*** ISFILTERED(<TableNameOrColumnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***when***start of code*** ColumnName ***end of code***or a column of***start of code*** TableName ***end of code***is being filtered directly. Otherwise returns***start of code*** FALSE ***end of code***. ~ Remarks - A column or table is said to be filtered directly when a filter is applied to***start of code*** ColumnName ***end of code***or any column of***start of code*** TableName ***end of code***. A column or table is said to be cross-filtered when a filter is applied to***start of code*** ColumnName ***end of code***, any column of***start of code*** TableName ***end of code***, or to any column of a related table. Therefore, theISCROSSFILTEREDfunction also returns***start of code*** TRUE ***end of code***when***start of code*** ColumnName ***end of code***, any column of***start of code*** TableName ***end of code***, or a column of a related table is filtered. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
ISINSCOPE: Syntax - ***start of code*** ISINSCOPE(<columnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***when the specified column is the level in a hierarchy of levels. ~ Remarks -  ~ Example - ***start of code*** DEFINEMEASURE FactInternetSales[% of Parent] =  SWITCH (TRUE(),    ISINSCOPE(DimProduct[Subcategory]),      DIVIDE(        SUM(FactInternetSales[Sales Amount]),        CALCULATE(          SUM(FactInternetSales[Sales Amount]),          ALLSELECTED(DimProduct[Subcategory]))      ),    ISINSCOPE(DimProduct[Category]),      DIVIDE(        SUM(FactInternetSales[Sales Amount]),         CALCULATE(          SUM(FactInternetSales[Sales Amount]),          ALLSELECTED(DimProduct[Category]))      ),    1  ) * 100EVALUATE  SUMMARIZECOLUMNS  (    ROLLUPADDISSUBTOTAL    (      DimProduct[Category], "Category Subtotal",      DimProduct[Subcategory], "Subcategory Subtotal"    ),    TREATAS(      {"Bike Racks", "Bike Stands", "Mountain Bikes", "Road Bikes", "Touring Bikes"},      DimProduct[Subcategory]),    "Sales", SUM(FactInternetSales[Sales Amount]),    "% of Parent", [% of Parent]  )  ORDER BY    [Category Subtotal] DESC, [Category],    [Subcategory Subtotal] DESC, [Subcategory] ***end of code*** Returns, DimProduct[Category]DimProduct[SubCategory][Category Subtotal][Subcategory Subtotal][Sales][% of Parent]***start of code*** TRUE ***end of code******start of code*** TRUE ***end of code***28,397,095.65100.00Accessories***start of code*** FALSE ***end of code******start of code*** TRUE ***end of code***78,951.000.28AccessoriesBike Racks***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code***39,360.0049.85AccessoriesBike Stands***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code***39,591.0050.15Bikes***start of code*** FALSE ***end of code******start of code*** TRUE ***end of code***28,318,144.6599.72BikesMountain Bikes***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code***9,952,759.5635.15BikesRoad Bikes***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code***14,520,584.0451.28BikesTouring Bikes***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code***3,844,801.0513.58
ISLOGICAL: Syntax - ***start of code*** ISLOGICAL(<value>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***if the value is a logical value;***start of code*** FALSE ***end of code***if any value other than***start of code*** TRUE ***end of code***OR***start of code*** FALSE ***end of code***. ~ Remarks -  ~ Example - The following three samples show the behavior of ISLOGICAL. ***start of code*** //RETURNS Is Boolean type or Logical= IF(ISLOGICAL(true), "Is Boolean type or Logical", "Is different type")//RETURNS Is Boolean type or Logical= IF(ISLOGICAL(false), "Is Boolean type or Logical", "Is different type")//RETURNS Is different type= IF(ISLOGICAL(25), "Is Boolean type or Logical", "Is different type") ***end of code***
ISNONTEXT: Syntax - ***start of code*** ISNONTEXT(<value>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***if the value is not text or blank;***start of code*** FALSE ***end of code***if the value is text. ~ Remarks - An empty string is considered text. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following examples show the behavior of the ISNONTEXT function. ***start of code*** //RETURNS Is Non-Text= IF(ISNONTEXT(1), "Is Non-Text", "Is Text")//RETURNS Is Non-Text= IF(ISNONTEXT(BLANK()), "Is Non-Text", "Is Text")//RETURNS Is Text= IF(ISNONTEXT(""), "Is Non-Text", "Is Text") ***end of code***
ISNUMBER: Syntax - ***start of code*** ISNUMBER(<value>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***if the value is numeric; otherwise***start of code*** FALSE ***end of code***. ~ Remarks -  ~ Example - The following three samples show the behavior of ISNUMBER. ***start of code*** //RETURNS Is number= IF(ISNUMBER(0), "Is number", "Is Not number")//RETURNS Is number= IF(ISNUMBER(3.1E-1),"Is number", "Is Not number")//RETURNS Is Not number= IF(ISNUMBER("123"), "Is number", "Is Not number") ***end of code***
ISODD: Syntax - ***start of code*** ISODD(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns***start of code*** TRUE ***end of code***if number is odd, or***start of code*** FALSE ***end of code***if number is even. ~ Remarks - If number is nonnumeric, ISODD returns the***start of code*** #VALUE! ***end of code***error value. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
ISONORAFTER: Syntax - ***start of code*** ISONORAFTER(<scalar_expression>, <scalar_expression>[, sort_order [, <scalar_expression>, <scalar_expression>[, sort_order]]…) ***end of code*** ~ Parameters - No parameters found ~ Return Value - True or false. ~ Remarks -  ~ Example - For the following table named, Info Country/RegionStateCountTotalINDJK20800INDMH251000INDWB10900USACA5500USAWA10900 The following expression ***start of code*** FILTER (    Info,    ISONORAFTER (        Info[Country], "IND", ASC,        Info[State], "MH", ASC )) ***end of code*** Returns Country/RegionStateCountTotalINDMH251000INDWB10900USACA5500USAWA10900
ISSELECTEDMEASURE: Syntax - ***start of code*** ISSELECTEDMEASURE( M1, M2, ... ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A Boolean indicating whether the measure that is currently in context is one of those specified in the list of parameters. ~ Remarks - Can only be referenced in the expression for a calculation item. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following calculation item expression checks if the current measure is one of those specified in the list of parameters. If the measures are renamed, formula fixup will reflect the name changes in the expression. ***start of code*** IF (    ISSELECTEDMEASURE ( [Expense Ratio 1], [Expense Ratio 2] ),    SELECTEDMEASURE (),    DIVIDE ( SELECTEDMEASURE (), COUNTROWS ( DimDate ) )) ***end of code***
ISSUBTOTAL: Syntax - ***start of code*** ISSUBTOTAL(<columnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A True value if the row contains a subtotal value for the column given as argument, otherwise returns False. ~ Remarks - This function can only be used in the expression of aSUMMARIZEfunction. This function must be preceded by the name of the Boolean column. ~ Example - SeeSUMMARIZE.
ISTEXT: Syntax - ***start of code*** ISTEXT(<value>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***if the value is text; otherwise***start of code*** FALSE ***end of code***. ~ Remarks -  ~ Example - The following examples show the behavior of the ISTEXT function. ***start of code*** //RETURNS Is Text= IF(ISTEXT("text"), "Is Text", "Is Non-Text")//RETURNS Is Text= IF(ISTEXT(""), "Is Text", "Is Non-Text")//RETURNS Is Non-Text= IF(ISTEXT(1), "Is Text", "Is Non-Text")//RETURNS Is Non-Text= IF(ISTEXT(BLANK()), "Is Text", "Is Non-Text") ***end of code***
NONVISUAL: Syntax - ***start of code*** NONVISUAL(<expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table of values. ~ Remarks - Marks a value filter inSUMMARIZECOLUMNSas not affecting measure values, but only applying to group-by columns. This function can only be used within aSUMMARIZECOLUMNSexpression. It's used as either a filterTable argument of theSUMMARIZECOLUMNSfunction or a groupLevelFilter argument of theROLLUPADDISSUBTOTALorROLLUPISSUBTOTALfunction. ~ Example - SeeSUMMARIZECOLUMNS.
SELECTEDMEASURE: Syntax - ***start of code*** SELECTEDMEASURE() ***end of code*** ~ Parameters - No parameters found ~ Return Value - A reference to the measure that is currently in context when the calculation item or format string is evaluated. ~ Remarks - Can only be referenced in the expression for a calculation item or format string. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following calculation item expression calculates the year-to-date for whatever the measure is in context. ***start of code*** CALCULATE(SELECTEDMEASURE(), DATESYTD(DimDate[Date])) ***end of code*** The following expression can be used to dynamically adjust the format string of a measure based upon whether a value is the hundreds, thousands, or millions. ***start of code*** SWITCH(TRUE(),SELECTEDMEASURE() < 1000,"$#,##0",            //Values less than 1000 have no text after themSELECTEDMEASURE() < 1000000, "$#,##0,.0 K",   //Values between 1000 and 1000000 are formatted as #.## K"$#,##0,,.0 M"                                //Values greater than 1000000 are formatted as #.## M) ***end of code***
SELECTEDMEASUREFORMATSTRING: Syntax - ***start of code*** SELECTEDMEASUREFORMATSTRING() ***end of code*** ~ Parameters - No parameters found ~ Return Value - A string holding the format string of the measure that is currently in context when the calculation item is evaluated. ~ Remarks - This function can only be referenced in expressions for calculation items in calculation groups. It is designed to be used by theFormat String Expressionproperty of calculation items. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following expression is evaluated by the Format String Expression property for a calculation item. If there is a single currency in filter context, the format string is retrieved from the DimCurrency[FormatString] column; otherwise the format string of the measure in context is used. ***start of code*** SELECTEDVALUE( DimCurrency[FormatString], SELECTEDMEASUREFORMATSTRING() ) ***end of code***
SELECTEDMEASURENAME: Syntax - ***start of code*** SELECTEDMEASURENAME() ***end of code*** ~ Parameters - No parameters found ~ Return Value - A string value holding the name of the measure that is currently in context when the calculation item is evaluated. ~ Remarks - Can only be referenced in the expression for a calculation item. This function is often used for debugging purposes when authoring calculation groups. ~ Example - The following calculation item expression checks if the current measure is Expense Ratio and conditionally applies calculation logic. Since the check is based on a string comparison, it is not subject to formula fixup and will not benefit from object renaming being automatically reflected. For a similar comparison that would benefit from formula fixup, please see the ISSLECTEDMEASURE function instead. ***start of code*** IF (    SELECTEDMEASURENAME = "Expense Ratio",    SELECTEDMEASURE (),    DIVIDE ( SELECTEDMEASURE (), COUNTROWS ( DimDate ) )) ***end of code***
USERCULTURE: Syntax - ***start of code*** USERCULTURE() ***end of code*** ~ Parameters - No parameters found ~ Return Value - Locale as a string. ~ Remarks - In the Power BI service, locale is determined bySettings>Language>Language Settings. The default is determined by the user's browser language setting. When used in calculated table and calculated column expressions, the result may differ depending on whether the table is in DirectQuery or Import mode. When in DirectQuery mode, the result is determined by the language (locale) specified in Language Settings in the Power BI service. The default in Language Settings specifies locale is determined by the user's browser language setting, which means the same calculated table or column can return different results depending on the browser language settings for each user. When in Import mode, the result is statically determined during refresh and will not vary at query time. For managed refreshes, such as scheduled or interactive, locale is not based on the user’s browser language setting but instead uses an invariant locale. The invariant locale, however, can be overridden by using the XMLA endpoint to specify a custom locale. When combined with the Field parameters feature in Power BI, USERCULTURE can be used to reliably translate dynamic visualization titles and captions when used in measure and row-level security (RLS) object expressions within the same model. However, expressions containing USERCULTURE called from outside the model, such as queries and live-connect report measures, should not be relied upon for correctly translated titles and captions. USERCULTURE returns the correct user locale when used in object expressions called from within the model such as measures, row-level security (RLS), and calculation items. However, it may not return the correct user locale when used in expressions from outside the model, such as queries and live-connect report measures. In Live-connect reports, USERCULTURE may not return the correct user locale when called from a report measure expression. ~ Example - For the following expression, ***start of code*** FORMAT(TODAY(), "dddd", USERCULTURE()) ***end of code*** Depending on the language setting for the current user,USERCULTUREreturns the current day, for example LocaleFormatted weekdayde-DEDienstagen-USTuesdayes-ES_tradnlmarteseu-ESastearteait-ITmartedìnl-NLdinsdagpl-PLwtorekro-ROmarțiru-RUвторникuk-UAвівторок
USERNAME: Syntax - ***start of code*** USERNAME() ***end of code*** ~ Parameters - No parameters found ~ Return Value - The username from the credentials given to the system at connection time ~ Remarks -  ~ Example - The following formula verifies if the user login is part of the UsersTable. ***start of code*** = IF(CONTAINS(UsersTable,UsersTable[login], USERNAME()), "Allowed", BLANK()) ***end of code***
USEROBJECTID: Syntax - ***start of code*** USEROBJECTID() ***end of code*** ~ Parameters - No parameters found ~ Return Value - The current user's Object ID from Microsoft Entra ID for Power BI or Azure Analysis Services models or SID for SQL Server Analysis Services models. ~ Remarks -  ~ Example - There is no provided example for this function.
USERPRINCIPALNAME: Syntax - ***start of code*** USERPRINCIPALNAME() ***end of code*** ~ Parameters - No parameters found ~ Return Value - The userprincipalname at connection time. ~ Remarks -  ~ Example - There is no provided example for this function.
AND: Syntax - ***start of code*** AND(<logical1>,<logical2>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns true or false depending on the combination of values that you test. ~ Remarks -  ~ Example - There is no provided example for this function.
BITAND: Syntax - ***start of code*** BITAND(<number>, <number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A bitwise AND of two numbers. ~ Remarks - This function supports both positive and negative numbers. ~ Example - The following DAX query ***start of code*** EVALUATE { BITAND(13, 11) } ***end of code*** Returns 9.
BITLSHIFT: Syntax - ***start of code*** BITLSHIFT(<Number>, <Shift_Amount>)  ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer value. ~ Remarks - Be sure to understand the nature of bitshift operations and overflow/underflow of integers before using DAX bitshift functions. If Shift_Amount is negative, it will shift in the opposite direction. If absolute value of Shift_Amount is larger than 64, there will be no error but will result in overflow/underflow. There’s no limit on Number, but the result may overflow/underflow. ~ Example - There is no provided example for this function.
BITOR: Syntax - ***start of code*** BITOR(<number>, <number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A bitwise OR of two numbers. ~ Remarks - This function supports both positive and negative numbers. ~ Example - The following DAX query ***start of code*** EVALUATE     { BITOR(9, 10) } ***end of code*** Returns 11.
BITRSHIFT: Syntax - ***start of code*** BITRSHIFT(<Number>, <Shift_Amount>)  ***end of code*** ~ Parameters - No parameters found ~ Return Value - An integer value. ~ Remarks - Be sure to understand the nature of bitshift operations and overflow/underflow of integers before using DAX bitshift functions. If Shift_Amount is negative, it will shift in the opposite direction. If absolute value of Shift_Amount is larger than 64, there will be no error but will result in overflow/underflow. There’s no limit on Number, but the result may overflow/underflow. ~ Example - There is no provided example for this function.
BITXOR: Syntax - ***start of code*** BITXOR(<number>, <number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A bitwise XOR of two numbers. ~ Remarks - This function supports both positive and negative numbers. ~ Example - The following DAX query ***start of code*** EVALUATE { BITXOR(9, 10) } ***end of code*** Returns 3.
COALESCE: Syntax - ***start of code*** COALESCE(<expression>, <expression>[, <expression>]…) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value coming from one of the expressions or BLANK if all expressions evaluate to BLANK. ~ Remarks -  ~ Example - There is no provided example for this function.
FALSE: Syntax - ***start of code*** FALSE() ***end of code*** ~ Parameters - No parameters found ~ Return Value - Always***start of code*** FALSE ***end of code***. ~ Remarks -  ~ Example - The formula returns the logical value***start of code*** FALSE ***end of code***when the value in the column, 'InternetSales_USD'[SalesAmount_USD], is less than or equal to 200000. ***start of code*** = IF(SUM('InternetSales_USD'[SalesAmount_USD]) >200000, TRUE(), false()) ***end of code*** The following table shows the results when the example formula is used with 'ProductCategory'[ProductCategoryName] in Row Labels and 'DateTime'[CalendarYear] in Column Labels. Row Labels2005200620072008-Grand TotalAccessories***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** FALSE ***end of code******start of code*** TRUE ***end of code***Bikes***start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** FALSE ***end of code******start of code*** TRUE ***end of code***Clothing***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** TRUE ***end of code***Components***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code***Grand Total***start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** FALSE ***end of code******start of code*** TRUE ***end of code***
IF: Syntax - ***start of code*** IF(<logical_test>, <value_if_true>[, <value_if_false>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Either***start of code*** value_if_true ***end of code***,***start of code*** value_if_false ***end of code***, or***start of code*** BLANK ***end of code***. ~ Remarks - The IF function can return a variant data type if***start of code*** value_if_true ***end of code***and***start of code*** value_if_false ***end of code***are of different data types, but the function attempts to return a single data type if both***start of code*** value_if_true ***end of code***and***start of code*** value_if_false ***end of code***are of numeric data types. In the latter case, the IF function will implicitly convert data types to accommodate both values.For example, the formula***start of code*** IF(<condition>, TRUE(), 0) ***end of code***returns***start of code*** TRUE ***end of code***or 0, but the formula***start of code*** IF(<condition>, 1.0, 0) ***end of code***returns only decimal values even though***start of code*** value_if_false ***end of code***is of the whole number data type. To learn more about implicit data type conversion, seeData types. To execute the branch expressions regardless of the condition expression, useIF.EAGERinstead. ~ Example - There is no provided example for this function.
IF.EAGER: Syntax - ***start of code*** IF.EAGER(<logical_test>, <value_if_true>[, <value_if_false>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Either***start of code*** value_if_true ***end of code***,***start of code*** value_if_false ***end of code***, or***start of code*** BLANK ***end of code***. ~ Remarks - The IF.EAGER function can return a variant data type if value_if_true and value_if_false are of different data types, but the function attempts to return a single data type if both***start of code*** value_if_true ***end of code***and***start of code*** value_if_false ***end of code***are of numeric data types. In the latter case, the IF.EAGER function will implicitly convert data types to accommodate both values.For example, the formula***start of code*** IF.EAGER(<condition>, TRUE(), 0) ***end of code***returns***start of code*** TRUE ***end of code***or 0, but the formula***start of code*** IF.EAGER(<condition>, 1.0, 0) ***end of code***returns only decimal values even though***start of code*** value_if_false ***end of code***is of the whole number data type. To learn more about implicit data type conversion, seeData types. IF.EAGER has the same functional behavior as the IF function, but performance may differ due to differences in execution plans.***start of code*** IF.EAGER(<logical_test>, <value_if_true>, <value_if_false>) ***end of code***has the same execution plan as the following DAX expression***start of code*** VAR _value_if_true = <value_if_true>VAR _value_if_false = <value_if_false>RETURNIF (<logical_test>, _value_if_true, _value_if_false) ***end of code***Note The two branch expressions are evaluated regardless of the condition expression. ~ Example - There is no provided example for this function.
IFERROR: Syntax - ***start of code*** IFERROR(value, value_if_error) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar of the same type as***start of code*** value ***end of code*** ~ Remarks - You can use the IFERROR function to trap and handle errors in an expression. If***start of code*** value ***end of code***or***start of code*** value_if_error ***end of code***is an empty cell, IFERROR treats it as an empty string value (""). The IFERROR function is based on the IF function, and uses the same error messages, but has fewer arguments. The relationship between the IFERROR function and the IF function as follows***start of code*** IFERROR(A,B) = IF(ISERROR(A), B, A) ***end of code***Values that are returned for A and B must be of the same data type; therefore, the column or expression used for***start of code*** value ***end of code***and the value returned for***start of code*** value_if_error ***end of code***must be the same data type. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. For best practices when using IFERROR, seeAppropriate use of error functions. ~ Example - The following example returns 9999 if the expression 25/0 evaluates to an error. If the expression returns a value other than error, that value is passed to the invoking expression. ***start of code*** = IFERROR(25/0,9999) ***end of code***
NOT: Syntax - ***start of code*** NOT(<logical>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - ***start of code*** TRUE ***end of code***OR***start of code*** FALSE ***end of code***. ~ Remarks -  ~ Example - The following example retrieves values from the calculated column that was created to illustrate the IF function. For that example, the calculated column was named using the default name,Calculated Column1, and contains the following formula***start of code*** = IF([Orders]<300,"true","false") ***end of code*** The formula checks the value in the column, [Orders], and returns "true" if the number of orders is under 300. Now create a new calculated column,Calculated Column2, and type the following formula. ***start of code*** = NOT([CalculatedColumn1]) ***end of code*** For each row inCalculated Column1, the values "true" and "false" are interpreted as the logical values***start of code*** TRUE ***end of code***or***start of code*** FALSE ***end of code***, and the NOT function returns the logical opposite of that value.
OR: Syntax - ***start of code*** OR(<logical1>,<logical2>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A Boolean value. The value is***start of code*** TRUE ***end of code***if any of the two arguments is***start of code*** TRUE ***end of code***; the value is FALSE if both the arguments are***start of code*** FALSE ***end of code***. ~ Remarks - The***start of code*** OR ***end of code***function in DAX accepts only two (2) arguments. If you need to perform an OR operation on multiple expressions, you can create a series of calculations or, better, use the OR operator (||) to join all of them in a simpler expression. The function evaluates the arguments until the first***start of code*** TRUE ***end of code***argument, then returns***start of code*** TRUE ***end of code***. ~ Example - The following example shows how to use the OR function to obtain the sales people that belong to the Circle of Excellence. The Circle of Excellence recognizes those who have achieved more than a million dollars in Touring Bikes sales or sales of over two and a half million dollars in 2007. ***start of code*** IF(   OR(   CALCULATE(SUM('ResellerSales_USD'[SalesAmount_USD]), 'ProductSubcategory'[ProductSubcategoryName]="Touring Bikes") > 1000000         ,   CALCULATE(SUM('ResellerSales_USD'[SalesAmount_USD]), 'DateTime'[CalendarYear]=2007) > 2500000         )   , "Circle of Excellence"   , ""   ) ***end of code*** Returns Row Labels2005200620072008-Grand TotalAbbas, Syed EAlberts, Amy EAnsman-Wolfe, Pamela OBlythe, Michael GCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCampbell, David RCarson, JillianCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceIto, Shu KJiang, Stephen YMensa-Annan, Tete AMitchell, Linda CCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellencePak, Jae BCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceReiter, Tsvi MichaelSaraiva, José EdvaldoCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceTsoflias, Lynn NValdez, Rachel BVargas, Garrett RVarkey Chudukatil, Ranjit RCircle of ExcellenceGrand TotalCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of ExcellenceCircle of Excellence
SWITCH: Syntax - ***start of code*** SWITCH(<expression>, <value>, <result>[, <value>, <result>]…[, <else>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - If there’s a match with a***start of code*** value ***end of code***, a scalar value from the corresponding***start of code*** result ***end of code***is returned. If there isn’t a match with a***start of code*** value ***end of code***, a value from***start of code*** else ***end of code***is returned. If none of the***start of code*** values ***end of code***match and***start of code*** else ***end of code***isn’t specified, BLANK is returned. ~ Remarks - The***start of code*** expression ***end of code***to be evaluated can be a constant value or an expression. A common use of this function is to set the first parameter to***start of code*** TRUE ***end of code***. See examples below. All***start of code*** result ***end of code***expressions and the***start of code*** else ***end of code***expression must be of the same data type. The order of conditions matters. As soon as one***start of code*** value ***end of code***matches, the corresponding***start of code*** result ***end of code***is returned, and other subsequent***start of code*** values ***end of code***aren’t evaluated. Make sure the most restrictive***start of code*** values ***end of code***to be evaluated are specified before less restrictive***start of code*** values ***end of code***. See examples below. ~ Example - There is no provided example for this function.
TRUE: Syntax - ***start of code*** TRUE() ***end of code*** ~ Parameters - No parameters found ~ Return Value - Always***start of code*** TRUE ***end of code***. ~ Remarks -  ~ Example - The formula returns the logical value***start of code*** TRUE ***end of code***when the value in the column, 'InternetSales_USD'[SalesAmount_USD], is greater than 200000. ***start of code*** = IF(SUM('InternetSales_USD'[SalesAmount_USD]) >200000, TRUE(), false()) ***end of code*** The following table shows the results when the example formula is used in a report with 'ProductCategory'[ProductCategoryName] in Row Labels and 'DateTime'[CalendarYear] in Column Labels. Row Labels2005200620072008-Grand TotalAccessories***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** FALSE ***end of code******start of code*** TRUE ***end of code***Bikes***start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** FALSE ***end of code******start of code*** TRUE ***end of code***Clothing***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** TRUE ***end of code***Components***start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code******start of code*** FALSE ***end of code***Grand Total***start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** TRUE ***end of code******start of code*** FALSE ***end of code******start of code*** TRUE ***end of code***
ABS: Syntax - ***start of code*** ABS(<number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks -  ~ Example - The following example returns the absolute value of the difference between the list price and the dealer price, which you might use in a new calculated column,DealerMarkup. ***start of code*** = ABS([DealerPrice]-[ListPrice]) ***end of code***
ACOS: Syntax - ***start of code*** ACOS(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the arccosine, or inverse cosine, of a number. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = ACOS(-0.5) ***end of code***Arccosine of -0.5 in radians, 2*pi/3.2.094395102***start of code*** = ACOS(-0.5)*180/PI() ***end of code***Arccosine of -0.5 in degrees.120
ACOSH: Syntax - ***start of code*** ACOSH(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the inverse hyperbolic cosine of a number. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = ACOSH(1) ***end of code***Inverse hyperbolic cosine of 1.0***start of code*** = ACOSH(10) ***end of code***Inverse hyperbolic cosine of 10.2.993228
ACOT: Syntax - ***start of code*** ACOT(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A single decimal value. ~ Remarks -  ~ Example - There is no provided example for this function.
ACOTH: Syntax - ***start of code*** ACOTH(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A single decimal value. ~ Remarks -  ~ Example - There is no provided example for this function.
ASIN: Syntax - ***start of code*** ASIN(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the arcsine, or inverse sine, of a number. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = ASIN(-0.5) ***end of code***Arcsine of -0.5 in radians, -pi/6-0.523598776***start of code*** = ASIN(-0.5)*180/PI() ***end of code***Arcsine of -0.5 in degrees-30***start of code*** = DEGREES(ASIN(-0.5)) ***end of code***Arcsine of -0.5 in degrees-30
ASINH: Syntax - ***start of code*** ASINH(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the inverse hyperbolic sine of a number. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = ASINH(-2.5) ***end of code***Inverse hyperbolic sine of -2.5-1.647231146***start of code*** = ASINH(10) ***end of code***Inverse hyperbolic sine of 102.99822295
ATAN: Syntax - ***start of code*** ATAN(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the inverse hyperbolic tangent of a number. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = ATAN(1) ***end of code***Arctangent of 1 in radians, pi/40.785398163***start of code*** = ATAN(1)*180/PI() ***end of code***Arctangent of 1 in degrees45
ATANH: Syntax - ***start of code*** ATANH(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the inverse hyperbolic tangent of a number. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = ATANH(0.76159416) ***end of code***Inverse hyperbolic tangent of 0.761594161.00000001***start of code*** = ATANH(-0.1) ***end of code***-0.100335348
CEILING: Syntax - ***start of code*** CEILING(<number>, <significance>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number rounded as specified. ~ Remarks - There are two CEILING functions in DAX, with the following differencesThe CEILING function emulates the behavior of the CEILING function in Excel.The ISO.CEILING function follows the ISO-defined behavior for determining the ceiling value. The CEILING function emulates the behavior of the CEILING function in Excel. The ISO.CEILING function follows the ISO-defined behavior for determining the ceiling value. The two functions return the same value for positive numbers, but different values for negative numbers.  When using a positive multiple of significance, both CEILING and ISO.CEILING round negative numbers upward (toward positive infinity).  When using a negative multiple of significance, CEILING rounds negative numbers downward (toward negative infinity), while ISO.CEILING rounds negative numbers upward (toward positive infinity). The return type is usually of the same type of the significant argument, with the following exceptionsIf the number argument type is currency, the return type is currency.If the significance argument type is Boolean, the return type is integer.If the significance argument type is non-numeric, the return type is real. If the number argument type is currency, the return type is currency. If the significance argument type is Boolean, the return type is integer. If the significance argument type is non-numeric, the return type is real. ~ Example - There is no provided example for this function.
CONVERT: Syntax - ***start of code*** CONVERT(<Expression>, <Datatype>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the value of***start of code*** Expression ***end of code***, translated to***start of code*** Datatype ***end of code***. ~ Remarks - The function returns an error when a value cannot be converted to the specified data type. DAX calculated columns must be of a single data type. Since MEDIAN and MEDIANX functions over an integer column return mixed data types, either integer or double, the following calculated column expression will return an error as a result***start of code*** MedianNumberCarsOwned = MEDIAN(DimCustomer[NumberCarsOwned]) ***end of code***. To avoid mixed data types, change the expression to always return the double data type, for example***start of code*** MedianNumberCarsOwned = MEDIANX(DimCustomer, CONVERT([NumberCarsOwned], DOUBLE)) ***end of code***. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DAX query ***start of code*** EVALUATE { CONVERT(DATE(1900, 1, 1), INTEGER) } ***end of code*** Returns [Value]2
COS: Syntax - ***start of code*** COS(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the cosine of the given angle. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = COS(1.047) ***end of code***Cosine of 1.047 radians0.5001711***start of code*** = COS(60*PI()/180) ***end of code***Cosine of 60 degrees0.5***start of code*** = COS(RADIANS(60)) ***end of code***Cosine of 60 degrees0.5
COSH: Syntax - ***start of code*** COSH(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The hyperbolic cosine of a number. ~ Remarks - The formula for the hyperbolic cosine is$$\text{COSH}(z) = \frac{e^{z} + e^{-z}}{2}$$ This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DAX expressionDescriptionResult***start of code*** = COSH(4) ***end of code***Hyperbolic cosine of 427.308233***start of code*** = COSH(EXP(1)) ***end of code***Hyperbolic cosine of the base of the natural logarithm.7.6101251
COT: Syntax - ***start of code*** COT (<number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The cotangent of the given angle. ~ Remarks - The absolute value of number must be less than 2^27 and cannot be 0. If number is outside its constraints, an error is returned. If number is a non-numeric value, an error is returned. ~ Example - The following DAX query, ***start of code*** EVALUATE { COT(30) } ***end of code*** Returns [Value]-0.156119952161659
COTH: Syntax - ***start of code*** COTH (<number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The hyperbolic cotangent of the given angle. ~ Remarks - The hyperbolic cotangent is an analog of the ordinary (circular) cotangent. The absolute value of number must be less than $2^{27}$ and cannot be 0. If number is outside its constraints, an error is returned If number is a non-numeric value, an error is returned. The following equation is used$$\text{COTH}(N) = \frac{1}{\text{TANH}(N)} = \frac{\text{COSH(N)}}{\text{SINH(N)}} = \frac{e^{N} + e^{-N}}{e^{N} - e^{-N}}$$ This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query, ***start of code*** EVALUATE { COTH(2) } ***end of code*** Returns [Value]1.03731472072755
CURRENCY: Syntax - ***start of code*** CURRENCY(<value>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The value of the expression evaluated and returned as a currency type value. ~ Remarks - The CURRENCY function rounds up the 5th significant decimal, in value, to return the 4th decimal digit. Rounding up occurs if the 5th significant decimal is equal or larger than 5. For example, if value is 3.6666666666666 then converting to currency returns \$3.6667. However, if value is 3.0123456789 then converting to currency returns \$3.0123. If the data type of the expression is TrueFalse then CURRENCY(***start of code*** TrueFalse ***end of code***) will return \$1.0000 for True values and \$0.0000 for False values. If the data type of the expression is Text then CURRENCY(***start of code*** Text ***end of code***) will try to convert text to a number. If conversion succeeds the number will be converted to currency, otherwise an error is returned. If the data type of the expression is DateTime then CURRENCY(***start of code*** DateTime ***end of code***) will convert the datetime value to a number and that number to currency. DateTime values have an integer part that represents the number of days between the given date and 1900-03-01 and a fraction that represents the fraction of a day (where 12 hours or noon is 0.5 day). If the value of the expression is not a proper DateTime value an error is returned. ~ Example - Convert number 1234.56 to currency data type. ***start of code*** = CURRENCY(1234.56) ***end of code*** Returns value 1234.56000.
DEGREES: Syntax - ***start of code*** DEGREES(angle) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = DEGREES(PI()) ***end of code***Degrees of pi radians180
DIVIDE: Syntax - ***start of code*** DIVIDE(<numerator>, <denominator> [,<alternateresult>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Alternate result on divide by 0 must be a constant. ~ Remarks - Alternate result on divide by 0 must be a constant. For best practices when using DIVIDE, seeDIVIDE function vs. divide operator (/) in DAX. ~ Example - The following example returns 2.5. ***start of code*** = DIVIDE(5,2) ***end of code***
EVEN: Syntax - ***start of code*** EVEN(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns number rounded up to the nearest even integer. ~ Remarks - If***start of code*** number ***end of code***is nonnumeric, EVEN returns the***start of code*** #VALUE! ***end of code***error value. Regardless of the sign of number, a value is rounded up when adjusted away from zero. If number is an even integer, no rounding occurs. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - FormulaDescriptionResult***start of code*** = EVEN(1.5) ***end of code***Rounds 1.5 to the nearest even integer2***start of code*** = EVEN(3) ***end of code***Rounds 3 to the nearest even integer4***start of code*** = EVEN(2) ***end of code***Rounds 2 to the nearest even integer2***start of code*** = EVEN(-1) ***end of code***Rounds -1 to the nearest even integer-2
EXP: Syntax - ***start of code*** EXP(<number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - EXP is the inverse of LN, which is the natural logarithm of the given number. To calculate powers of bases other than e, use the exponentiation operator (^). For more information, seeDAX Operator Reference. ~ Example - The following formula calculates e raised to the power of the number contained in the column,***start of code*** [Power] ***end of code***. ***start of code*** = EXP([Power]) ***end of code***
FACT: Syntax - ***start of code*** FACT(<number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - If the number is not an integer, it is truncated and an error is returned. If the result is too large, an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following formula returns the factorial for the series of integers in the column,***start of code*** [Values] ***end of code***. ***start of code*** = FACT([Values]) ***end of code*** The following table shows the expected results ValuesResults0111223642451201707.257415615308E+306
FLOOR: Syntax - ***start of code*** FLOOR(<number>, <significance>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - If either argument is nonnumeric, FLOOR returns***start of code*** #VALUE! ***end of code***error value. If number and significance have different signs, FLOOR returns the***start of code*** #NUM! ***end of code***error value. Regardless of the sign of the number, a value is rounded down when adjusted away from zero. If the number is an exact multiple of significance, no rounding occurs. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following formula takes the values in the [Total Product Cost] column from the table, InternetSales, and rounds down to the nearest multiple of .1. ***start of code*** = FLOOR(InternetSales[Total Product Cost],.1) ***end of code*** The following table shows the expected results for some sample values ValuesExpected Result10.842310.88.037382.97332.9
GCD: Syntax - ***start of code*** GCD(number1, [number2], ...) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The greatest common divisor of two or more integers. ~ Remarks - If any argument is nonnumeric, GCD returns the***start of code*** #VALUE! ***end of code***error value. If any argument is less than zero, GCD returns the***start of code*** #NUM! ***end of code***error value. One divides any value evenly. A prime number has only itself and one as even divisors. If a parameter to GCD is >=2^53, GCD returns the***start of code*** #NUM! ***end of code***error value. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - DAX expressionDescriptionResult***start of code*** = GCD(5, 2) ***end of code***Greatest common divisor of 5 and 2.1***start of code*** = GCD(24, 36) ***end of code***Greatest common divisor of 24 and 36.12***start of code*** = GCD(7, 1) ***end of code***Greatest common divisor of 7 and 1.1
INT: Syntax - ***start of code*** INT(<number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. ~ Remarks -  ~ Example - The following expression rounds the value to 1. If you use the ROUND function, the result would be 2. ***start of code*** = INT(1.5) ***end of code***
ISO.CEILING: Syntax - ***start of code*** ISO.CEILING(<number>[, <significance>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number, of the same type as the***start of code*** number ***end of code***argument, rounded as specified. ~ Remarks - The CEILING function emulates the behavior of the CEILING function in Excel. The ISO.CEILING function follows the ISO-defined behavior for determining the ceiling value. ~ Example - There is no provided example for this function.
LCM: Syntax - ***start of code*** LCM(number1, [number2], ...) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the least common multiple of integers. ~ Remarks - If any argument is nonnumeric, LCM returns the***start of code*** #VALUE! ***end of code***error value. If any argument is less than zero, LCM returns the***start of code*** #NUM! ***end of code***error value. If LCM(a,b) >=2^53, LCM returns the***start of code*** #NUM! ***end of code***error value. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - FormulaDescriptionResult***start of code*** = LCM(5, 2) ***end of code***Least common multiple of 5 and 2.10***start of code*** = LCM(24, 36) ***end of code***Least common multiple of 24 and 36.72
LN: Syntax - ***start of code*** LN(<number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks -  ~ Example - The following example returns the natural logarithm of the number in the column,***start of code*** [Values] ***end of code***. ***start of code*** = LN([Values]) ***end of code***
LOG: Syntax - ***start of code*** LOG(<number>,<base>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks -  ~ Example - The following formulas return the same result, 2. ***start of code*** = LOG(100,10)= LOG(100)= LOG10(100) ***end of code***
LOG10: Syntax - ***start of code*** LOG10(<number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks -  ~ Example - The following formulas return the same result, 2 ***start of code*** = LOG(100,10)= LOG(100)= LOG10(100) ***end of code***
MOD: Syntax - ***start of code*** MOD(<number>, <divisor>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. ~ Remarks - If the divisor is 0 (zero), MOD returns an error. You cannot divide by 0. The MOD function can be expressed in terms of the INT function MOD(n, d) = n - d*INT(n/d) ~ Example - There is no provided example for this function.
MROUND: Syntax - ***start of code*** MROUND(<number>, <multiple>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks -  ~ Example - There is no provided example for this function.
ODD: Syntax - ***start of code*** ODD(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns number rounded up to the nearest odd integer. ~ Remarks - If***start of code*** number ***end of code***is nonnumeric, ODD returns the***start of code*** #VALUE! ***end of code***error value. Regardless of the sign of number, a value is rounded up when adjusted away from zero. If number is an odd integer, no rounding occurs. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - FormulaDescriptionResult***start of code*** = ODD(1.5) ***end of code***Rounds 1.5 up to the nearest odd integer.3***start of code*** = ODD(3) ***end of code***Rounds 3 up to the nearest odd integer.3***start of code*** = ODD(2) ***end of code***Rounds 2 up to the nearest odd integer.3***start of code*** = ODD(-1) ***end of code***Rounds -1 up to the nearest odd integer.-1***start of code*** = ODD(-2) ***end of code***Rounds -2 up (away from 0) to the nearest odd integer.-3
PI: Syntax - ***start of code*** PI() ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number with the value of Pi, 3.14159265358979, accurate to 15 digits. ~ Remarks -  ~ Example - The following formula calculates the area of a circle given the radius in the column,***start of code*** [Radius] ***end of code***. ***start of code*** = PI()*([Radius]*2) ***end of code***
POWER: Syntax - ***start of code*** POWER(<number>, <power>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks -  ~ Example - The following example returns 25. ***start of code*** = POWER(5,2) ***end of code***
QUOTIENT: Syntax - ***start of code*** QUOTIENT(<numerator>, <denominator>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. ~ Remarks - If either argument is non-numeric, QUOTIENT returns the***start of code*** #VALUE! ***end of code***error value. You can use a column reference instead of a literal value for either argument. However, if the column that you reference contains a 0 (zero), an error is returned for the entire column of values. ~ Example - The following formulas return the same result, 2. ***start of code*** = QUOTIENT(5,2) ***end of code*** ***start of code*** = QUOTIENT(10/2,2) ***end of code***
RADIANS: Syntax - ***start of code*** RADIANS(angle) ***end of code*** ~ Parameters - No parameters found ~ Return Value - There is no specified return value for this function. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = RADIANS(270) ***end of code***270 degrees as radians (4.712389 or 3π/2 radians)4.712389
RAND: Syntax - ***start of code*** RAND() ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - Recalculation depends on various factors, including whether the model is set to***start of code*** Manual ***end of code***or***start of code*** Automatic ***end of code***recalculation mode, and whether data has been refreshed. RAND and other volatile functions that do not have fixed values are not always recalculated. For example, execution of a query or filtering will usually not cause such functions to be re-evaluated. However, the results for these functions will be recalculated when the entire column is recalculated. These situations include refresh from an external data source or manual editing of data that causes re-evaluation of formulas that contain these functions. RAND is always recalculated if the function is used in the definition of a measure. RAND function cannot return a result of zero, to prevent errors such as division by zero. ~ Example - There is no provided example for this function.
RANDBETWEEN: Syntax - ***start of code*** RANDBETWEEN(<bottom>,<top>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. ~ Remarks -  ~ Example - The following formula returns a random number between 1 and 10. ***start of code*** = RANDBETWEEN(1,10) ***end of code***
ROUND: Syntax - ***start of code*** ROUND(<number>, <num_digits>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - If***start of code*** num_digits ***end of code***is greater than 0 (zero), then number is rounded to the specified number of decimal places. If***start of code*** num_digits ***end of code***is 0, the number is rounded to the nearest integer. If***start of code*** num_digits ***end of code***is less than 0, the number is rounded to the left of the decimal point. Related functionsTo always round up (away from zero), use the ROUNDUP function.To always round down (toward zero), use the ROUNDDOWN function.To round a number to a specific multiple (for example, to round to the nearest multiple of 0.5), use the MROUND function.Use the functions TRUNC and INT to obtain the integer portion of the number. To always round up (away from zero), use the ROUNDUP function. To always round down (toward zero), use the ROUNDDOWN function. To round a number to a specific multiple (for example, to round to the nearest multiple of 0.5), use the MROUND function. Use the functions TRUNC and INT to obtain the integer portion of the number. ~ Example - There is no provided example for this function.
ROUNDDOWN: Syntax - ***start of code*** ROUNDDOWN(<number>, <num_digits>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - If***start of code*** num_digits ***end of code***is greater than 0 (zero), then the value in***start of code*** number ***end of code***is rounded down to the specified number of decimal places. If***start of code*** num_digits ***end of code***is 0, then the value in***start of code*** number ***end of code***is rounded down to the nearest integer. If***start of code*** num_digits ***end of code***is less than 0, then the value in***start of code*** number ***end of code***is rounded down to the left of the decimal point. ROUNDDOWN behaves like ROUND, except that it always rounds a number down. The INT function also rounds down, but with INT the result is always an integer, whereas with ROUNDDOWN you can control the precision of the result. ~ Example - There is no provided example for this function.
ROUNDUP: Syntax - ***start of code*** ROUNDUP(<number>, <num_digits>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - If***start of code*** num_digits ***end of code***is greater than 0 (zero), then the number is rounded up to the specified number of decimal places. If***start of code*** num_digits ***end of code***is 0, then number is rounded up to the nearest integer. If***start of code*** num_digits ***end of code***is less than 0, then number is rounded up to the left of the decimal point. ROUNDUP behaves like ROUND, except that it always rounds a number up. ~ Example - The following formula rounds Pi to four decimal places. The expected result is 3.1416. ***start of code*** = ROUNDUP(PI(),4) ***end of code***
SIGN: Syntax - ***start of code*** SIGN(<number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. The possible Return values are 1, 0, and -1. ~ Remarks -  ~ Example - The following formula returns the sign of the result of the expression that calculates sale price minus cost. ***start of code*** = SIGN( ([Sale Price] - [Cost]) ) ***end of code***
SIN: Syntax - ***start of code*** SIN(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the sine of the given angle. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = SIN(PI()) ***end of code***Sine of pi radians (0, approximately).0.0***start of code*** = SIN(PI()/2) ***end of code***Sine of pi/2 radians.1.0***start of code*** = SIN(30*PI()/180) ***end of code***Sine of 30 degrees.0.5***start of code*** = SIN(RADIANS(30)) ***end of code***Sine of 30 degrees.0.5
SINH: Syntax - ***start of code*** SINH(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the hyperbolic sine of a number. ~ Remarks - The formula for the hyperbolic sine is$$\text{SINH}(z) = \frac{e^{z} - e^{-z}}{2}$$ This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - Probability of obtaining a result of less than 1.03 seconds. ***start of code*** = 2.868*SINH(0.0342\*1.03) ***end of code*** Returns, 0.1010491
SQRT: Syntax - ***start of code*** SQRT(<number>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks -  ~ Example - The following formula, ***start of code*** = SQRT(25) ***end of code***
SQRTPI: Syntax - ***start of code*** SQRTPI(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the square root of (number * pi). ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = SQRTPI(1) ***end of code***Square root of pi.1.772454***start of code*** = SQRTPI(2) ***end of code***Square root of 2 * pi.2.506628
TAN: Syntax - ***start of code*** TAN(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the tangent of the given angle. ~ Remarks -  ~ Example - FormulaDescriptionResult***start of code*** = TAN(0.785) ***end of code***Tangent of 0.785 radians (0.99920)0.99920***start of code*** = TAN(45*PI()/180) ***end of code***Tangent of 45 degrees (1)1***start of code*** = TAN(RADIANS(45)) ***end of code***Tangent of 45 degrees (1)1
TANH: Syntax - ***start of code*** TANH(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the hyperbolic tangent of a number. ~ Remarks - The formula for the hyperbolic tangent is$$\text{TANH}(z) = \frac{\text{SINH}(z)}{\text{COSH}(z)}$$ This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - FormulaDescriptionResult***start of code*** = TANH(-2) ***end of code***Hyperbolic tangent of -2 (-0.96403)-0.964028***start of code*** = TANH(0) ***end of code***Hyperbolic tangent of 0 (0)0***start of code*** = TANH(0.5) ***end of code***Hyperbolic tangent of 0.5 (0.462117)0.462117
TRUNC: Syntax - ***start of code*** TRUNC(<number>,<num_digits>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number. ~ Remarks -  ~ Example - There is no provided example for this function.
BLANK: Syntax - ***start of code*** BLANK() ***end of code*** ~ Parameters - No parameters found ~ Return Value - A blank. ~ Remarks - Blanks are not equivalent to nulls. DAX uses blanks for both database nulls and for blank cells in Excel. Some DAX functions treat blank cells somewhat differently from Microsoft Excel. Blanks and empty strings ("") are not always equivalent, but some operations may treat them as such. ~ Example - The following example illustrates how you can work with blanks in formulas. The formula calculates the ratio of sales between the Resellers and the Internet channels. However, before attempting to calculate the ratio the denominator should be checked for zero values. If the denominator is zero then a blank value should be returned; otherwise, the ratio is calculated. ***start of code*** = IF( SUM(InternetSales_USD[SalesAmount_USD])= 0   , BLANK()   , SUM(ResellerSales_USD[SalesAmount_USD])/SUM(InternetSales_USD[SalesAmount_USD])   ) ***end of code*** The table shows the expected results when this formula is used to create a table visualization. Row LabelsAccessoriesBikesClothingGrand Total20052.652.8920063.334.0320071.042.926.633.5120080.411.532.001.71Grand Total0.832.515.452.94 In the original data source, the column evaluated by the BLANK function might have included text, empty strings, or nulls. If the original data source was a SQL Server database, nulls and empty strings are different kinds of data. However, for this operation an implicit type cast is performed and DAX treats them as the same.
ERROR: Syntax - ***start of code*** ERROR(<text>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - None ~ Remarks - The ERROR function can be placed in a DAX expression anywhere a scalar value is expected. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
EVALUATEANDLOG: Syntax - ***start of code*** EVALUATEANDLOG(<Value>, [Label], [MaxRows]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The value of the first argument. ~ Remarks - Trace events can be captured by usingSQL Server Profilerand the open-sourceDAX Debug Outputtool. This function can be used with almost any sub-expression in a DAX expression, and the entire expression will still be valid. When the first argument is evaluated multiple times in a single query, the function generates a single DAX Evaluation Log event that contains both the input values and the corresponding output values. When the label parameter is specified, its value is returned in both the json output and the Label column of the DAX Evaluation Log event. If the first argument is a table expression, only the top MaxRows rows are shown in the DAX Evaluation Log event. In some cases, this function is not executed due to optimizations. If the DAX Evaluation Log event is greater than one million characters, it's truncated to preserve correct json structure. ~ Example - There is no provided example for this function.
TOCSV: Syntax - ***start of code*** TOCSV(<Table>, [MaxRows], [Delimiter], [IncludeHeaders]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A string with CSV representation of the table. ~ Remarks -  ~ Example - The following DAX query ***start of code*** EVALUATE{TOCSV(DimSalesTerritory)} ***end of code*** Returns ***start of code*** 'DimSalesTerritory'[SalesTerritoryKey],'DimSalesTerritory'[SalesTerritoryAlternateKey],'DimSalesTerritory'[SalesTerritoryRegion],'DimSalesTerritory'[SalesTerritoryCountry],'DimSalesTerritory'[SalesTerritoryGroup]1,1,Northwest,United States,North America2,2,Northeast,United States,North America3,3,Central,United States,North America4,4,Southwest,United States,North America5,5,Southeast,United States,North America6,6,Canada,Canada,North America7,7,France,France,Europe8,8,Germany,Germany,Europe9,9,Australia,Australia,Pacific10,10,United Kingdom,United Kingdom,Europe ***end of code***
TOJSON: Syntax - ***start of code*** TOJSON(<Table>, [MaxRows]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A string with JSON representation of the table. The representation contains column names as "header", count-of-rows as "rowCount", and values as "data". ~ Remarks -  ~ Example - The following DAX query ***start of code*** EVALUATE{TOJSON(DimSalesTerritory)} ***end of code*** Returns ***start of code*** {"header" ["'DimSalesTerritory'[SalesTerritoryKey]", "'DimSalesTerritory'[SalesTerritoryAlternateKey]", "'DimSalesTerritory'[SalesTerritoryRegion]", "'DimSalesTerritory'[SalesTerritoryCountry]", "'DimSalesTerritory'[SalesTerritoryGroup]"],<br>"rowCount" 11,"data" [[1, 1, "Northwest", "United States", "North America"],[2, 2, "Northeast", "United States", "North America"],[3, 3, "Central", "United States", "North America"],[4, 4, "Southwest", "United States", "North America"],[5, 5, "Southeast", "United States", "North America"],[6, 6, "Canada", "Canada", "North America"],[7, 7, "France", "France", "Europe"],[8, 8, "Germany", "Germany", "Europe"],[9, 9, "Australia", "Australia", "Pacific"],[10, 10, "United Kingdom", "United Kingdom", "Europe"]]} ***end of code***
PATH: Syntax - ***start of code*** PATH(<ID_columnName>, <parent_columnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A delimited text string containing the identifiers of all the parents to the current identifier. ~ Remarks - This function is used in tables that have some kind of internal hierarchy, to return the items that are related to the current row value. For example, in an Employees table that contains employees, the managers of employees, and the managers of the managers, you can return the path that connects an employee to his or her manager. The path is not constrained to a single level of parent-child relationships; it can return related rows that are several levels up from the specified starting row.The delimiter used to separate the ascendants is the vertical bar,***start of code*** | ***end of code***.The values in***start of code*** ID_columnName ***end of code***and***start of code*** parent_columnName ***end of code***must have the same data type, text or integer.Values in***start of code*** parent_columnName ***end of code***must be present in***start of code*** ID_columnName ***end of code***. That is, you cannot look up a parent if there is no value at the child level.If***start of code*** parent_columnName ***end of code***is***start of code*** BLANK ***end of code***then***start of code*** PATH() ***end of code***returns***start of code*** ID_columnName ***end of code***value.  In other words, if you look for the manager of an employee but the***start of code*** parent_columnName ***end of code***column has no data, the PATH function returns just the employee ID.If***start of code*** ID_columnName ***end of code***has duplicates and***start of code*** parent_columnName ***end of code***is the same for those duplicates then***start of code*** PATH() ***end of code***returns the common***start of code*** parent_columnName ***end of code***value; however, if***start of code*** parent_columnName ***end of code***value is different for those duplicates then***start of code*** PATH() ***end of code***returns an error. In other words, if you have two listings for the same employee ID and they have the same manager ID, the PATH function returns the ID for that manager. However, if there are two identical employee IDs that have different manager IDs, the PATH function returns an error.If***start of code*** ID_columnName ***end of code***is***start of code*** BLANK ***end of code***then***start of code*** PATH() ***end of code***returns***start of code*** BLANK ***end of code***.If***start of code*** ID_columnName ***end of code***contains a vertical bar***start of code*** | ***end of code***then***start of code*** PATH() ***end of code***returns an error. The delimiter used to separate the ascendants is the vertical bar,***start of code*** | ***end of code***. The values in***start of code*** ID_columnName ***end of code***and***start of code*** parent_columnName ***end of code***must have the same data type, text or integer. Values in***start of code*** parent_columnName ***end of code***must be present in***start of code*** ID_columnName ***end of code***. That is, you cannot look up a parent if there is no value at the child level. If***start of code*** parent_columnName ***end of code***is***start of code*** BLANK ***end of code***then***start of code*** PATH() ***end of code***returns***start of code*** ID_columnName ***end of code***value.  In other words, if you look for the manager of an employee but the***start of code*** parent_columnName ***end of code***column has no data, the PATH function returns just the employee ID. If***start of code*** ID_columnName ***end of code***has duplicates and***start of code*** parent_columnName ***end of code***is the same for those duplicates then***start of code*** PATH() ***end of code***returns the common***start of code*** parent_columnName ***end of code***value; however, if***start of code*** parent_columnName ***end of code***value is different for those duplicates then***start of code*** PATH() ***end of code***returns an error. In other words, if you have two listings for the same employee ID and they have the same manager ID, the PATH function returns the ID for that manager. However, if there are two identical employee IDs that have different manager IDs, the PATH function returns an error. If***start of code*** ID_columnName ***end of code***is***start of code*** BLANK ***end of code***then***start of code*** PATH() ***end of code***returns***start of code*** BLANK ***end of code***. If***start of code*** ID_columnName ***end of code***contains a vertical bar***start of code*** | ***end of code***then***start of code*** PATH() ***end of code***returns an error. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example creates a calculated column that lists all the managers for each employee. ***start of code*** = PATH(Employee[EmployeeKey], Employee[ParentEmployeeKey]) ***end of code***
PATHCONTAINS: Syntax - ***start of code*** PATHCONTAINS(<path>, <item>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A value of***start of code*** TRUE ***end of code***if***start of code*** item ***end of code***exists in***start of code*** path ***end of code***; otherwise***start of code*** FALSE ***end of code***. ~ Remarks - If***start of code*** item ***end of code***is an integer number it is converted to text and then the function is evaluated. If conversion fails then the function returns an error. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example creates a calculated column that takes a manager ID and checks a set of employees. If the manager ID is among the list of managers returned by the PATH function, the PATHCONTAINS function returns true; otherwise it returns false. ***start of code*** = PATHCONTAINS(PATH(Employee[EmployeeKey], Employee[ParentEmployeeKey]), "23") ***end of code***
PATHITEM: Syntax - ***start of code*** PATHITEM(<path>, <position>[, <type>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The identifier returned by the PATH function at the specified position in the list of identifiers. Items returned by the PATH function are ordered by most distant to current. ~ Remarks - This function can be used to return a specific level from a hierarchy returned by a PATH function. For example, you could return just the skip-level managers for all employees. If you specify a number for***start of code*** position ***end of code***that is less than one (1) or greater than the number of elements in***start of code*** path ***end of code***, the PATHITEM function returns BLANK If***start of code*** type ***end of code***is not a valid enumeration element an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example returns the third tier manager of the current employee; it takes the employee and manager IDs as the input to a PATH function that returns a string with the hierarchy of parents to current employee. From that string PATHITEM returns the third entry as an integer. ***start of code*** = PATHITEM(PATH(Employee[EmployeeKey], Employee[ParentEmployeeKey]), 3, 1) ***end of code***
PATHITEMREVERSE: Syntax - ***start of code*** PATHITEMREVERSE(<path>, <position>[, <type>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The n-position ascendant in the given path, counting from current to the oldest. ~ Remarks - This function can be used to get an individual item from a hierarchy resulting from a PATH function. This function reverses the standard order of the hierarchy, so that closest items are listed first, For example, if the PATh function returns a list of managers above an employee in a hierarchy, the PATHITEMREVERSE function returns the employee's immediate manager in position 2 because position 1 contains the employee's id. If the number specified for***start of code*** position ***end of code***is less than one (1) or greater than the number of elements in***start of code*** path ***end of code***, the PATHITEM function  returns BLANK. If***start of code*** type ***end of code***is not a valid enumeration element an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example takes an employee ID column as the input to a PATH function, and reverses the list of grandparent elements that are returned. The position specified is 3 and the return type is 1; therefore, the PATHITEMREVERSE function returns an integer representing the manager two levels up from the employee. ***start of code*** = PATHITEMREVERSE(PATH(Employee[EmployeeKey], Employee[ParentEmployeeKey]), 3, 1) ***end of code***
PATHLENGTH: Syntax - ***start of code*** PATHLENGTH(<path>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The number of items that are parents to the specified item in a given PATH result, including the specified item. ~ Remarks -  ~ Example - The following example takes an employee ID as input to a PATH function and returns a list of the managers above that employee in the hierarchy, The PATHLENGTH function takes that result and counts the different levels of employees and managers, including the employee you started with. ***start of code*** = PATHLENGTH(PATH(Employee[EmployeeKey], Employee[ParentEmployeeKey])) ***end of code***
CROSSFILTER: Syntax - ***start of code*** CROSSFILTER(<columnName1>, <columnName2>, <direction>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The function returns no value; the function only sets the cross-filtering direction for the indicated relationship, for the duration of the query. ~ Remarks - In the case of a 11 relationship, there is no difference between the one and both direction. CROSSFILTER can only be used in functions that take a filter as an argument, for example CALCULATE, CALCULATETABLE, CLOSINGBALANCEMONTH, CLOSINGBALANCEQUARTER, CLOSINGBALANCEYEAR, OPENINGBALANCEMONTH, OPENINGBALANCEQUARTER, OPENINGBALANCEYEAR, TOTALMTD, TOTALQTD and TOTALYTD functions. CROSSFILTER uses existing relationships in the model, identifying relationships by their ending point columns. In CROSSFILTER, the cross-filtering setting of a relationship is not important; that is, whether the relationship is set to filter one, or both directions in the model does not affect the usage of the function. CROSSFILTER will override any existing cross-filtering setting. An error is returned if any of the columns named as an argument is not part of a relationship or the arguments belong to different relationships. If CALCULATE expressions are nested, and more than one CALCULATE expression contains a CROSSFILTER function, then the innermost CROSSFILTER is the one that prevails in case of a conflict or ambiguity. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - In the following model diagram, both DimProduct and DimDate have a single direction relationship with FactInternetSales.  By default, we cannot get the Count of Products sold by year  There are  two ways to get the count of products by year Turn on bi-directional cross-filtering on the relationship. This will change how filters work for all data between these two tables.Use the CROSSFILTER function to change how the relationships work for just this measure. When using DAX, we can use the CROSSFILTER function to change how the cross-filter direction behaves between two columns defined by a relationship. In this case, the DAX expression looks like this ***start of code*** BiDi= CALCULATE([Distinct Count of ProductKey], CROSSFILTER(FactInternetSales[ProductKey], DimProduct[ProductKey] , Both)) ***end of code*** By using the CROSSFILTER function in our measure expression, we get the expected results
RELATED: Syntax - ***start of code*** RELATED(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A single value that is related to the current row. ~ Remarks - The RELATED function requires that a relationship exists between the current table and the table with related information. You specify the column that contains the data that you want, and the function follows an existing many-to-one relationship to fetch the value from the specified column in the related table. If a relationship does not exist, you must create a relationship. When the RELATED function performs a lookup, it examines all values in the specified table regardless of any filters that may have been applied. The RELATED function needs a row context; therefore, it can only be used in calculated column expression, where the current row context is unambiguous, or as a nested function in an expression that uses a table scanning function. A table scanning function, such as SUMX, gets the value of the current row value and then scans another table for instances of that value. The RELATED function cannot be used to fetch a column across alimited relationship. ~ Example - In the following example, the measure Non USA Internet Sales is created to produce a sales report that excludes sales in the United States. In order to create the measure, the InternetSales_USD table must be filtered to exclude all sales that belong to the United States in the SalesTerritory table. The United States, as a country, appears 5 times in the SalesTerritory table; once for each of the following regions Northwest, Northeast, Central, Southwest, and Southeast. The first approach to filter the Internet Sales, in order to create the measure, could be to add a filter expression like the following ***start of code*** FILTER('InternetSales_USD', 'InternetSales_USD'[SalesTerritoryKey]<>1 && 'InternetSales_USD'[SalesTerritoryKey]<>2 && 'InternetSales_USD'[SalesTerritoryKey]<>3 && 'InternetSales_USD'[SalesTerritoryKey]<>4 && 'InternetSales_USD'[SalesTerritoryKey]<>5) ***end of code*** However, this approach is counterintuitive, prone to typing errors, and might not work if any of the existing regions is split in the future. A better approach would be to use the existing relationship between InternetSales_USD and SalesTerritory and explicitly state that the country must be different from the United States. To do so, create a filter expression like the following ***start of code*** FILTER( 'InternetSales_USD', RELATED('SalesTerritory'[SalesTerritoryCountry])<>"United States") ***end of code*** This expression uses the RELATED function to lookup the country value in the SalesTerritory table, starting with the value of the key column, SalesTerritoryKey, in the InternetSales_USD table. The result of the lookup is used by the filter function to determine if the InternetSales_USD row is filtered or not. NoteIf the example does not work, you might need to create a relationship between the tables. ***start of code*** = SUMX(FILTER( 'InternetSales_USD'            ,  RELATED('SalesTerritory'[SalesTerritoryCountry])               <>"United States"             )     ,'InternetSales_USD'[SalesAmount_USD]) ***end of code*** The following table shows only totals for each region, to prove that the filter expression in the measure, Non USA Internet Sales, works as intended. Row LabelsInternet SalesNon USA Internet SalesAustralia$4,999,021.84$4,999,021.84Canada$1,343,109.10$1,343,109.10France$2,490,944.57$2,490,944.57Germany$2,775,195.60$2,775,195.60United Kingdom$5,057,076.55$5,057,076.55United States$9,389,479.79Grand Total$26,054,827.45$16,665,347.67 The following shows what that you might get if you used this measure in a report table visual Row LabelsAccessoriesBikesClothingGrand Total2005$1,526,481.95$1,526,481.952006$3,554,744.04$3,554,744.042007$156,480.18$5,640,106.05$70,142.77$5,866,729.002008$228,159.45$5,386,558.19$102,675.04$5,717,392.68Grand Total$384,639.63$16,107,890.23$172,817.81$16,665,347.67
RELATEDTABLE: Syntax - ***start of code*** RELATEDTABLE(<tableName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table of values. ~ Remarks - The RELATEDTABLE function changes the context in which the data is filtered, and evaluates the expression in the new context that you specify. This function is a shortcut for CALCULATETABLE function with no logical expression. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example uses the RELATEDTABLE function to create a calculated column with the Internet Sales in the Product Category table ***start of code*** = SUMX( RELATEDTABLE('InternetSales_USD')     , [SalesAmount_USD]) ***end of code*** The following table shows the results Product Category KeyProduct Category AlternateKeyProduct Category NameInternet Sales11Bikes$28,318,144.6522Components33Clothing$339,772.6144Accessories$700,759.96
USERELATIONSHIP: Syntax - ***start of code*** USERELATIONSHIP(<columnName1>,<columnName2>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The function returns no value; the function only enables the indicated relationship for the duration of the calculation. ~ Remarks - USERELATIONSHIP can only be used in functions that take a filter as an argument, for example CALCULATE, CALCULATETABLE, CLOSINGBALANCEMONTH, CLOSINGBALANCEQUARTER, CLOSINGBALANCEYEAR, OPENINGBALANCEMONTH, OPENINGBALANCEQUARTER, OPENINGBALANCEYEAR, TOTALMTD, TOTALQTD and TOTALYTD functions. USERELATIONSHIP cannot be used when row level security is defined for the table in which the measure is included. For example,***start of code*** CALCULATE(SUM([SalesAmount]), USERELATIONSHIP(FactInternetSales[CustomerKey], DimCustomer[CustomerKey])) ***end of code***will return an error if row level security is defined for DimCustomer. USERELATIONSHIP uses existing relationships in the model, identifying  relationships by their ending point columns. In USERELATIONSHIP, the status of a relationship is not important; that is, whether the relationship is active or not does not affect the usage of the function. Even if the relationship is inactive, it will be used and overrides any other active relationships that might be present in the model but not mentioned in the function arguments. An error is returned if any of the columns named as an argument is not part of a relationship or the arguments belong to different relationships. If multiple relationships are needed to join table A to table B in a calculation, each relationship must be indicated in a different USERELATIONSHIP function. If CALCULATE expressions are nested, and more than one CALCULATE expression contains a USERELATIONSHIP function, then the innermost USERELATIONSHIP is the one that prevails in case of a conflict or ambiguity. Up to 10 USERELATIONSHIP functions can be nested; however, your expression might have a deeper level of nesting, ie. the following sample expression is nested 3 levels deep but only 2 for USERELATIONSHIP***start of code*** =CALCULATE(CALCULATE( CALCULATE( <anyExpression>, USERELATIONSHIP( t1[colA], t2[colB])), t99[colZ]=999), USERELATIONSHIP( t1[colA], t2[colA])) ***end of code***. For 1-to-1 relationships, USERELATIONSHIP will only activate the relationship in one direction. In particular, filters will only be able to flow fromcolumnName2's table tocolumnName1's table. If bi-directional cross-filtering is desired, two USERELATIONSHIPs with opposite directionality can be used in the same calculation. For example,***start of code*** CALCULATE(..., USERELATIONSHIP(T1[K], T2[K]), USERELATIONSHIP(T2[K], T1[K])) ***end of code***. ~ Example - The following sample shows how to override the default, active, relationship between InternetSales and DateTime tables. The default relationship exists between the OrderDate column, in the InternetSales table, and the Date column, in the DateTime table. To calculate the sum of internet sales and allow slicing by ShippingDate instead of the traditional OrderDate, create measure, [InternetSales by ShippingDate] using the following expression ***start of code*** = CALCULATE(SUM(InternetSales[SalesAmount]), USERELATIONSHIP(InternetSales[ShippingDate], DateTime[Date])) ***end of code*** Relationships between InternetSales[ShipmentDate] and DateTime[Date] must exist and should not be the active relationship; also, the relationship between InternetSales[OrderDate] and DateTime[Date] should exist and should be the active relationship.
BETA.DIST: Syntax - ***start of code*** BETA.DIST(x,alpha,beta,cumulative,[A],[B]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the beta distribution. ~ Remarks - If any argument is nonnumeric, BETA.DIST returns the***start of code*** #VALUE! ***end of code***error value. If any argument is not an integer, it is rounded. If***start of code*** alpha ≤ 0 ***end of code***or beta ≤ 0, BETA.DIST returns the***start of code*** #NUM! ***end of code***error value. If x < A, x > B, or A = B, BETA.DIST returns the***start of code*** #NUM! ***end of code***error value. If you omit values for A and B, BETA.DIST uses the standard cumulative beta distribution, so that A = 0 and B = 1. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
BETA.INV: Syntax - ***start of code*** BETA.INV(probability,alpha,beta,[A],[B]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the inverse of the beta cumulative probability density function (BETA.DIST). ~ Remarks - If any argument is nonnumeric,***start of code*** BETA.INV ***end of code***returns the***start of code*** #VALUE! ***end of code***error value. If any argument is not an integer, it is rounded. If***start of code*** alpha ***end of code***≤ 0 or***start of code*** beta ***end of code***≤ 0,***start of code*** BETA.INV ***end of code***returns the***start of code*** #NUM! ***end of code***error value. If probability ≤ 0 or probability > 1,***start of code*** BETA.INV ***end of code***returns the #NUM! error value. If you omit values for A and B,***start of code*** BETA.INV ***end of code***uses the standard cumulative beta distribution, so that A = 0 and B = 1. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
CHISQ.DIST: Syntax - ***start of code*** CHISQ.DIST(<x>, <deg_freedom>, <cumulative>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The chi-squared distribution. ~ Remarks - If***start of code*** x ***end of code***or***start of code*** deg_freedom ***end of code***is nonnumeric, an error is returned. If***start of code*** deg_freedom ***end of code***is not an integer, it is rounded. If***start of code*** x ***end of code***< 0, an error is returned. If***start of code*** deg_freedom ***end of code***< 1 or***start of code*** deg_freedom ***end of code***> 10^10, an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query, ***start of code*** EVALUATE { CHISQ.DIST(2, 2, TRUE) } ***end of code*** Returns [Value]0.632120558828558
CHISQ.DIST.RT: Syntax - ***start of code*** CHISQ.DIST.RT(<x>, <deg_freedom>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The right-tailed probability of the chi-squared distribution. ~ Remarks - If***start of code*** x ***end of code***or***start of code*** deg_freedom ***end of code***is nonnumeric, an error is returned. If***start of code*** deg_freedom ***end of code***is not an integer, it is rounded. If***start of code*** x ***end of code***< 0, an error is returned. If***start of code*** deg_freedom ***end of code***< 1 or***start of code*** deg_freedom ***end of code***> 10^10, an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query, ***start of code*** EVALUATE { CHISQ.DIST.RT(2, 5) } ***end of code*** Returns [Value]0.84914503608461
CHISQ.INV: Syntax - ***start of code*** CHISQ.INV(probability,deg_freedom) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the inverse of the left-tailed probability of the chi-squared distribution. ~ Remarks - If argument is nonnumeric, CHISQ.INV returns the***start of code*** #VALUE! ***end of code***error value. If probability < 0 or probability > 1, CHISQ.INV returns the***start of code*** #NUM! ***end of code***error value. If***start of code*** deg_freedom ***end of code***is not an integer, it is rounded. If***start of code*** deg_freedom ***end of code***< 0 or***start of code*** deg_freedom ***end of code***> 10^10, CHISQ.INV returns the***start of code*** #NUM! ***end of code***error value. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - FormulaDescriptionResult***start of code*** = CHISQ.INV(0.93,1) ***end of code***Inverse of the left-tailed probability of the chi-squared distribution for 0.93, using 1 degree of freedom.5.318520074***start of code*** = CHISQ.INV(0.6,2) ***end of code***Inverse of the left-tailed probability of the chi-squared distribution for 0.6, using 2 degrees of freedom.1.832581464
CHISQ.INV.RT: Syntax - ***start of code*** CHISQ.INV.RT(probability,deg_freedom) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the inverse of the right-tailed probability of the chi-squared distribution. ~ Remarks - If either argument is nonnumeric, CHISQ.INV.RT returns the***start of code*** #VALUE! ***end of code***error value. If***start of code*** probability ***end of code***< 0 or***start of code*** probability ***end of code***> 1, CHISQ.INV.RT returns the***start of code*** #NUM! ***end of code***error value. If***start of code*** deg_freedom ***end of code***is not an integer, it is rounded. If***start of code*** deg_freedom ***end of code***< 1, CHISQ.INV.RT returns the***start of code*** #NUM! ***end of code***error value. Given a value for probability, CHISQ.INV.RT seeks that value x such that CHISQ.DIST.RT(x, deg_freedom) = probability. Thus, precision of CHISQ.INV.RT depends on precision of CHISQ.DIST.RT. CHISQ.INV.RT uses an iterative search technique. If the search has not converged after 64 iterations, the function returns the #N/A error value. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
COMBIN: Syntax - ***start of code*** COMBIN(number, number_chosen) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the number of combinations for a given number of items. ~ Remarks - Numeric arguments are truncated to integers. If either argument is nonnumeric, COMBIN returns the***start of code*** #VALUE! ***end of code***error value. If number < 0, number_chosen < 0, or number < number_chosen, COMBIN returns the***start of code*** #NUM! ***end of code***error value. A combination is any set or subset of items, regardless of their internal order. Combinations are distinct from permutations, for which the internal order is significant. The number of combinations is as follows, where number = $n$ and number_chosen = $k$$${n \choose k} = \frac{P_{k,n}}{k!} = \frac{n!}{k!(n-k)!}$$Where$$P_{k,n} = \frac{n!}{(n-k)!}$$ This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - FormulaDescriptionResult***start of code*** = COMBIN(8,2) ***end of code***Possible two-person teams that can be formed from 8 candidates.28
COMBINA: Syntax - ***start of code*** COMBINA(number, number_chosen) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the number of combinations (with repetitions) for a given number of items. ~ Remarks - If the value of either argument is outside of its constraints, COMBINA returns the***start of code*** #NUM! ***end of code***error value. If either argument is a non-numeric value, COMBINA returns the***start of code*** #VALUE! ***end of code***error value. The following equation is used, where $N$ is Number and $M$ is Number_chosen$${N+M-1 \choose N-1}$$ This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - FormulaDescriptionResult***start of code*** = COMBINA(4,3) ***end of code***Returns the number of combinations (with repetitions) for 4 and 3.20***start of code*** = COMBINA(10,3) ***end of code***Returns the number of combinations (with repetitions) for 10 and 3.220
CONFIDENCE.NORM: Syntax - ***start of code*** CONFIDENCE.NORM(alpha,standard_dev,size) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A range of values ~ Remarks - If any argument is nonnumeric, CONFIDENCE.NORM returns the***start of code*** #VALUE! ***end of code***error value. If***start of code*** alpha ≤ 0 ***end of code***or***start of code*** alpha ≥ 1 ***end of code***, CONFIDENCE.NORM returns the***start of code*** #NUM! ***end of code***error value. If***start of code*** standard_dev ≤ 0 ***end of code***, CONFIDENCE.NORM returns the***start of code*** #NUM! ***end of code***error value. If***start of code*** size ***end of code***is not an integer, it is rounded. If***start of code*** size < 1 ***end of code***, CONFIDENCE.NORM returns the***start of code*** #NUM! ***end of code***error value. If we assume alpha equals 0.05, we need to calculate the area under the standard normal curve that equals (1 - alpha), or 95 percent. This value is ± 1.96. The confidence interval is therefore$$\overline{x} \pm 1.96 \bigg( \frac{\sigma}{\sqrt{n}} \bigg) $$ This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
CONFIDENCE.T: Syntax - ***start of code*** CONFIDENCE.T(alpha,standard_dev,size) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the confidence interval for a population mean, using a Student's t distribution. ~ Remarks - If any argument is nonnumeric, CONFIDENCE.T returns the***start of code*** #VALUE! ***end of code***error value. If***start of code*** alpha ≤ 0 ***end of code***or***start of code*** alpha ≥ 1 ***end of code***, CONFIDENCE.T returns the***start of code*** #NUM! ***end of code***error value. If***start of code*** standard_dev ≤ 0 ***end of code***, CONFIDENCE.T returns the***start of code*** #NUM! ***end of code***error value. If size is not an integer, it is rounded. If size equals 1, CONFIDENCE.T returns #DIV/0! error value. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - FormulaDescriptionResult***start of code*** = CONFIDENCE.T(0.05,1,50) ***end of code***Confidence interval for the mean of a population based on a sample size of 50, with a 5% significance level and a standard deviation of 1. This is based on a Student's t-distribution.0.284196855
EXPON.DIST: Syntax - ***start of code*** EXPON.DIST(x,lambda,cumulative) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the exponential distribution. ~ Remarks - If***start of code*** x ***end of code***or***start of code*** lambda ***end of code***is nonnumeric, EXPON.DIST returns the***start of code*** #VALUE! ***end of code***error value. If***start of code*** x ***end of code***or***start of code*** lambda ***end of code***is not an integer, it is rounded. If***start of code*** x ***end of code***< 0, EXPON.DIST returns the***start of code*** #NUM! ***end of code***error value. If***start of code*** lambda ***end of code***≤ 0, EXPON.DIST returns the***start of code*** #NUM! ***end of code***error value. The equation for the probability density function is$$f(x; \lambda) = \lambda e^{-\lambda x}$$ The equation for the cumulative distribution function is$$F(x; \lambda) = 1 - e^{-\lambda x}$$ This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
GEOMEAN: Syntax - ***start of code*** GEOMEAN(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - Only the numbers in the column are counted. Blanks, logical values, and text are ignored. GEOMEAN( Table[Column] ) is equivalent to GEOMEANX( Table, Table[Column] ) This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following computes the geometric mean of the Return column in the Investment table ***start of code*** = GEOMEAN( Investment[Return] ) ***end of code***
GEOMEANX: Syntax - ***start of code*** GEOMEANX(<table>, <expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - The GEOMEANX function takes as its first argument a table, or an expression that returns a table. The second argument is a column that contains the numbers for which you want to compute the geometric mean, or an expression that evaluates to a column. Only the numbers in the column are counted. Blanks, logical values, and text are ignored. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following computes the geometric mean of the ReturnPct column in the Investments table ***start of code*** = GEOMEANX( Investments, Investments[ReturnPct] + 1 ) ***end of code***
LINEST: Syntax - ***start of code*** LINEST ( <columnY>, <columnX>[, …][, <const>] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A single-row table describing the line, plus additional statistics. These are the available columns ~ Remarks - Slope1andIntercept the coefficients of the calculated linear model; StandardErrorSlope1andStandardErrorIntercept the standard error values for the coefficients above; CoefficientOfDetermination,StandardError,FStatistic,DegreesOfFreedom,RegressionSumOfSquaresandResidualSumOfSquares regression statistics about the model. ~ Example - There is no provided example for this function.
LINESTX: Syntax - ***start of code*** LINESTX ( <table>, <expressionY>, <expressionX>[, …][, <const>] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A single-row table describing the line, plus additional statistics. These are the available columns ~ Remarks -  ~ Example - There is no provided example for this function.
MEDIAN: Syntax - ***start of code*** MEDIAN(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - Only the numbers in the column are counted. Blanks are ignored. Logical values, dates, and text are not supported. MEDIAN( Table[Column] ) is equivalent to MEDIANX( Table, Table[Column] ). This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following computes the median of a column named Age in a table named Customers ***start of code*** = MEDIAN( Customers[Age] ) ***end of code***
MEDIANX: Syntax - ***start of code*** MEDIANX(<table>, <expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A decimal number. ~ Remarks - The MEDIANX function takes as its first argument a table, or an expression that returns a table. The second argument is a column that contains the numbers for which you want to compute the median, or an expression that evaluates to a column. Only the numbers in the column are counted. Logical values and text are ignored. MEDIANX does not ignore blanks; however, MEDIAN does ignore blanks This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following computes the median age of customers who live in the USA. ***start of code*** = MEDIANX( FILTER(Customers, RELATED( Geography[Country]="USA" ) ), Customers[Age] ) ***end of code***
NORM.DIST: Syntax - ***start of code*** NORM.DIST(X, Mean, Standard_dev, Cumulative) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The normal distribution for the specified mean and standard deviation. ~ Remarks -  ~ Example - ***start of code*** EVALUATE { NORM.DIST(42, 40, 1.5, TRUE) } ***end of code*** Returns [Value]0.908788780274132
NORM.INV: Syntax - ***start of code*** NORM.INV(Probability, Mean, Standard_dev) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the inverse of the normal cumulative distribution for the specified mean and standard deviation. ~ Remarks -  ~ Example - ***start of code*** EVALUATE { NORM.INV(0.908789, 40, 1.5) } ***end of code*** Returns [Value]42.00000200956628780274132
NORM.S.DIST: Syntax - ***start of code*** NORM.S.DIST(Z, Cumulative) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The standard normal distribution (has a mean of zero and a standard deviation of one. ~ Remarks -  ~ Example - ***start of code*** EVALUATE { NORM.S.DIST(1.333333, TRUE) } ***end of code*** Returns [Value]0.908788725604095
NORM.S.INV: Syntax - ***start of code*** NORM.S.INV(Probability) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The inverse of the standard normal cumulative distribution. The distribution has a mean of zero and a standard deviation of one. ~ Remarks -  ~ Example - ***start of code*** EVALUATE { NORM.S.INV(0.908789) } ***end of code*** Returns [Value]1.33333467304411
PERCENTILE.EXC: Syntax - ***start of code*** PERCENTILE.EXC(<column>, <k>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The k-th percentile of values in a range, where k is in the range 0..1, exclusive. ~ Remarks - If column is empty, BLANK() is returned. If k is zero or blank, percentile rank of 1/(n+1) returns the smallest value. If zero, it is out of range and an error is returned. If k is nonnumeric or outside the range 0 to 1, an error is returned. If k is not a multiple of 1/(n + 1), PERCENTILE.EXC will interpolate to determine the value at the k-th percentile. PERCENTILE.EXC will interpolate when the value for the specified percentile is between two values in the array. If it cannot interpolate for the k percentile specified, an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
PERCENTILE.INC: Syntax - ***start of code*** PERCENTILE.INC(<column>, <k>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The k-th percentile of values in a range, where k is in the range 0..1, inclusive. ~ Remarks - If column is empty, BLANK() is returned. If k is zero or blank, percentile rank of 1/(n+1) returns the smallest value. If zero, it is out of range and an error is returned. If k is nonnumeric or outside the range 0 to 1, an error is returned. If k is not a multiple of 1/(n + 1), PERCENTILE.INC will interpolate to determine the value at the k-th percentile. PERCENTILE.INC will interpolate when the value for the specified percentile is between two values in the array. If it cannot interpolate for the k percentile specified, an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
PERCENTILEX.EXC: Syntax - ***start of code*** PERCENTILEX.EXC(<table>, <expression>, k) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The percentile number of an expression evaluated for each row in a table. ~ Remarks - If k is zero or blank, percentile rank of 1/(n+1) returns the smallest value. If zero, it is out of range and an error is returned. If k is nonnumeric or outside the range 0 to 1, an error is returned. If k is not a multiple of 1/(n + 1), PERCENTILEX.EXC will interpolate to determine the value at the k-th percentile. PERCENTILEX.EXC will interpolate when the value for the specified percentile is between two values in the array. If it cannot interpolate for the k percentile specified, an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
PERCENTILEX.INC: Syntax - ***start of code*** PERCENTILEX.INC(<table>, <expression>;, k) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The percentile number of an expression evaluated for each row in a table. ~ Remarks - If k is zero or blank, percentile rank of 1/(n - 1) returns the smallest value. If zero, it is out of range and an error is returned. If k is nonnumeric or outside the range 0 to 1, an error is returned. If k is not a multiple of 1/(n - 1), PERCENTILEX.EXC will interpolate to determine the value at the k-th percentile. PERCENTILEX.INC will interpolate when the value for the specified percentile is between two values in the array. If it cannot interpolate for the k percentile specified, an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
PERMUT: Syntax - ***start of code*** PERMUT(number, number_chosen) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the number of permutations for a given number of objects that can be selected from number objects ~ Remarks - Both arguments are truncated to integers. If number or number_chosen is nonnumeric, PERMUT returns the***start of code*** #VALUE! ***end of code***error value. If number ≤ 0 or if number_chosen < 0, PERMUT returns the***start of code*** #NUM! ***end of code***error value. If number < number_chosen, PERMUT returns the***start of code*** #NUM! ***end of code***error value. The equation for the number of permutations is$$P_{k,n} = \frac{n!}{(n-k)!}$$ This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - In the following formula, permutations possible for a group of 3 objects where 2 are chosen ***start of code*** = PERMUT(3,2) ***end of code*** Result, 6
POISSON.DIST: Syntax - ***start of code*** POISSON.DIST(x,mean,cumulative) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Returns the Poisson distribution. ~ Remarks - If x is not an integer, it is rounded. If x or mean is nonnumeric, POISSON.DIST returns the***start of code*** #VALUE! ***end of code***error value. If x < 0, POISSON.DIST returns the***start of code*** #NUM! ***end of code***error value. If mean < 0, POISSON.DIST returns the***start of code*** #NUM! ***end of code***error value. POISSON.DIST is calculated as follows.For cumulative =***start of code*** FALSE ***end of code***$$\text{POISSON} = \frac{e^{-\lambda} \lambda^{x}}{x!}$$For cumulative =***start of code*** TRUE ***end of code***$$\text{CUMPOISSON} = \sum^{x}_{k=0} \frac{e^{-\lambda} \lambda^{x}}{k!}$$ For cumulative =***start of code*** FALSE ***end of code***$$\text{POISSON} = \frac{e^{-\lambda} \lambda^{x}}{x!}$$ For cumulative =***start of code*** TRUE ***end of code***$$\text{CUMPOISSON} = \sum^{x}_{k=0} \frac{e^{-\lambda} \lambda^{x}}{k!}$$ This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
RANK.EQ: Syntax - ***start of code*** RANK.EQ(<value>, <columnName>[, <order>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number indicating the rank of***start of code*** value ***end of code***among the numbers in***start of code*** columnName ***end of code***. ~ Remarks - ***start of code*** columnName ***end of code***cannot refer to any column created using these functions ADDCOLUMNS, ROW or SUMMARIZE.I If***start of code*** value ***end of code***is not in***start of code*** columnName ***end of code***or value is a blank, thenRANK.EQreturns a blank value. Duplicate values of***start of code*** value ***end of code***receive the same rank value; the next rank value assigned will be the rank value plus the number of duplicate values. For example if five (5) values are tied with a rank of 11 then the next value will receive a rank of 16 (11 + 5). This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
RANKX: Syntax - ***start of code*** RANKX(<table>, <expression>[, <value>[, <order>[, <ties>]]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The rank number of***start of code*** value ***end of code***among all possible values of***start of code*** expression ***end of code***evaluated for all rows of***start of code*** table ***end of code***numbers. ~ Remarks - If***start of code*** expression ***end of code***or***start of code*** value ***end of code***evaluates to BLANK it is treated as a 0 (zero) for all expressions that result in a number, or as an empty text for all text expressions. If***start of code*** value ***end of code***is not among all possible values of***start of code*** expression ***end of code***then RANKX temporarily adds***start of code*** value ***end of code***to the values from***start of code*** expression ***end of code***and re-evaluates RANKX to determine the proper rank of***start of code*** value ***end of code***. Optional arguments might be skipped by placing an empty comma (,) in the argument list, such as***start of code*** RANKX(Inventory, [InventoryCost],,,"Dense") ***end of code***. Equality related comparisons (***start of code*** = ***end of code***,***start of code*** < ***end of code***,***start of code*** > ***end of code***,***start of code*** >= ***end of code***and***start of code*** <= ***end of code***) between values with theDecimal Numberdata type can potentially return unexpected results when using RANKX function. Incorrect results can occur because values withDecimal Numberdata type are stored as IEEE Standard 754 floating point numbers and have inherent limitations in their precision. To avoid unexpected results, change the data type toFixed Decimal Numberor do a forced rounding usingROUND. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following calculated column in the Products table calculates the sales ranking for each product in the Internet channel. ***start of code*** = RANKX(ALL(Products), SUMX(RELATEDTABLE(InternetSales), [SalesAmount])) ***end of code***
SAMPLE: Syntax - ***start of code*** SAMPLE(<n_value>, <table>, <orderBy_expression>, [<order>[, <orderBy_expression>, [<order>]]…]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table consisting of a sample of N rows of***start of code*** table ***end of code***or an empty table if***start of code*** n_value ***end of code***is 0 (zero) or less. If OrderBy arguments are provided, the sample will be stable and deterministic, returning the first row, the last row, and evenly distributed rows between them. If no ordering is specified, the sample will be random, not stable, and not deterministic. ~ Remarks - If***start of code*** n_value ***end of code***is 0 (zero) or less then SAMPLE returns an empty table. In order to avoid duplicate values in the sample, the table provided as the second argument should be grouped by the column used for sorting. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
STDEV.P: Syntax - ***start of code*** STDEV.P(<ColumnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number representing the standard deviation of the entire population. ~ Remarks - STDEV.P assumes that the column refers to the entire population. If your data represents a sample of the population, then compute the standard deviation by using STDEV.S. STDEV.P uses the following formula√[∑(x - x̃)2/n]where x̃ is the average value of x for the entire population and n is the population size. Blank rows are filtered out from***start of code*** columnName ***end of code***and not considered in the calculations. An error is returned if***start of code*** columnName ***end of code***contains less than 2 non-blank rows This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows the formula for a measure that calculates the standard deviation of the column, SalesAmount_USD, when the table InternetSales_USD is the entire population. ***start of code*** = STDEV.P(InternetSales_USD[SalesAmount_USD]) ***end of code***
STDEV.S: Syntax - ***start of code*** STDEV.S(<ColumnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number that represents the standard deviation of a sample population. ~ Remarks - STDEV.S assumes that the column refers to a sample of the population. If your data represents the entire population, then compute the standard deviation by using STDEV.P. STDEV.S uses the following formula√[∑(x - x̃)2/(n-1)]where x̃ is the average value of x for the sample population and n is the population size. Blank rows are filtered out from***start of code*** columnName ***end of code***and not considered in the calculations. An error is returned if***start of code*** columnName ***end of code***contains less than 2 non-blank rows. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows the formula for a measure that calculates the standard deviation of the column, SalesAmount_USD, when the table InternetSales_USD is the sample population. ***start of code*** = STDEV.S(InternetSales_USD[SalesAmount_USD]) ***end of code***
STDEVX.P: Syntax - ***start of code*** STDEVX.P(<table>, <expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number that represents the standard deviation of the entire population. ~ Remarks - STDEVX.P evaluates***start of code*** expression ***end of code***for each row of***start of code*** table ***end of code***and returns the standard deviation of expression assuming that table refers to the entire population. If the data in***start of code*** table ***end of code***represents a sample of the population, you should compute the standard deviation by using STDEVX.S instead. STDEVX.P uses the following formula√[∑(x - x̃)2/n]where x̃ is the average value of x for the entire population and n is the population size. Blank rows are filtered out from***start of code*** columnName ***end of code***and not considered in the calculations. An error is returned if***start of code*** columnName ***end of code***contains less than 2 non-blank rows This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows the formula for a calculated column that calculates the standard deviation of the unit price per product, when the formula is used in theProducttable. ***start of code*** = STDEVX.P(RELATEDTABLE(InternetSales_USD), InternetSales_USD[UnitPrice_USD] – (InternetSales_USD[DiscountAmount_USD]/InternetSales_USD[OrderQuantity])) ***end of code***
STDEVX.S: Syntax - ***start of code*** STDEVX.S(<table>, <expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number with the standard deviation of a sample population. ~ Remarks - STDEVX.S evaluates***start of code*** expression ***end of code***for each row of***start of code*** table ***end of code***and returns the standard deviation of***start of code*** expression ***end of code***assuming that***start of code*** table ***end of code***refers to a sample of the population. If***start of code*** table ***end of code***represents the entire population, then compute the standard deviation by using STDEVX.P. STDEVX.S uses the following formula√[∑(x - x̃)2/(n-1)]where x̃ is the average value of x for the entire population and n is the population size. Blank rows are filtered out from***start of code*** columnName ***end of code***and not considered in the calculations. An error is returned if***start of code*** columnName ***end of code***contains less than 2 non-blank rows. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows the formula for a calculated column that estimates the standard deviation of the unit price per product for a sample population, when the formula is used in the Product table. ***start of code*** = STDEVX.S(RELATEDTABLE(InternetSales_USD), InternetSales_USD[UnitPrice_USD] – (InternetSales_USD[DiscountAmount_USD]/InternetSales_USD[OrderQuantity])) ***end of code***
T.DIST: Syntax - ***start of code*** T.DIST(X,Deg_freedom,Cumulative) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The Student's left-tailed t-distribution. ~ Remarks -  ~ Example - ***start of code*** EVALUATE { T.DIST(60, 1, TRUE) } ***end of code*** Returns, [Value]0.994695326367377
T.DIST.2T: Syntax - ***start of code*** T.DIST.2T(X,Deg_freedom) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The two-tailed Student's t-distribution. ~ Remarks -  ~ Example - ***start of code*** EVALUATE { T.DIST.2T(1.959999998, 60) } ***end of code*** Returns [Value]0.054644929975921
T.DIST.RT: Syntax - ***start of code*** T.DIST.RT(X,Deg_freedom) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The right-tailed Student's t-distribution. ~ Remarks -  ~ Example - ***start of code*** EVALUATE { T.DIST.RT(1.959999998, 60) } ***end of code*** Returns [Value]0.0273224649879605
T.INV: Syntax - ***start of code*** T.INV(Probability,Deg_freedom) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The left-tailed inverse of the Student's t-distribution. ~ Remarks -  ~ Example - ***start of code*** EVALUATE { T.INV(0.75, 2) } ***end of code*** Returns [Value]0.816496580927726
T.INV.2t: Syntax - ***start of code*** T.INV.2T(Probability,Deg_freedom) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The two-tailed inverse of the Student's t-distribution. ~ Remarks -  ~ Example - ***start of code*** EVALUATE { T.INV.2T(0.546449, 60) } ***end of code*** Returns [Value]0.606533075825759
VAR.P: Syntax - ***start of code*** VAR.P(<columnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number with the variance of the entire population. ~ Remarks - VAR.P assumes that the column refers the entire population. If your data represents a sample of the population, then compute the variance by using VAR.S. VAR.P uses the following formula∑(x - x̃)2/nwhere x̃ is the average value of x for the entire populationand n is the population size Blank rows are filtered out from***start of code*** columnName ***end of code***and not considered in the calculations. An error is returned if***start of code*** columnName ***end of code***contains less than 2 non-blank rows This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows the formula for a measure that estimates the variance of the SalesAmount_USD column from the InternetSales_USD table, for the entire population. ***start of code*** = VAR.P(InternetSales_USD[SalesAmount_USD]) ***end of code***
VAR.S: Syntax - ***start of code*** VAR.S(<columnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number with the variance of a sample population. ~ Remarks - VAR.S assumes that the column refers to a sample of the population. If your data represents the entire population, then compute the variance by using VAR.P. VAR.S uses the following formula∑(x - x̃)2/(n-1)where x̃ is the average value of x for the sample populationand n is the population size Blank rows are filtered out from***start of code*** columnName ***end of code***and not considered in the calculations. An error is returned if***start of code*** columnName ***end of code***contains less than 2 non-blank rows. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows the formula for a measure that calculates the variance of the SalesAmount_USD column from the InternetSales_USD for a sample population. ***start of code*** = VAR.S(InternetSales_USD[SalesAmount_USD]) ***end of code***
VARX.P: Syntax - ***start of code*** VARX.P(<table>, <expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number with the variance of the entire population. ~ Remarks - VARX.P evaluates <expression> for each row of <table> and returns the variance of <expression> assuming that <table> refers to the entire population.. If <table> represents a sample of the population, then compute the variance by using VARX.S. VARX.P uses the following formula∑(x - x̃)2/nwhere x̃ is the average value of x for the entire populationand n is the population size Blank rows are filtered out from***start of code*** columnName ***end of code***and not considered in the calculations. An error is returned if***start of code*** columnName ***end of code***contains less than 2 non-blank rows This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows the formula for a calculated column that calculates the variance of the unit price per product, when the formula is used in the Product table ***start of code*** = VARX.P(InternetSales_USD, InternetSales_USD[UnitPrice_USD] –(InternetSales_USD[DiscountAmount_USD]/InternetSales_USD[OrderQuantity])) ***end of code***
VARX.S: Syntax - ***start of code*** VARX.S(<table>, <expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number that represents the variance of a sample population. ~ Remarks - VARX.S evaluates***start of code*** expression ***end of code***for each row of***start of code*** table ***end of code***and returns the variance of***start of code*** expression ***end of code***; on the assumption that***start of code*** table ***end of code***refers to a sample of the population. If***start of code*** table ***end of code***represents the entire population, then you should compute the variance by using VARX.P. VAR.S uses the following formula∑(x - x̃)2/(n-1)where x̃ is the average value of x for the sample populationand n is the population size Blank rows are filtered out from***start of code*** columnName ***end of code***and not considered in the calculations. An error is returned if***start of code*** columnName ***end of code***contains less than 2 non-blank rows. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows the formula for a calculated column that estimates the variance of the unit price per product for a sample population, when the formula is used in the Product table. ***start of code*** = VARX.S(InternetSales_USD, InternetSales_USD[UnitPrice_USD] – (InternetSales_USD[DiscountAmount_USD]/InternetSales_USD[OrderQuantity])) ***end of code***
ADDCOLUMNS: Syntax - ***start of code*** ADDCOLUMNS(<table>, <name>, <expression>[, <name>, <expression>]…) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table with all its original columns and the added ones. ~ Remarks -  ~ Example - The following example returns an extended version of the Product Category table that includes total sales values from the reseller channel and the internet sales. ***start of code*** ADDCOLUMNS(ProductCategory               , "Internet Sales", SUMX(RELATEDTABLE(InternetSales_USD), InternetSales_USD[SalesAmount_USD])               , "Reseller Sales", SUMX(RELATEDTABLE(ResellerSales_USD), ResellerSales_USD[SalesAmount_USD])) ***end of code*** The following table shows a preview of the data as it would be received by any function expecting to receive a table ProductCategory[ProductCategoryName]ProductCategory[ProductCategoryAlternateKey]ProductCategory[ProductCategoryKey][Internet Sales][Reseller Sales]Bikes1125107749.7763084675.04Components2211205837.96Clothing33306157.58291669943.267Accessories44640920.1338534301.9888
ADDMISSINGITEMS: Syntax - ***start of code*** ADDMISSINGITEMS ( [<showAll_columnName> [, <showAll_columnName> [, … ] ] ], <table> [, <groupBy_columnName> [, [<filterTable>] [, <groupBy_columnName> [, [<filterTable>] [, … ] ] ] ] ] ] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table with one or more columns. ~ Remarks -  ~ Example - There is no provided example for this function.
CROSSJOIN: Syntax - ***start of code*** CROSSJOIN(<table>, <table>[, <table>]…) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table that contains the Cartesian product of all rows from all tables in the arguments. ~ Remarks - Column names from***start of code*** table ***end of code***arguments must all be different in all tables or an error is returned. The total number of rows returned by CROSSJOIN() is equal to the product of the number of rows from all tables in the arguments; also, the total number of columns in the result table is the sum of the number of columns in all tables. For example, ifTableAhasrArows andcAcolumns, andTableBhasrBrows andcBcolumns, andTableChasrCrows andcCcolumn; then, the resulting table hasrA × rb × rCrows andcA + cB + cCcolumns. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example shows the results of applying CROSSJOIN() to two tablesColorsandStationery. The tableColorscontains colors and patterns ColorPatternRedHorizontal StripeGreenVertical StripeBlueCrosshatch The tableStationerycontains fonts and presentation FontPresentationserifembossedsans-serifengraved The expression to generate the cross join is presented below ***start of code*** CROSSJOIN( Colors, Stationery) ***end of code*** When the above expression is used wherever a table expression is expected, the results of the expression would be as follows ColorPatternFontPresentationRedHorizontal StripeserifembossedGreenVertical StripeserifembossedBlueCrosshatchserifembossedRedHorizontal Stripesans-serifengravedGreenVertical Stripesans-serifengravedBlueCrosshatchsans-serifengraved
CURRENTGROUP: Syntax - ***start of code*** CURRENTGROUP ( ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The rows in the table argument of theGROUPBYfunction corresponding to one group of values of the groupBy_columnName arguments. ~ Remarks - This function can only be used within aGROUPBYexpression. This function takes no arguments and is only supported as the first argument to one of the following aggregation functionsAVERAGEX,COUNTAX,COUNTX,GEOMEANX,MAXX,MINX,PRODUCTX,STDEVX.S,STDEVX.P,SUMX,VARX.S,VARX.P. ~ Example - SeeGROUPBY.
DATATABLE: Syntax - ***start of code*** DATATABLE (ColumnName1, DataType1, ColumnName2, DataType2..., {{Value1, Value2...}, {ValueN, ValueN+1...}...}) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table declaring an inline set of values. ~ Remarks - Unlike DATATABLE,Table Constructorallows any scalar expressions as input values. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - ***start of code*** = DataTable("Name", STRING,               "Region", STRING               ,{                        {" User1","East"},                        {" User2","East"},                        {" User3","West"},                        {" User4","West"},                        {" User4","East"}                }           ) ***end of code***
DETAILROWS: Syntax - ***start of code*** DETAILROWS([Measure]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table with the data returned by the Detail Rows Expression. If no Detail Rows Expression is defined, the data for the table containing the measure is returned. ~ Remarks -  ~ Example - There is no provided example for this function.
EXCEPT: Syntax - ***start of code*** EXCEPT(<table_expression1>, <table_expression2>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table that contains the rows of one table minus all the rows of another table. ~ Remarks - If a row appears at all in both tables, it and its duplicates are not present in the result set. If a row appears in only table_expression1, it and its duplicates will appear in the result set. The column names will match the column names in table_expression1. The returned table has lineage based on the columns in table_expression1 , regardless of the lineage of the columns in the second table. For example, if the first column of first table_expression has lineage to the base column C1 in the model, the Except will reduce the rows based on the availability of values in the first column of second table_expression and keep the lineage on base column C1 intact. The two tables must have the same number of columns. Columns are compared based on positioning, and data comparison with no type coercion. The set of rows returned depends on the order of the two expressions. The returned table does not include columns from tables related to table_expression1. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - States1 StateABBBCDD States2 StateBCDDDEEE Except(States1, States2) StateA Except(States2, States1) StateEEE
FILTERS: Syntax - ***start of code*** FILTERS(<columnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The values that are directly applied as filters to***start of code*** columnName ***end of code***. ~ Remarks -  ~ Example - The following example shows how to determine the number of direct filters a column has. ***start of code*** = COUNTROWS(FILTERS(ResellerSales_USD[ProductKey])) ***end of code*** This example lets you know how many direct filters on ResellerSales_USD[ProductKey] have been applied to the context where the expression is being evaluated.
GENERATE: Syntax - ***start of code*** GENERATE(<table1>, <table2>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table with the Cartesian product between each row intable1and the table that results from evaluatingtable2in the context of the current row fromtable1 ~ Remarks - If the evaluation oftable2for the current row intable1returns an empty table, then the result table will not contain the current row fromtable1. This is different than GENERATEALL() where the current row fromtable1will be included in the results and columns corresponding totable2will have null values for that row. All column names fromtable1andtable2must be different or an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - In the following example the user wants a summary table of the sales by Region and Product Category for the Resellers channel, like the following table SalesTerritory[SalesTerritoryGroup]ProductCategory[ProductCategoryName][Reseller Sales]EuropeAccessories$         142,227.27EuropeBikes$     9,970,200.44EuropeClothing$         365,847.63EuropeComponents$     2,214,440.19North AmericaAccessories$         379,305.15North AmericaBikes$   52,403,796.85North AmericaClothing$     1,281,193.26North AmericaComponents$     8,882,848.05PacificAccessories$           12,769.57PacificBikes$         710,677.75PacificClothing$           22,902.38PacificComponents$         108,549.71 The following formula produces the above table ***start of code*** GENERATE(SUMMARIZE(SalesTerritory, SalesTerritory[SalesTerritoryGroup]),SUMMARIZE(ProductCategory , [ProductCategoryName], "Reseller Sales", SUMX(RELATEDTABLE(ResellerSales_USD), ResellerSales_USD[SalesAmount_USD]))) ***end of code*** The first SUMMARIZE statement,***start of code*** SUMMARIZE(SalesTerritory, SalesTerritory[SalesTerritoryGroup]) ***end of code***, produces a table of territory groups, where each row is a territory group, as shown belowSalesTerritory[SalesTerritoryGroup]North AmericaEuropePacificNAThe second SUMMARIZE statement,***start of code*** SUMMARIZE(ProductCategory, [ProductCategoryName], "Reseller Sales", SUMX(RELATEDTABLE(ResellerSales_USD), ResellerSales_USD[SalesAmount_USD])) ***end of code***, produces a table of Product Category groups with the Reseller sales for each group, as shown belowProductCategory[ProductCategoryName][Reseller Sales]Bikes$               63,084,675.04Components$               11,205,837.96Clothing$                 1,669,943.27Accessories$                     534,301.99However, when you take the above table and evaluate it under the context of each row from the territory groups table, you obtain different results for each territory.
GENERATEALL: Syntax - ***start of code*** GENERATEALL(<table1>, <table2>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table with the Cartesian product between each row intable1and the table that results from evaluatingtable2in the context of the current row fromtable1 ~ Remarks - If the evaluation oftable2for the current row intable1returns an empty table, then the current row fromtable1will be included in the results and columns corresponding totable2will have null values for that row. This is different than GENERATE() where the current row fromtable1willnotbe included in the results. All column names fromtable1andtable2must be different or an error is returned. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - In the following example, the user wants a summary table of the sales by Region and Product Category for the Resellers channel, like the following table SalesTerritory[SalesTerritoryGroup]ProductCategory[ProductCategoryName][Reseller Sales]EuropeAccessories$        142,227.27EuropeBikes$    9,970,200.44EuropeClothing$        365,847.63EuropeComponents$    2,214,440.19NAAccessoriesNABikesNAClothingNAComponentsNorth AmericaAccessories$        379,305.15North AmericaBikes$  52,403,796.85North AmericaClothing$    1,281,193.26North AmericaComponents$    8,882,848.05PacificAccessories$          12,769.57PacificBikes$        710,677.75PacificClothing$          22,902.38PacificComponents$        108,549.71 The following formula produces the above table ***start of code*** GENERATEALL(SUMMARIZE(SalesTerritory, SalesTerritory[SalesTerritoryGroup]),SUMMARIZE(ProductCategory, [ProductCategoryName], "Reseller Sales", SUMX(RELATEDTABLE(ResellerSales_USD), ResellerSales_USD[SalesAmount_USD]))) ***end of code*** The first SUMMARIZE produces a table of territory groups, where each row is a territory group, like those listed belowSalesTerritory[SalesTerritoryGroup]North AmericaEuropePacificNAThe second SUMMARIZE produces a table of Product Category groups with the Reseller sales for each group, as shown belowProductCategory[ProductCategoryName][Reseller Sales]Bikes$               63,084,675.04Components$               11,205,837.96Clothing$                 1,669,943.27Accessories$                     534,301.99However, when you take the above table and evaluate the table under the context of each row from the territory groups table, you obtain different results for each territory.
GENERATESERIES: Syntax - ***start of code*** GENERATESERIES(<startValue>, <endValue>[, <incrementValue>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A single column table containing the values of an arithmetic series. The name of the column is Value. ~ Remarks - When endValue is less than startValue, an empty table is returned. incrementValue must be a positive value. The sequence stops at the last value that is less than or equal to endValue. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
GROUPBY: Syntax - ***start of code*** GROUPBY (<table> [, <groupBy_columnName> [, <groupBy_columnName> [, …]]] [, <name>, <expression> [, <name>, <expression> [, …]]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table with the selected columns for the groupBy_columnName arguments and the extension columns designated by the name arguments. ~ Remarks - The GROUPBY function does the followingStart with the specified table (and all related tables in the "to-one" direction).Create a grouping using all of the GroupBy columns (which are required to exist in the table from step #1.).Each group is one row in the result, but represents a set of rows in the original table.For each group, evaluate the extension columns being added.  Unlike the SUMMARIZE function, an implied CALCULATE is not performed, and the group isn't placed into the filter context. Start with the specified table (and all related tables in the "to-one" direction). Create a grouping using all of the GroupBy columns (which are required to exist in the table from step #1.). Each group is one row in the result, but represents a set of rows in the original table. For each group, evaluate the extension columns being added.  Unlike the SUMMARIZE function, an implied CALCULATE is not performed, and the group isn't placed into the filter context. Each column for which you define a name must have a corresponding expression; otherwise, an error is returned. The first argument, name, defines the name of the column in the results. The second argument, expression, defines the calculation performed to obtain the value for each row in that column. ***start of code*** groupBy_columnName ***end of code***must be either in table or in a related table. Each name must be enclosed in double quotation marks. The function groups a selected set of rows into a set of summary rows by the values of one or more groupBy_columnName columns. One row is returned for each group. GROUPBY is primarily used to perform aggregations over intermediate results from DAX table expressions. For efficient aggregations over physical tables in the model, consider usingSUMMARIZECOLUMNSorSUMMARIZEfunction. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
IGNORE: Syntax - ***start of code*** IGNORE(<expression>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The function does not return a value. ~ Remarks -  ~ Example - SeeSUMMARIZECOLUMNS.
INTERSECT: Syntax - ***start of code*** INTERSECT(<table_expression1>, <table_expression2>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table that contains all the rows in table_expression1 that are also in table_expression2 ~ Remarks - Intersect is not commutative. In general, Intersect(T1, T2) will have a different result set than Intersect(T2, T1). Duplicate rows are retained. If a row appears in table_expression1 and table_expression2, it and all duplicates in table_expression_1 are included in the result set. The column names will match the column names in table_expression1. The returned table has lineage based on the columns in table_expression1 , regardless of the lineage of the columns in the second table. For example, if the first column of first table_expression has lineage to the base column C1 in the model, the intersect will reduce the rows based on the intersect on first column of second table_expression and keep the lineage on base column C1 intact. Columns are compared based on positioning, and data comparison with no type coercion. The returned table does not include columns from tables related to table_expression1. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - States1 StateAABBBCDD States2 StateBCDDDE Intersect(States1, States2) StateBBBCDD Intersect(States2, States1) StateBCDDD
NATURALINNERJOIN: Syntax - ***start of code*** NATURALINNERJOIN(<LeftTable>, <RightTable>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table which includes only rows for which the values in the common columns specified are present in both tables. The table returned will have the common columns from the left table and other columns from both the tables. ~ Remarks - Tables are joined on common columns (by name) in the two tables. If the two tables have no common column names, an error is returned. There is no sort order guarantee for the results. Columns being joined on must have the same data type in both tables. Only columns from the same source table (have the same lineage) are joined on. For example, Products[ProductID], WebSales[ProductdID], StoreSales[ProductdID] with many-to-one relationships between WebSales and StoreSales and the Products table based on the ProductID column, WebSales and StoreSales tables are joined on [ProductID]. Strict comparison semantics are used during join. There is no type coercion; for example, 1 does not equal 1.0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
NATURALLEFTOUTERJOIN: Syntax - ***start of code*** NATURALLEFTOUTERJOIN(<LeftTable>, <RightTable>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table which includes only rows from RightTable for which the values in the common columns specified are also present in LeftTable. The table returned will have the common columns from the left table and the other columns from both the tables. ~ Remarks - Tables are joined on common columns (by name) in the two tables. If the two tables have no common column names, an error is returned. There is no sort order guarantee for the results. Columns being joined on must have the same data type in both tables. Only columns from the same source table (have the same lineage) are joined on. For example, Products[ProductID], WebSales[ProductdID], StoreSales[ProductdID] with many-to-one relationships between WebSales and StoreSales and the Products table based on the ProductID column, WebSales and StoreSales tables are joined on [ProductID]. Strict comparison semantics are used during join. There is no type coercion; for example, 1 does not equal 1.0. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
ROLLUP: Syntax - ***start of code*** ROLLUP ( <groupBy_columnName> [, <groupBy_columnName> [, … ] ] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - This function does not return a value. It only specifies the set of columns to be subtotaled. ~ Remarks -  ~ Example - SeeSUMMARIZE.
ROLLUPADDISSUBTOTAL: Syntax - ***start of code*** ROLLUPADDISSUBTOTAL ( [<grandtotalFilter>], <groupBy_columnName>, <name> [, [<groupLevelFilter>] [, <groupBy_columnName>, <name> [, [<groupLevelFilter>] [, … ] ] ] ] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The function does not return a value. ~ Remarks -  ~ Example - SeeSUMMARIZECOLUMNS.
ROLLUPISSUBTOTAL: Syntax - ***start of code*** ROLLUPISSUBTOTAL ( [<grandTotalFilter>], <groupBy_columnName>, <isSubtotal_columnName> [, [<groupLevelFilter>] [, <groupBy_columnName>, <isSubtotal_columnName> [, [<groupLevelFilter>] [, … ] ] ] ] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - None ~ Remarks -  ~ Example - There is no provided example for this function.
ROLLUPGROUP: Syntax - ***start of code*** ROLLUPGROUP ( <groupBy_columnName> [, <groupBy_columnName> [, … ] ] ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - This function does not return a value. It marks a set of columns to be treated as a single group during subtotaling byROLLUPorROLLUPADDISSUBTOTAL. ~ Remarks -  ~ Example - SeeSUMMARIZEandSUMMARIZECOLUMNS.
ROW: Syntax - ***start of code*** ROW(<name>, <expression>[[,<name>, <expression>]…]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A single row table ~ Remarks - Arguments must always come in pairs of***start of code*** name ***end of code***and***start of code*** expression ***end of code***. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example returns a single row table with the total sales for internet and resellers channels. ***start of code*** ROW("Internet Total Sales (USD)", SUM(InternetSales_USD[SalesAmount_USD]),         "Resellers Total Sales (USD)", SUM(ResellerSales_USD[SalesAmount_USD])) ***end of code***
SELECTCOLUMNS: Syntax - ***start of code*** SELECTCOLUMNS(<Table>, [<Name>], <Expression>, [<Name>], …)  ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table with the same number of rows as the table specified as the first argument. The returned table has one column for each pair of***start of code*** Name ***end of code***,***start of code*** Expression ***end of code***arguments, and each expression is evaluated in the context of a row from the specified***start of code*** Table ***end of code***argument. ~ Remarks -  ~ Example - For the following table namedCustomer CountryStateCountTotalINDJK20800INDMH251000INDWB10900USACA5500USAWA10900 ***start of code*** SELECTCOLUMNS(Customer, "Country, State", [Country]&", "&[State]) ***end of code*** Returns, Country, StateIND, JKIND, MHIND, WBUSA, CAUSA, WA
SUBSTITUTEWITHINDEX: Syntax - ***start of code*** SUBSTITUTEWITHINDEX(<table>, <indexColumnName>, <indexColumnsTable>, [<orderBy_expression>, [<order>][, <orderBy_expression>, [<order>]]…]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table which includes only those values present in the indexColumnsTable table and which has an index column instead of all columns present (by name) in the indexColumnsTable table. ~ Remarks - This function does not guarantee any result sort order. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
SUMMARIZE: Syntax - ***start of code*** SUMMARIZE (<table>, <groupBy_columnName>[, <groupBy_columnName>]…[, <name>, <expression>]…) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table with the selected columns for the***start of code*** groupBy_columnName ***end of code***arguments and the summarized columns designed by the name arguments. ~ Remarks - Each column for which you define a name must have a corresponding expression; otherwise, an error is returned. The first argument, name, defines the name of the column in the results. The second argument, expression, defines the calculation performed to obtain the value for each row in that column. groupBy_columnName must be either in***start of code*** table ***end of code***or in a related table to***start of code*** table ***end of code***. Each name must be enclosed in double quotation marks. The function groups a selected set of rows into a set of summary rows by the values of one or more groupBy_columnName columns. One row is returned for each group. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example returns a summary of the reseller sales grouped around the calendar year and the product category name, this result table allows you to do analysis over the reseller sales by year and product category. ***start of code*** SUMMARIZE(ResellerSales_USD      , DateTime[CalendarYear]      , ProductCategory[ProductCategoryName]      , "Sales Amount (USD)", SUM(ResellerSales_USD[SalesAmount_USD])      , "Discount Amount (USD)", SUM(ResellerSales_USD[DiscountAmount])      ) ***end of code*** The following table shows a preview of the data as it would be received by any function expecting to receive a table DateTime[CalendarYear]ProductCategory[ProductCategoryName][Sales Amount (USD)][Discount Amount (USD)]2008Bikes12968255.4236167.65922005Bikes6958251.0434231.16212006Bikes18901351.08178175.83992007Bikes24256817.5276065.9922008Components2008052.70639.92662005Components574256.986502006Components3428213.05948.76742007Components5195315.2164226.04442008Clothing366507.8444151.12352005Clothing31851.162890.95932006Clothing455730.97294233.0392007Clothing815853.286812489.38352008Accessories153299.924865.59452005Accessories18594.47824.2932006Accessories86612.74631061.48722007Accessories275794.84034756.6546
SUMMARIZECOLUMNS: Syntax - ***start of code*** SUMMARIZECOLUMNS( <groupBy_columnName> [, < groupBy_columnName >]…, [<filterTable>]…[, <name>, <expression>]…) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table which includes combinations of values from the supplied columns based on the grouping specified. Only rows for which at least one of the supplied expressions return a non-blank value are included in the table returned. If all expressions evaluate to BLANK/NULL for a row, that row is not included in the table returned. ~ Remarks - This function does not guarantee any sort order for the results. A column cannot be specified more than once in the groupBy_columnName parameter. For example, the following formula is invalid.***start of code*** SUMMARIZECOLUMNS( Sales[StoreId], Sales[StoreId] ) ***end of code*** This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
TOPN: Syntax - ***start of code*** TOPN(<N_Value>, <Table>, <OrderBy_Expression>, [<Order>[, <OrderBy_Expression>, [<Order>]]…]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table with the top N rows of***start of code*** Table ***end of code***or an empty table if***start of code*** N_Value ***end of code***is 0 (zero) or less. Rows are not sorted in any particular order. ~ Remarks - If there is a tie, in***start of code*** Order_By ***end of code***values, at the N-th row of the table, then all tied rows are returned. Then, when there are ties at the N-th row the function might return more than n rows. If N_Value is 0 (zero) or less, TOPN returns an empty table. TOPN does not guarantee any sort order for the results. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following measure formula returns the top 10 sold products by sales amount. ***start of code*** = SUMX(        TOPN(            10,             SUMMARIZE(                    InternetSales,                     InternetSales[ProductKey],                     "TotalSales", SUM(InternetSales[SalesAmount])            ),            [TotalSales], DESC        ),        [TotalSales])  ***end of code***
TREATAS: Syntax - ***start of code*** TREATAS(table_expression, <column>[, <column>[, <column>[,…]]]} ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table that contains all the rows in column(s) that are also in table_expression. ~ Remarks - The number of columns specified must match the number of columns in the table expression and be in the same order. If a value returned in the table expression does not exist in the column, it is ignored. For example, TREATAS({"Red", "Green", "Yellow"}, DimProduct[Color]) sets a filter on column DimProduct[Color] with three values "Red", "Green", and "Yellow". If "Yellow" does not exist in  DimProduct[Color], the effective filter values would be "Red" and "Green". Best for use when a relationship does not exist between the tables. If you have multiple relationships between the tables involved, consider usingUSERELATIONSHIPinstead. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - In the following example, the model contains two unrelated product tables. If a user applies a filter to DimProduct1[ProductCategory] selecting Bikes, Seats, Tires, the same filter, Bikes, Seats, Tires is applied to DimProduct2[ProductCategory]. ***start of code*** CALCULATE(    SUM(Sales[Amount]),    TREATAS(        VALUES(DimProduct1[ProductCategory]),        DimProduct2[ProductCategory]    )) ***end of code***
UNION: Syntax - ***start of code*** UNION(<table_expression1>, <table_expression2> [,<table_expression>]…) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table that contains all the rows from each of the two table expressions. ~ Remarks - The two tables must have the same number of columns. Columns are combined by position in their respective tables. The column names in the return table will match the column names in table_expression1. Duplicate rows are retained. The returned table has lineage where possible. For example, if the first column of each table_expression has lineage to the same base column C1 in the model, the first column in the UNION result will have lineage to C1. However, if combined columns have lineage to different base columns, or if there is an extension column, the resulting column in UNION will have no lineage. When data types differ, the resulting data type is determined based on the rules for data type coercion. The returned table will not contain columns from related tables. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following expression creates a union by combining the USAInventory table and the INDInventory table into a single table ***start of code*** UNION(UsaInventory, IndInventory) ***end of code*** USAInventory Country/RegionStateCountTotalUSACA5500USAWA10900 INDInventory Country/RegionStateCountTotalINDJK20800INDMH251000INDWB10900 Return table, Country/RegionStateCountTotalUSACA5500USAWA10900INDJK20800INDMH251000INDWB10900
VALUES: Syntax - ***start of code*** VALUES(<TableNameOrColumnName>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - When the input parameter is a column name, a single column table. When the input parameter is a table name, a table of the same columns is returned. ~ Remarks - When you use the VALUES function in a context that has been filtered, the unique values returned by VALUES are affected by the filter. For example, if you filter by Region, and return a list of the values for City, the list will include only those cities in the regions permitted by the filter. To return all of the cities, regardless of existing filters, you must use the ALL function to remove filters from the table. The second example demonstrates use of ALL with VALUES. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. For best practices when using VALUES, seeUse SELECTEDVALUE instead of VALUES. ~ Example - The following formula counts the number of unique invoices (sales orders), and produces the following results when used in a report that includes the Product Category Names ***start of code*** = COUNTROWS(VALUES('InternetSales_USD'[SalesOrderNumber])) ***end of code*** Returns Row LabelsCount InvoicesAccessories18,208Bikes15,205Clothing7,461Grand Total27,659
COMBINEVALUES: Syntax - ***start of code*** COMBINEVALUES(<delimiter>, <expression>, <expression>[, <expression>]…) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A concatenated string. ~ Remarks - The COMBINEVALUES function assumes, but does not validate, that when the input values are different, the output strings are also different. Based on this assumption, when COMBINEVALUES is used to create calculated columns in order to build a relationship that joins multiple columns from two DirectQuery tables, an optimized join condition is generated at query time. For example, if users want to create a relationship between Table1(Column1, Column2) and Table2(Column1, Column2), they can create two calculated columns, one on each table, as***start of code*** Table1[CalcColumn] = COMBINEVALUES(",", Table1[Column1], Table1[Column2]) ***end of code***and***start of code*** Table2[CalcColumn] = COMBINEVALUES(",", Table2[Column1], Table2[Column2]) ***end of code***And then create a relationship between***start of code*** Table1[CalcColumn] ***end of code***and***start of code*** Table2[CalcColumn] ***end of code***. Unlike other DAX functions and operators, which are translated literally to the corresponding SQL operators and functions, the above relationship generates a SQL join predicate as***start of code*** (Table1.Column1 = Table2.Column1 OR Table1.Column1 IS NULL AND Table2.Column1 IS NULL) ***end of code***and***start of code*** (Table1.Column2 = Table2.Column2 OR Table1.Column2 IS NULL AND Table2.Column2 IS NULL) ***end of code*** The join predicate can potentially deliver much better query performance than one that involves complex SQL operators and functions. The COMBINEVALUES function relies on users to choose the appropriate delimiter to ensure that unique combinations of input values produce distinct output strings but it does not validate that the assumption is true. For example, if users choose***start of code*** "| " ***end of code***as the delimiter, but one row in Table1 has***start of code*** Table1[Column1] = "| " ***end of code***and***start of code*** Table2 [Column2] = " " ***end of code***, while one row in Table2 has***start of code*** Table2[Column1] = " " ***end of code***and***start of code*** Table2[Column2] = "| " ***end of code***, the two concatenated outputs will be the same***start of code*** "|| " ***end of code***,  which seem to indicate that the two rows are a match in the join operation. The two rows are not joined together if both tables are from the same DirectQuery source although they are joined together if both tables are imported. ~ Example - The following DAX query ***start of code*** EVALUATEDISTINCT (    SELECTCOLUMNS ( Date, "Month", COMBINEVALUES ( ", ", [MonthName], [CalendarYear] ) )) ***end of code*** Returns the following single column table [Month]January, 2020February, 2020March, 2020April, 2020May, 2020June, 2020July, 2020August, 2020September, 2020October, 2020November, 2020December, 2020January, 2021January, 2021February, 2021March, 2021April, 2021May, 2021June, 2021July, 2021August, 2021September, 2021October, 2021November, 2021December, 2021
CONCATENATE: Syntax - ***start of code*** CONCATENATE(<text1>, <text2>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A concatenated string. ~ Remarks - The CONCATENATE function joins two text strings into one text string. The joined items can be text, numbers, Boolean values represented as text, or a combination of those items. You can also use a column reference if the column contains appropriate values. The CONCATENATE function in DAX accepts only two arguments, whereas the Excel CONCATENATE function accepts up to 255 arguments. If you need to concatenate multiple columns, you can create a series of calculations or use the concatenation operator (***start of code*** & ***end of code***) to join all of them in a simpler expression. If you want to use text strings directly, rather than using a column reference, you must enclose each string in double quotation marks. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
CONCATENATEX: Syntax - ***start of code*** CONCATENATEX(<table>, <expression>[, <delimiter> [, <orderBy_expression> [, <order>]]...]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A concatenated string. ~ Remarks - This function takes as its first argument a table or an expression that returns a table. The second argument is a column that contains the values you want to concatenate, or an expression that returns a value. Concatenated values are not necessarily sorted in any particular order, unless***start of code*** orderBy_expression ***end of code***is specified. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - Employees table FirstNameLastNameAlanBrewerMichaelBlythe The following formula ***start of code*** = CONCATENATEX(Employees, [FirstName] & " " & [LastName], ",") ***end of code*** Returns"Alan Brewer, Michael Blythe"
EXACT: Syntax - ***start of code*** EXACT(<text1>,<text2>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - True or False. (Boolean) ~ Remarks -  ~ Example - The following formula used in a calculated column in the Product table checks the value of Product for the current row against the value of Model for the current row, and returns True if they are the same, and returns False if they are different. Examples in this article can be used with the sample Adventure Works DW 2020 Power BI Desktop model. To get the model, seeDAX sample model. ***start of code*** = EXACT([Product], [Model]) ***end of code***
FIND: Syntax - ***start of code*** FIND(<find_text>, <within_text>[, [<start_num>][, <NotFoundValue>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Number that shows the starting point of the text string you want to find. ~ Remarks - Whereas Microsoft Excel has multiple versions of the FIND function to accommodate single-byte character set (SBCS) and double-byte character set (DBCS) languages, DAX uses Unicode and counts each character the same way; therefore, you do not need to use a different version depending on the character type. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. FIND does not support wildcards. To use wildcards, useSEARCH. ~ Example - The following DAX query finds the position of the first letter of "Bike", in the string that contains the reseller name. If not found, Blank is returned. Keep in mind, FIND is case-sensitive. In this example, if "bike" were used in the***start of code*** find_text ***end of code***argument, no results would be returned. UseSEARCHfor case-insensitive. Examples in this article can be used with the sample Adventure Works DW 2020 Power BI Desktop model. To get the model, seeDAX sample model. ***start of code*** EVALUATECALCULATETABLE (    ADDCOLUMNS (        TOPN ( 10, SUMMARIZE('Reseller', [Reseller], [Business Type])),        "Position of Bike", FIND ( "Bike", 'Reseller'[Reseller], 1, BLANK () )    ),    'Reseller'[Business Type] IN { "Specialty Bike Shop", "Value Added Reseller", "Warehouse"}) ***end of code*** Returns, ResellerBusiness TypePosition of BikeVolume Bike SellersWarehouse8Mass Market BikesValue Added Reseller13Twin CyclesValue Added ResellerRich Department StoreWarehouseRental GallerySpecialty Bike ShopBudget Toy StoreWarehouseGlobal Sports OutletWarehouseOnline Bike CatalogWarehouse8Helmets and CyclesValue Added ResellerJumbo BikesSpecialty Bike Shop7
FIXED: Syntax - ***start of code*** FIXED(<number>, <decimals>, <no_commas>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A number represented as text. ~ Remarks - If the value used for the***start of code*** decimals ***end of code***parameter is negative,***start of code*** number ***end of code***is rounded to the left of the decimal point. If you omit***start of code*** decimals ***end of code***, it is assumed to be 2. If***start of code*** no_commas ***end of code***is 0 or is omitted, then the returned text includes commas as usual. The major difference between formatting a cell containing a number by using a command and formatting a number directly with the FIXED function is that FIXED converts its result to text. A number formatted with a command from the formatting menu is still a number. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following formula used in a calculated column gets the numeric value for the current row in Product[List Price] and returns it as text with 2 decimal places and no commas. Examples in this article can be used with the sample Adventure Works DW 2020 Power BI Desktop model. To get the model, seeDAX sample model. ***start of code*** = FIXED([List Price],2,1) ***end of code***
FORMAT: Syntax - ***start of code*** FORMAT(<value>, <format_string>[, <locale_name>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A string containing***start of code*** value ***end of code***formatted as defined by***start of code*** format_string ***end of code***. ~ Remarks - Predefined format strings use the model culture property when formatting the result. By default, the model culture property is set according to the user locale of the computer. For new Power BI Desktop models, the model culture property can be changed in Options > Regional Settings > Model language. For Analysis Services, model culture is set according to the Language property initially defined by the instance. The format strings supported as an argument to the DAX FORMAT function are based on the format strings used by Visual Basic (OLE Automation), not on the format strings used by the .NET Framework. Therefore, you might get unexpected results or an error if the argument doesn't match any defined format strings. For example, "p" as an abbreviation for "Percent" isn't supported. Strings that you provide as an argument to the FORMAT function that aren't included in the list of predefined format strings are handled as part of a custom format string, or as a string literal. To learn more specifying a locale with FORMAT, check out thisvideo. Using FORMAT changes a measure result to a text data type. If the measure result is originally of numeric data type, then with FORMAT, the measure can't be used on visuals where the values section requires a numeric data type, like with charts. In Power BI, you can alternatively useDynamic format strings for measuresspecify a conditional format string that maintains the numeric data type of the measure. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
LEFT: Syntax - ***start of code*** LEFT(<text>, <num_chars>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A text string. ~ Remarks - Whereas Microsoft Excel contains different functions for working with text in single-byte and double-byte character languages, DAX works with Unicode and stores all characters as the same length; therefore, a single function is enough. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following example returns the first five characters of the company name in the column [ResellerName] and the first five letters of the geographical code in the column [GeographyKey] and concatenates them, to create an identifier. ***start of code*** = CONCATENATE(LEFT('Reseller'[ResellerName],LEFT(GeographyKey,3)) ***end of code*** If the***start of code*** num_chars ***end of code***argument is a number that is larger than the number of characters available, the function returns the maximum characters available and does not raise an error. For example, the column [GeographyKey] contains numbers such as 1, 12 and 311; therefore the result also has variable length.
LEN: Syntax - ***start of code*** LEN(<text>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A whole number indicating the number of characters in the text string. ~ Remarks - Whereas Microsoft Excel has different functions for working with single-byte and double-byte character languages, DAX uses Unicode and stores all characters with the same length. LEN always counts each character as 1, no matter what the default language setting is. If you use LEN with a column that contains non-text values, such as dates or Booleans, the function implicitly casts the value to text, using the current column format. ~ Example - The following formula sums the lengths of addresses in the columns, [AddressLine1] and [AddressLine2]. ***start of code*** = LEN([AddressLine1])+LEN([AddressLin2]) ***end of code***
LOWER: Syntax - ***start of code*** LOWER(<text>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Text in lowercase. ~ Remarks -  ~ Example - The following formula gets each row in the column, [ProductCode], and converts the value to all lowercase. Numbers in the column are not affected. ***start of code*** = LOWER('New Products'[ProductCode]) ***end of code***
MID: Syntax - ***start of code*** MID(<text>, <start_num>, <num_chars>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A string of text of the specified length. ~ Remarks -  ~ Example - There is no provided example for this function.
REPLACE: Syntax - ***start of code*** REPLACE(<old_text>, <start_num>, <num_chars>, <new_text>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A text string. ~ Remarks - Whereas Microsoft Excel has different functions for use with single-byte and double-byte character languages, DAX uses Unicode and therefore stores all characters as the same length. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following formula creates a new calculated column that replaces the first two characters of the product code in column, [ProductCode], with a new two-letter code, OB. ***start of code*** = REPLACE('New Products'[Product Code],1,2,"OB") ***end of code***
REPT: Syntax - ***start of code*** REPT(<text>, <num_times>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A string containing the changes. ~ Remarks - If***start of code*** num_times ***end of code***is 0 (zero), REPT returns a blank. If***start of code*** num_times ***end of code***is not an integer, it is truncated. The result of the REPT function cannot be longer than 32,767 characters, or REPT returns an error. ~ Example - There is no provided example for this function.
RIGHT: Syntax - ***start of code*** RIGHT(<text>, <num_chars>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A text string containing the specified right-most characters. ~ Remarks - RIGHT always counts each character, whether single-byte or double-byte, as 1, no matter what the default language setting is. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
SEARCH: Syntax - ***start of code*** SEARCH(<find_text>, <within_text>[, [<start_num>][, <NotFoundValue>]]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The number of the starting position of the first text string from the first character of the second text string. ~ Remarks - The search function is case insensitive. Searching for "N" will find the first occurrence of 'N' or 'n'. The search function is accent sensitive. Searching for "á" will find the first occurrence of 'á' but no occurrences of 'a', 'à', or the capitalized versions 'A', 'Á'. You can use the SEARCH function to determine the location of a character or text string within another text string, and then use the MID function to return the text, or use the REPLACE function to change the text. If the***start of code*** find_text ***end of code***cannot be found in***start of code*** within_text ***end of code***, the formula returns an error. This behavior is like Excel, which returns #VALUE if the substring is not found. Nulls in***start of code*** within_text ***end of code***will be interpreted as an empty string in this context. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following DAX query finds the position of the first letter of "cycle", in the string that contains the reseller name. If not found, Blank is returned. SEARCH is case-insensitive. In this example, if "cycle" or "Cycle" is used in the***start of code*** find_text ***end of code***argument, results are returned for either case. UseFINDfor case-sensitive. Examples in this article can be used with the sample Adventure Works DW 2020 Power BI Desktop model. To get the model, seeDAX sample model. ***start of code*** EVALUATECALCULATETABLE (    ADDCOLUMNS (        TOPN ( 10, SUMMARIZE('Reseller', [Reseller], [Business Type])),        "Position of cycle", SEARCH ( "cycle", 'Reseller'[Reseller], 1, BLANK () )    ),    'Reseller'[Business Type] IN { "Specialty Bike Shop", "Value Added Reseller", "Warehouse"}) ***end of code*** Returns, ResellerBusiness TypePosition of cycleVolume Bike SellersWarehouseMass Market BikesValue Added ResellerTwin CyclesValue Added Reseller6Rich Department StoreWarehouseRental GallerySpecialty Bike ShopBudget Toy StoreWarehouseGlobal Sports OutletWarehouseOnline Bike CatalogWarehouseHelmets and CyclesValue Added Reseller13Jumbo BikesSpecialty Bike Shop
SUBSTITUTE: Syntax - ***start of code*** SUBSTITUTE(<text>, <old_text>, <new_text>, <instance_num>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A string of text. ~ Remarks - Use the SUBSTITUTE function when you want to replace specific text in a text string; use the REPLACE function when you want to replace any text of variable length that occurs in a specific location in a text string. The SUBSTITUTE function is case-sensitive. If case does not match between***start of code*** text ***end of code***and***start of code*** old_text ***end of code***, SUBSTITUTE will not replace the text. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
TRIM: Syntax - ***start of code*** TRIM(<text>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The string with spaces removed. ~ Remarks - Use TRIM on text that you have received from another application that may have irregular spacing. The TRIM function was originally designed to trim the 7-bit ASCII space character (value 32) from text. In the Unicode character set, there is an additional space character called the nonbreaking space character that has a decimal value of 160. This character is commonly used in Web pages as the HTML entity, &nbsp;. By itself, the TRIM function does not remove this nonbreaking space character. For an example of how to trim both space characters from text, see Remove spaces and nonprinting characters from text. ~ Example - The following formula creates a new string that does not have trailing white space. ***start of code*** = TRIM("A column with trailing spaces.   ") ***end of code*** When you create the formula, the formula is propagated through the row just as you typed it, so that you see the original string in each formula and the results are not apparent. However, when the formula is evaluated the string is trimmed. You can verify that the formula produces the correct result by checking the length of the calculated column created by the previous formula, as follows ***start of code*** = LEN([Calculated Column 1]) ***end of code***
UNICHAR: Syntax - ***start of code*** UNICHAR(number) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A character represented by the Unicode number. ~ Remarks - If XML characters are not invalid, UNICHAR returns an error. If Unicode numbers are partial surrogates and data types are not valid, UNICHAR returns an error. If numbers are numeric values that fall outside the allowable range, UNICHAR returns an error. If number is zero (0), UNICHAR returns an error. The Unicode character returned can be a string of characters, for example in UTF-8 or UTF-16 codes. ~ Example - The following example returns the character represented by the Unicode number 66 (uppercase A). ***start of code*** = UNICHAR(65) ***end of code*** The following example returns the character represented by the Unicode number 32 (space character). ***start of code*** = UNICHAR(32) ***end of code*** The following example returns the character represented by the Unicode number 9733 (★ character). ***start of code*** = UNICHAR(9733) ***end of code***
UNICODE: Syntax - ***start of code*** UNICODE( <Text> ) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A numeric code for the first character in a text string. ~ Remarks -  ~ Example - There is no provided example for this function.
UPPER: Syntax - ***start of code*** UPPER (<text>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - Same text, in uppercase. ~ Remarks -  ~ Example - The following formula converts the string in the column, [ProductCode], to all uppercase. Non-alphabetic characters are not affected. ***start of code*** = UPPER(['New Products'[Product Code]) ***end of code***
VALUE: Syntax - ***start of code*** VALUE(<text>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - The converted number in decimal data type. ~ Remarks - The value passed as the***start of code*** text ***end of code***parameter can be in any of the constant, number, date, or time formats recognized by the application or services you are using. If***start of code*** text ***end of code***is not in one of these formats, an error is returned. You do not generally need to use the VALUE function in a formula because the engine implicitly converts text to numbers as necessary. You can also use column references. For example, if you have a column that contains mixed number types, VALUE can be used to convert all values to a single numeric data type. However, if you use the VALUE function with a column that contains mixed numbers and text, the entire column is flagged with an error, because not all values in all rows can be converted to numbers. ~ Example - The following formula converts the typed string, "3", into the numeric value 3. ***start of code*** = VALUE("3") ***end of code***
CLOSINGBALANCEMONTH: Syntax - ***start of code*** CLOSINGBALANCEMONTH(<expression>,<dates>[,<filter>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value that represents the***start of code*** expression ***end of code***evaluated at the last date of the month in the current context. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values.NoteConstraints on Boolean expressions are described inCALCULATE function.NoteThe***start of code*** filter ***end of code***expression has restrictions described inCALCULATE function. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values.NoteConstraints on Boolean expressions are described inCALCULATE function.NoteThe***start of code*** filter ***end of code***expression has restrictions described inCALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'Month End Inventory Value' of the product inventory. ***start of code*** = CLOSINGBALANCEMONTH(SUMX(ProductInventory,ProductInventory[UnitCost]*ProductInventory[UnitsBalance]),DateTime[DateKey]) ***end of code***
CLOSINGBALANCEQUARTER: Syntax - ***start of code*** CLOSINGBALANCEQUARTER(<expression>,<dates>[,<filter>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value that represents the***start of code*** expression ***end of code***evaluated at the last date of the quarter in the current context. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values.NoteConstraints on Boolean expressions are described inCALCULATE function.NoteThe***start of code*** filter ***end of code***expression has restrictions described inCALCULATE function. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values.NoteConstraints on Boolean expressions are described inCALCULATE function.NoteThe***start of code*** filter ***end of code***expression has restrictions described inCALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'Quarter End Inventory Value' of the product inventory. ***start of code*** = CLOSINGBALANCEQUARTER(SUMX(ProductInventory,ProductInventory[UnitCost]*ProductInventory[UnitsBalance]),DateTime[DateKey]) ***end of code***
CLOSINGBALANCEYEAR: Syntax - ***start of code*** CLOSINGBALANCEYEAR(<expression>,<dates>[,<filter>][,<year_end_date>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value that represents the***start of code*** expression ***end of code***evaluated at the last date of the year in the current context. ~ Remarks - The***start of code*** year_end_date ***end of code***parameter is a string literal of a date, in the same locale as the locale of the client where the workbook was created. The year portion of the date is ignored. The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values.NoteConstraints on Boolean expressions are described inCALCULATE function.NoteThe***start of code*** filter ***end of code***expression has restrictions described inCALCULATE function. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values.NoteConstraints on Boolean expressions are described inCALCULATE function.NoteThe***start of code*** filter ***end of code***expression has restrictions described inCALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'Year End Inventory Value' of the product inventory. ***start of code*** = CLOSINGBALANCEYEAR(SUMX(ProductInventory,ProductInventory[UnitCost]*ProductInventory[UnitsBalance]),DateTime[DateKey]) ***end of code***
DATEADD: Syntax - ***start of code*** DATEADD(<dates>,<number_of_intervals>,<interval>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - A reference to a date/time column, A table expression that returns a single column of date/time values, A Boolean expression that defines a single-column table of date/time values.NoteConstraints on Boolean expressions are described in the topic,CALCULATE function. If the number specified for***start of code*** number_of_intervals ***end of code***is positive, the dates in***start of code*** dates ***end of code***are moved forward in time; if the number is negative, the dates in***start of code*** dates ***end of code***are shifted back in time. The***start of code*** interval ***end of code***parameter is an enumeration, not a set of strings; therefore values should not be enclosed in quotation marks. Also, the values***start of code*** year ***end of code***,***start of code*** quarter ***end of code***,***start of code*** month ***end of code***,***start of code*** day ***end of code***should be spelled in full when using them. The result table includes only dates that exist in the***start of code*** dates ***end of code***column. If the dates in the current context do not form a contiguous interval, the function returns an error. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - There is no provided example for this function.
DATESBETWEEN: Syntax - ***start of code*** DATESBETWEEN(<Dates>, <StartDate>, <EndDate>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - In the most common use case,***start of code*** dates ***end of code***is a reference to the date column of a marked date table. If***start of code*** StartDate ***end of code***is BLANK, then***start of code*** StartDate ***end of code***will be the earliest value in the***start of code*** dates ***end of code***column. If***start of code*** EndDate ***end of code***is BLANK, then***start of code*** EndDate ***end of code***will be the latest value in the***start of code*** dates ***end of code***column. Dates used as the***start of code*** StartDate ***end of code***and***start of code*** EndDate ***end of code***are inclusive. So, for example, if the***start of code*** StartDate ***end of code***value is July 1, 2019, then that date will be included in the returned table (providing the date exists in the***start of code*** dates ***end of code***column). The returned table can only contain dates stored in the***start of code*** Dates ***end of code***column. So, for example, if the***start of code*** Dates ***end of code***column starts from July 1, 2017, and the***start of code*** StartDate ***end of code***value is July 1, 2016, the returned table will start from July 1, 2017. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The followingSalestable measure definition uses the DATESBETWEEN function to produce alife-to-date(LTD) calculation. Life-to-date represents the accumulation of a measure over time since the very beginning of time. Notice that the formula uses theMAXfunction. This function returns the latest date that's in the filter context. So, the DATESBETWEEN function returns a table of dates beginning from the earliest date until the latest date being reported. Examples in this article can be used with the sample Adventure Works DW 2020 Power BI Desktop model. To get the model, seeDAX sample model. ***start of code*** Customers LTD =CALCULATE(    DISTINCTCOUNT(Sales[CustomerKey]),    DATESBETWEEN(        'Date'[Date],        BLANK(),        MAX('Date'[Date])    )) ***end of code*** Consider that the earliest date stored in theDatetable is July 1, 2017. So, when a report filters the measure by the month of June 2020, the DATESBETWEEN function returns a date range from July 1, 2017 until June 30, 2020.
DATESINPERIOD: Syntax - ***start of code*** DATESINPERIOD(<dates>, <start_date>, <number_of_intervals>, <interval>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - In the most common use case,***start of code*** dates ***end of code***is a reference to the date column of a marked date table. If the number specified for***start of code*** number_of_intervals ***end of code***is positive, dates are moved forward in time; if the number is negative, dates are shifted backward in time. The***start of code*** interval ***end of code***parameter is an enumeration. Valid values are***start of code*** DAY ***end of code***,***start of code*** MONTH ***end of code***,***start of code*** QUARTER ***end of code***, and***start of code*** YEAR ***end of code***. Because it's an enumeration, values aren't passed in as strings. So don't enclose them within quotation marks. The returned table can only contain dates stored in the***start of code*** dates ***end of code***column. So, for example, if the***start of code*** dates ***end of code***column starts from July 1, 2017, and the***start of code*** start_date ***end of code***value is July 1, 2016, the returned table will start from July 1, 2017. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The followingSalestable measure definition uses the DATESINPERIOD function to calculate revenue for the prior year (PY). Notice the formula uses theMAXfunction. This function returns the latest date that's in the filter context. So, the DATESINPERIOD function returns a table of dates beginning from the latest date for the last year. Examples in this article can be used with the sample Adventure Works DW 2020 Power BI Desktop model. To get the model, seeDAX sample model. ***start of code*** Revenue PY =CALCULATE(    SUM(Sales[Sales Amount]),    DATESINPERIOD(        'Date'[Date],        MAX('Date'[Date]),        -1,        YEAR    )) ***end of code*** Consider that the report is filtered by the month of June 2020. The MAX function returns June 30, 2020. The DATESINPERIOD function then returns a date range from July 1, 2019 until June 30, 2020. It's a year of date values starting from June 30, 2020 for the last year.
DATESMTD: Syntax - ***start of code*** DATESMTD(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values.NoteConstraints on Boolean expressions are described in the topic,CALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'Month To Date Total' for Internet Sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), DATESMTD(DateTime[DateKey])) ***end of code***
DATESQTD: Syntax - ***start of code*** DATESQTD(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values.NoteConstraints on Boolean expressions are described in the topic,CALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'Quarterly Running Total' of Internet Sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), DATESQTD(DateTime[DateKey])) ***end of code***
DATESYTD: Syntax - ***start of code*** DATESYTD(<dates> [,<year_end_date>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - A reference to a date/time column, A table expression that returns a single column of date/time values, A Boolean expression that defines a single-column table of date/time values.NoteConstraints on Boolean expressions are described in the topic,CALCULATE function. The***start of code*** year_end_date ***end of code***parameter is a string literal of a date, in the same locale as the locale of the client where the workbook was created. The year portion of the date is ignored.  Depending on locale, the format might be something like "m-dd" or "dd-m". This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'Running Total' for Internet sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), DATESYTD(DateTime[DateKey])) ***end of code*** The following sample formula creates a measure that calculates the 'Fiscal Year Running Total' for Internet sales, using a US Locale for the Date format. ***start of code*** = CALCULATE(    SUM(InternetSales_USD[SalesAmount_USD]),     DATESYTD(DateTime[DateKey],        "6-30"        )) ***end of code***
ENDOFMONTH: Syntax - ***start of code*** ENDOFMONTH(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column and single row with a date value. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that returns the end of the month, for the current context. ***start of code*** = ENDOFMONTH(DateTime[DateKey]) ***end of code***
ENDOFQUARTER: Syntax - ***start of code*** ENDOFQUARTER(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column and single row with a date value. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column,A table expression that returns a single column of date/time values,A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column, A table expression that returns a single column of date/time values, A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that returns the end of the quarter, for the current context. ***start of code*** = ENDOFQUARTER(DateTime[DateKey]) ***end of code***
ENDOFYEAR: Syntax - ***start of code*** ENDOFYEAR(<dates> [,<year_end_date>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column and single row with a date value. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column,A table expression that returns a single column of date/time values,A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column, A table expression that returns a single column of date/time values, A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. The***start of code*** year_end_date ***end of code***parameter is a string literal of a date, in the same locale as the locale of the client where the workbook was created. The year portion of the date is ignored. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that returns the end of the fiscal year that ends on June 30, for the current context. ***start of code*** = ENDOFYEAR(DateTime[DateKey],"06/30/2004") ***end of code***
FIRSTDATE: Syntax - ***start of code*** FIRSTDATE(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column and single row with a date value. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. When the current context is a single date, the date returned by the FIRSTDATE and LASTDATE functions will be equal. The Return value is a table that contains a single column and single value. Therefore, this function can be used as an argument to any function that requires a table in its arguments. Also, the returned value can be used whenever a date value is required. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that obtains the first date when a sale was made in the Internet sales channel for the current context. ***start of code*** = FIRSTDATE('InternetSales_USD'[SaleDateKey]) ***end of code***
LASTDATE: Syntax - ***start of code*** LASTDATE(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column and single row with a date value. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column,A table expression that returns a single column of date/time values,A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column, A table expression that returns a single column of date/time values, A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. When the current context is a single date, the date returned by the FIRSTDATE and LASTDATE functions will be equal. Technically, the Return value is a table that contains a single column and single value. Therefore, this function can be used as an argument to any function that requires a table in its arguments. Also, the returned value can be used whenever a date value is required. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that obtains the last date, for the current context, when a sale was made in the Internet sales channel. ***start of code*** = LASTDATE('InternetSales_USD'[SaleDateKey]) ***end of code***
NEXTDAY: Syntax - ***start of code*** NEXTDAY(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - This function returns all dates from the next day to the first date in the input parameter. For example, if the first date in the***start of code*** dates ***end of code***argument refers to June 10, 2009; then this function returns all dates equal to June 11, 2009. The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'next day sales' of Internet sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), NEXTDAY('DateTime'[DateKey])) ***end of code***
NEXTMONTH: Syntax - ***start of code*** NEXTMONTH(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - This function returns all dates from the next day to the first date in the input parameter. For example, if the first date in the***start of code*** dates ***end of code***argument refers to June 10, 2009; then this function returns all dates for the month of July, 2009. The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'next month sales' for Internet sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), NEXTMONTH('DateTime'[DateKey])) ***end of code***
NEXTQUARTER: Syntax - ***start of code*** NEXTQUARTER(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - This function returns all dates in the next quarter, based on the first date in the input parameter. For example, if the first date in the***start of code*** dates ***end of code***column refers to June 10, 2009, this function returns all dates for the quarter July to September, 2009. The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'next quarter sales' for Internet sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), NEXTQUARTER('DateTime'[DateKey])) ***end of code***
NEXTYEAR: Syntax - ***start of code*** NEXTYEAR(<dates>[,<year_end_date>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - This function returns all dates in the next year, based on the first date in the input column. For example, if the first date in the***start of code*** dates ***end of code***column refers to the year 2007, this function returns all dates for the year 2008. The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. The***start of code*** year_end_date ***end of code***parameter is a string literal of a date, in the same locale as the locale of the client where the workbook was created. The year portion of the date is ignored. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'next year sales' for Internet sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), NEXTYEAR('DateTime'[DateKey])) ***end of code***
OPENINGBALANCEMONTH: Syntax - ***start of code*** OPENINGBALANCEMONTH(<expression>,<dates>[,<filter>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value that represents the***start of code*** expression ***end of code***evaluated at the first date of the month in the current context. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. The***start of code*** filter ***end of code***expression has restrictions described in the topic,CALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'Month Start Inventory Value' of the product inventory. ***start of code*** = OPENINGBALANCEMONTH(SUMX(ProductInventory,ProductInventory[UnitCost]*ProductInventory[UnitsBalance]),DateTime[DateKey]) ***end of code***
OPENINGBALANCEQUARTER: Syntax - ***start of code*** OPENINGBALANCEQUARTER(<expression>,<dates>[,<filter>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value that represents the***start of code*** expression ***end of code***evaluated at the first date of the quarter in the current context. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. The***start of code*** filter ***end of code***expression has restrictions described in the topic,CALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'Quarter Start Inventory Value' of the product inventory. ***start of code*** = OPENINGBALANCEQUARTER(SUMX(ProductInventory,ProductInventory[UnitCost]*ProductInventory[UnitsBalance]),DateTime[DateKey]) ***end of code***
OPENINGBALANCEYEAR: Syntax - ***start of code*** OPENINGBALANCEYEAR(<expression>,<dates>[,<filter>][,<year_end_date>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value that represents the***start of code*** expression ***end of code***evaluated at the first date of the year in the current context. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. The***start of code*** filter ***end of code***expression has restrictions described in the topic,CALCULATE function. The***start of code*** year_end_date ***end of code***parameter is a string literal of a date, in the same locale as the locale of the client where the workbook was created. The year portion of the date is ignored. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'Year Start Inventory Value' of the product inventory. ***start of code*** = OPENINGBALANCEYEAR(SUMX(ProductInventory,ProductInventory[UnitCost]*ProductInventory[UnitsBalance]),DateTime[DateKey]) ***end of code***
PARALLELPERIOD: Syntax - ***start of code*** PARALLELPERIOD(<dates>,<number_of_intervals>,<interval>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - This function takes the current set of dates in the column specified by***start of code*** dates ***end of code***, shifts the first date and the last date the specified number of intervals, and then returns all contiguous dates between the two shifted dates. If the interval is a partial range of month, quarter, or year then any partial months in the result are also filled out to complete the entire interval. The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column,A table expression that returns a single column of date/time values,A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column, A table expression that returns a single column of date/time values, A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. If the number specified for***start of code*** number_of_intervals ***end of code***is positive, the dates in***start of code*** dates ***end of code***are moved forward in time; if the number is negative, the dates in***start of code*** dates ***end of code***are shifted back in time. The***start of code*** interval ***end of code***parameter is an enumeration, not a set of strings; therefore values should not be enclosed in quotation marks. Also, the values***start of code*** year ***end of code***,***start of code*** quarter ***end of code***,***start of code*** month ***end of code***should be spelled in full when using them. The result table includes only dates that appear in the values of the underlying table column. The PARALLELPERIOD function is similar to the DATEADD function except that PARALLELPERIOD always returns full periods at the given granularity level instead of the partial periods that DATEADD returns. For example, if you have a selection of dates that starts at June 10 and finishes at June 21 of the same year, and you want to shift that selection forward by one month then the PARALLELPERIOD function will return all dates from the next month (July 1 to July 31); however, if DATEADD is used instead, then the result will include only dates from July 10 to July 21. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the previous year sales for Internet sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), PARALLELPERIOD(DateTime[DateKey],-1,year)) ***end of code***
PREVIOUSDAY: Syntax - ***start of code*** PREVIOUSDAY(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - This function determines the first date in the input parameter, and then returns all dates corresponding to the day previous to that first date. For example, if the first date in the***start of code*** dates ***end of code***argument refers to June 10, 2009; this function returns all dates equal to June 9, 2009. The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE function. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'previous day sales' for Internet sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), PREVIOUSDAY('DateTime'[DateKey])) ***end of code***
PREVIOUSMONTH: Syntax - ***start of code*** PREVIOUSMONTH(<Dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - This function returns all dates from the previous month, using the first date in the column used as input. For example, if the first date in the***start of code*** Dates ***end of code***argument refers to June 10, 2009, this function returns all dates for the month of May, 2009. The***start of code*** Dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'previous month sales' for Internet sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), PREVIOUSMONTH('DateTime'[DateKey])) ***end of code***
PREVIOUSQUARTER: Syntax - ***start of code*** PREVIOUSQUARTER(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - This function returns all dates from the previous quarter, using the first date in the input column. For example, if the first date in the***start of code*** dates ***end of code***argument refers to June 10, 2009,  this function returns all dates for the quarter January to March, 2009. The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'previous quarter sales' for Internet sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), PREVIOUSQUARTER('DateTime'[DateKey])) ***end of code***
PREVIOUSYEAR: Syntax - ***start of code*** PREVIOUSYEAR(<dates>[,<year_end_date>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column of date values. ~ Remarks - This function returns all dates from the previous year given the latest date in the input parameter. For example, if the latest date in the***start of code*** dates ***end of code***argument refers to the year 2009, then this function returns all dates for the year of 2008, up to the specified***start of code*** year_end_date ***end of code***. The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE. The***start of code*** year_end_date ***end of code***parameter is a string literal of a date, in the same locale as the locale of the client where the workbook was created. The year portion of the date is ignored. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the previous year sales for Internet sales. ***start of code*** = CALCULATE(SUM(InternetSales_USD[SalesAmount_USD]), PREVIOUSYEAR('DateTime'[DateKey])) ***end of code***
SAMEPERIODLASTYEAR: Syntax - ***start of code*** SAMEPERIODLASTYEAR(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A single-column table of date values. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column,A table expression that returns a single column of date/time values,A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column, A table expression that returns a single column of date/time values, A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE. The dates returned are the same as the dates returned by this equivalent formula***start of code*** DATEADD(dates, -1, year) ***end of code*** This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the previous year sales of Reseller sales. ***start of code*** = CALCULATE(SUM(ResellerSales_USD[SalesAmount_USD]), SAMEPERIODLASTYEAR(DateTime[DateKey])) ***end of code***
STARTOFMONTH: Syntax - ***start of code*** STARTOFMONTH(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column and single row with a date value. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that returns the start of the month, for the current context. ***start of code*** = STARTOFMONTH(DateTime[DateKey]) ***end of code***
STARTOFQUARTER: Syntax - ***start of code*** STARTOFQUARTER(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column and single row with a date value. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that returns the start of the quarter, for the current context. ***start of code*** = STARTOFQUARTER(DateTime[DateKey]) ***end of code***
STARTOFYEAR: Syntax - ***start of code*** STARTOFYEAR(<dates>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing a single column and single row with a date value. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that returns the start of the year, for the current context. ***start of code*** = STARTOFYEAR(DateTime[DateKey]) ***end of code***
TOTALMTD: Syntax - ***start of code*** TOTALMTD(<expression>,<dates>[,<filter>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value that represents the***start of code*** expression ***end of code***evaluated for the dates in the current month-to-date, given the dates in***start of code*** dates ***end of code***. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE. The***start of code*** filter ***end of code***expression has restrictions described in the topic,CALCULATE. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'month running total' or 'month running sum' for Internet sales. ***start of code*** = TOTALMTD(SUM(InternetSales_USD[SalesAmount_USD]),DateTime[DateKey]) ***end of code***
TOTALQTD: Syntax - ***start of code*** TOTALQTD(<expression>,<dates>[,<filter>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value that represents the***start of code*** expression ***end of code***evaluated for all dates in the current quarter to date, given the dates in***start of code*** dates ***end of code***. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE. The***start of code*** filter ***end of code***expression has restrictions described in the topic,CALCULATE. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'quarter running total' or 'quarter running sum' for Internet sales. ***start of code*** = TOTALQTD(SUM(InternetSales_USD[SalesAmount_USD]),DateTime[DateKey]) ***end of code***
TOTALYTD: Syntax - ***start of code*** TOTALYTD(<expression>,<dates>[,<filter>][,<year_end_date>]) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A scalar value that represents the***start of code*** expression ***end of code***evaluated for the current year-to-date***start of code*** dates ***end of code***. ~ Remarks - The***start of code*** dates ***end of code***argument can be any of the followingA reference to a date/time column.A table expression that returns a single column of date/time values.A Boolean expression that defines a single-column table of date/time values. A reference to a date/time column. A table expression that returns a single column of date/time values. A Boolean expression that defines a single-column table of date/time values. Constraints on Boolean expressions are described in the topic,CALCULATE. The***start of code*** filter ***end of code***expression has restrictions described in the topic,CALCULATE. The***start of code*** year_end_date ***end of code***parameter is a string literal of a date, in the same locale as the locale of the client where the workbook was created. The year portion of the date is not required and is ignored. For example, the following formula specifies a (fiscal) year_end_date of 6/30 in an EN-US locale workbook.***start of code*** = TOTALYTD(SUM(InternetSales_USD[SalesAmount_USD]),DateTime[DateKey], ALL('DateTime'), "6/30") ***end of code***In this example, year_end_date can be specified as "6/30", "Jun 30", "30 June", or any string that resolves to a month/day. However, it is recommended you specify year_end_date using "month/day" (as shown) to ensure the string resolves to a date. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following sample formula creates a measure that calculates the 'year running total' or 'year running sum' for Internet sales. ***start of code*** = TOTALYTD(SUM(InternetSales_USD[SalesAmount_USD]),DateTime[DateKey]) ***end of code***
DISTINCT (table): Syntax - ***start of code*** DISTINCT(<table>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A table containing only distinct rows. ~ Remarks -  ~ Example - The following query ***start of code*** EVALUATE DISTINCT( { (1, "A"), (2, "B"), (1, "A") } ) ***end of code*** Returns table [Value1][Value2]1A2B
DISTINCT (column): Syntax - ***start of code*** DISTINCT(<column>) ***end of code*** ~ Parameters - No parameters found ~ Return Value - A column of unique values. ~ Remarks - The results of DISTINCT are affected by the current filter context. For example, if you use the formula in the following example to create a measure, the results would change whenever the table was filtered to show only a particular region or a time period. This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules. ~ Example - The following formula counts the number of unique customers who have generated orders over the internet channel. The table that follows illustrates the possible results when the formula is added to a report. ***start of code*** = COUNTROWS(DISTINCT(InternetSales_USD[CustomerKey])) ***end of code*** You cannot paste the list of values that DISTINCT returns directly into a column. Instead, you pass the results of the DISTINCT function to another function that counts, filters, or aggregates values by using the list. To make the example as simple as possible, here the table of distinct values has been passed to the COUNTROWS function. Row LabelsAccessoriesBikesClothingGrand Total20051013101320062677267720076792487528679309200894355451419611377Grand Total151149132685218484 Also, note that the results are not additive. That is to say, the total number of unique customers in2007is not the sum of unique customers ofAccessories,BikesandClothingfor that year. The reason is that a customer can be counted in multiple groups.
